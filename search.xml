<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>剑指 Offer 06.从尾到头打印链表</title>
    <url>/2021/05/24/%E5%89%91%E6%8C%87-Offer-06-%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><strong>输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）</strong></p>
<p>示例 1：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：head &#x3D; [1,3,2]</span><br><span class="line">输出：[2,3,1]</span><br></pre></td></tr></table></figure>


<p>限制：</p>
<p><code>0 &lt;= 链表长度 &lt;= 10000</code></p>
<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><h4 id="方式一：递归法"><a href="#方式一：递归法" class="headerlink" title="方式一：递归法"></a>方式一：递归法</h4><p>解题思路：递归到链表尾端，在回溯时存入数组。</p>
<p>算法实现：</p>
<ul>
<li>变量：先创建一个result数组，用size变量记录当前数组的下标索引，node为当前链表结点。</li>
<li>递归结束条件：当链表结点为null，node==null。</li>
<li>结果：result即为逆序排列链表数值后的数组，根据size对数组做截断并返回即可。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10000</span>];</span><br><span class="line">    <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] reversePrint(ListNode head) &#123;</span><br><span class="line">        recurGet(head);</span><br><span class="line">        <span class="keyword">return</span> Arrays.copyOfRange(result,<span class="number">0</span>,size);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recurGet</span><span class="params">(ListNode node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        recurGet(node.next);</span><br><span class="line">        result[size++] = node.val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>复杂度分析：</p>
<ul>
<li>时间复杂度O(N)：遍历整个链表</li>
<li>空间复杂度：本解法创建了一个大小为链表长度最大值的数组，结果对其做截断处理，故空间大小即为链表长度最大值；也可以使用集合代替数组，则空间复杂度为O(N)</li>
</ul>
<h4 id="方法二：栈"><a href="#方法二：栈" class="headerlink" title="方法二：栈"></a>方法二：栈</h4><p>解题思路：由于栈具有先进后出的特点，故可用来将链表倒置。</p>
<p>算法实现：创建一个栈，顺序遍历链表便依次将结点值push入栈。最后根据栈的大小创建数组result，遍历栈赋值给数组。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] reversePrint(ListNode head) &#123;</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack();</span><br><span class="line">        <span class="keyword">while</span>(head != <span class="keyword">null</span>)&#123;</span><br><span class="line">            stack.push(head.val);</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[stack.size()];</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">            result[i++] = stack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>复杂度分析：</p>
<ul>
<li>时间复杂度O(N): 先遍历链表给栈赋值（入栈），再遍历栈给数组赋值（出栈）</li>
<li>空间复杂度O(N): 栈与数组的大小均与链表长度有关</li>
</ul>
<h4 id="方法三：使用两个数组模拟栈"><a href="#方法三：使用两个数组模拟栈" class="headerlink" title="方法三：使用两个数组模拟栈"></a>方法三：使用两个数组模拟栈</h4><p>解题思路：遍历链表给第1个数组赋值，再将第1个数组逆序赋值给第2个数组</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] reversePrint(ListNode head) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] node = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10000</span>];</span><br><span class="line">        <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(head!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            node[size++] = head.val;</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[size--];</span><br><span class="line">        <span class="keyword">while</span>(size&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            result[i++] = node[size--];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>写在开头</title>
    <url>/2021/04/29/%E5%86%99%E5%9C%A8%E5%BC%80%E5%A4%B4/</url>
    <content><![CDATA[<h4 id="关于我"><a href="#关于我" class="headerlink" title="关于我"></a>关于我</h4><p>本人目前是软件工程专业的一名在读本科生，主要方向是java后台开发。平时也喜欢打篮球与听音乐，欢迎小伙伴与我交流，我的个人邮箱：<a href="mailto:&#55;&#53;&#50;&#x31;&#54;&#x30;&#54;&#53;&#53;&#x40;&#x71;&#113;&#46;&#x63;&#111;&#x6d;">&#55;&#53;&#50;&#x31;&#54;&#x30;&#54;&#53;&#53;&#x40;&#x71;&#113;&#46;&#x63;&#111;&#x6d;</a></p>
]]></content>
      <categories>
        <category>感想</category>
      </categories>
      <tags>
        <tag>感想</tag>
      </tags>
  </entry>
  <entry>
    <title>基于docker实现MySQL主从复制</title>
    <url>/2021/05/27/%E5%9F%BA%E4%BA%8Edocker%E5%AE%9E%E7%8E%B0MySQL%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/</url>
    <content><![CDATA[<h2 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h2><h4 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h4><p>主从复制是MySQL提供的一种高可用高性能的解决方案。</p>
<p>工作原理分为以下3个步骤：</p>
<p>1、主库（master）把数据更改记录到<strong>二进制日志（binlog）</strong>中。</p>
<p>2、从库（slave）的<strong>I/O线程</strong>把主库的二进制日志读取保存到自己的<strong>中继日志（relay log）</strong>中。</p>
<p>3、从库的<strong>SQL线程</strong>执行中继日志，重做中继日志中的日志，即再执行一遍SQL，更新自己的数据库，以达到数据的一致性。</p>
<p><img src="https://gitee.com/KIMTOU/img/raw/master/20210528000926.png" alt="主从复制"></p>
<p>注意要点：</p>
<p>主从复制不是完全实时地进行同步，而是<strong>异步实时</strong>。从库同步主库数据的过程是串行化的，也就是说主库上并行的操作，在从库上会串行执行。由于从库从主库拷贝日志以及串行执行 SQL 的特点，会有<strong>主从同步时延</strong>，在高并发的情况下，该问题就越明显。</p>
<h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><p>使用主从复制能够预防MySQ的单点故障，对数据进行备份。</p>
<p>在高并发下，需要对应用进行读写分离，配置多数据源，即写操作走主库，读操作则走从库，以减少锁的争用，此时也需要进行主从复制。</p>
<h4 id="部署数据库实例"><a href="#部署数据库实例" class="headerlink" title="部署数据库实例"></a>部署数据库实例</h4><p>1、拉取镜像</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker pull mysql:5.7</span><br></pre></td></tr></table></figure>

<p>2、运行容器</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 主库（端口3306）</span></span><br><span class="line">docker run -d -p 3306:3306 -e MYSQL_ROOT_PASSWORD=123456 --name master_mysql mysql:5.7</span><br><span class="line"><span class="meta">#</span><span class="bash"> 从库（端口3307）</span></span><br><span class="line">docker run -d -p 3307:3306 -e MYSQL_ROOT_PASSWORD=123456 --name slave_mysql mysql:5.7</span><br></pre></td></tr></table></figure>

<p>3、查看状态</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker ps	#查看是否运行成功</span><br></pre></td></tr></table></figure>

<p>4、使用Navicat等数据库管理工具进行连接</p>
<h4 id="主从复制配置"><a href="#主从复制配置" class="headerlink" title="主从复制配置"></a>主从复制配置</h4><p><strong>一、配置主库</strong></p>
<ul>
<li>进入容器修改配置文件</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker exec -it master_mysql /bin/bash</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">由于容器内没有vim工具，需进行安装</span></span><br><span class="line">apt-get update</span><br><span class="line">apt-get install vim</span><br><span class="line"></span><br><span class="line">vim /etc/mysql/my.cnf</span><br></pre></td></tr></table></figure>

<ul>
<li>在 my.cnf 配置文件中添加如下代码</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">server-id=10</span><br><span class="line">log-bin=mysql-bin</span><br><span class="line">innodb_flush_log_at_trx_commit=1</span><br><span class="line">sync_binlog=1</span><br></pre></td></tr></table></figure>

<img src="https://gitee.com/KIMTOU/img/raw/master/20210528000934.PNG" alt="mycnf" style="zoom: 67%;" />



<ul>
<li>进入<strong>主库</strong>为<strong>从库</strong>创建一个用户用来复制数据，从库通过这个用户连接至主库</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 登录mysql</span></span><br><span class="line">mysql -u root -p</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 创建用户</span></span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> CREATE user <span class="string">&#x27;slave&#x27;</span>@<span class="string">&#x27;%&#x27;</span> identified by <span class="string">&#x27;slave&#x27;</span>;</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 赋予权限</span></span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> GRANT REPLICATION SLAVE, REPLICATION CLIENT ON *.* TO <span class="string">&#x27;slave&#x27;</span>@<span class="string">&#x27;%&#x27;</span>;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>查看主库状态</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> show master status;</span></span><br><span class="line">+------------------+----------+--------------+------------------+-------------------+</span><br><span class="line">| File             | Position | Binlog_Do_DB | Binlog_Ignore_DB | Executed_Gtid_Set |</span><br><span class="line">+------------------+----------+--------------+------------------+-------------------+</span><br><span class="line">| mysql-bin.000001 |     617  |              |                  |                   |</span><br><span class="line">+------------------+----------+--------------+------------------+-------------------+</span><br></pre></td></tr></table></figure>

<ul>
<li>重启生效</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker restart master_mysql</span><br></pre></td></tr></table></figure>



<p><strong>二、从库配置</strong></p>
<ul>
<li>同样的进入容器修改配置文件</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker exec -it slave_mysql /bin/bash</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">由于容器内没有vim工具，需进行安装</span></span><br><span class="line">apt-get update</span><br><span class="line">apt-get install vim</span><br><span class="line"></span><br><span class="line">vim /etc/mysql/my.cnf</span><br></pre></td></tr></table></figure>

<ul>
<li>在 my.cnf 配置文件中添加如下代码</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">server_id=11</span><br><span class="line">log-bin=mysql-slave-bin</span><br><span class="line">relay_log=edu-mysql-relay-bin</span><br></pre></td></tr></table></figure>

<ul>
<li>重启生效</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker restart slave_mysql</span><br></pre></td></tr></table></figure>



<p><strong>三、绑定主库</strong></p>
<ul>
<li>docker查看主mysql容器的ip</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker inspect --format=&#x27;&#123;&#123;.NetworkSettings.IPAddress&#125;&#125;&#x27; master_mysql</span><br></pre></td></tr></table></figure>

<ul>
<li>进入从库</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker exec -it slave_mysql /bin/bash</span><br><span class="line">mysql -u root -p</span><br></pre></td></tr></table></figure>

<ul>
<li>绑定主库</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> change master to master_host=<span class="string">&#x27;172.17.0.2&#x27;</span>, master_user=<span class="string">&#x27;slave&#x27;</span>, master_password=<span class="string">&#x27;slave&#x27;</span>, master_port=3306, master_log_file=<span class="string">&#x27;mysql-bin.000001&#x27;</span>, master_log_pos=617, master_connect_retry=30;</span></span><br></pre></td></tr></table></figure>

<p>这里的<strong>master_host</strong>为刚刚查到的<strong>主mysql容器的ip</strong>，是容器独立的ip </p>
<ul>
<li>查看从库的状态</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">show slave status \G;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 发现IO线程和SQL线程运行状态都为No，默认是没有开启，需要手动开启</span></span><br><span class="line">Slave_IO_Running: No</span><br><span class="line">Slave_SQL_Running: No</span><br></pre></td></tr></table></figure>

<ul>
<li>开启主从复制</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">start slave;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
</search>
