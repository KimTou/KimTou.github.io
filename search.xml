<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Java 8新特性：Lambda表达式, Stream API, Optional类</title>
    <url>/2021/08/15/Java-8%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%9ALambda%E8%A1%A8%E8%BE%BE%E5%BC%8F-Stream-API-Optional%E7%B1%BB/</url>
    <content><![CDATA[<p>在 Java 8 中，增加了Lambda表达式、函数式接口、接口的默认方法和静态方法等语言新特性；在类库方面又新增了Stream API、Optional类等。</p>
<h2 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h2><p>Lambda 表达式 − Lambda允许把函数作为一个方法的参数（函数作为参数传递进方法中。</p>
<h2 id="Stream-API"><a href="#Stream-API" class="headerlink" title="Stream API"></a>Stream API</h2><h3 id="什么是Stream"><a href="#什么是Stream" class="headerlink" title="什么是Stream"></a>什么是Stream</h3><blockquote>
<p>Stream（流）是一个来自数据源的元素队列，它可以支持聚合操作，极大简化了集合的操作。</p>
<ul>
<li>数据源：流的数据来源，构造Stream对象的数据源，比如通过一个List来构造Stream对象，这个List就是数据源；</li>
<li>聚合操作：对Stream对象进行处理后使得Stream对象返回指定规则数据的操作称之为聚合操作，比如filter、map、limit、sorted等都是聚合操作。</li>
</ul>
</blockquote>
<h3 id="Stream聚合操作"><a href="#Stream聚合操作" class="headerlink" title="Stream聚合操作"></a>Stream聚合操作</h3><p>这里使用一个实体类（User）作为示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Long userId;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例数据：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">User user1 = <span class="keyword">new</span> User(<span class="number">1001L</span>, <span class="string">&quot;小明&quot;</span>, <span class="number">21</span>, <span class="string">&quot;深圳&quot;</span>);</span><br><span class="line">User user2 = <span class="keyword">new</span> User(<span class="number">1002L</span>, <span class="string">&quot;小红&quot;</span>, <span class="number">23</span>, <span class="string">&quot;成都&quot;</span>);</span><br><span class="line">User user3 = <span class="keyword">new</span> User(<span class="number">1003L</span>, <span class="string">&quot;小华&quot;</span>, <span class="number">25</span>, <span class="string">&quot;广州&quot;</span>);</span><br><span class="line">User user4 = <span class="keyword">new</span> User(<span class="number">1004L</span>, <span class="string">&quot;大海&quot;</span>, <span class="number">30</span>, <span class="string">&quot;杭州&quot;</span>);</span><br><span class="line">List&lt;User&gt; userList = Arrays.asList(user1, user2, user3, user4);</span><br></pre></td></tr></table></figure>

<h4 id="流的创建"><a href="#流的创建" class="headerlink" title="流的创建"></a>流的创建</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="comment">//创建一个顺序流</span></span><br><span class="line">Stream&lt;String&gt; stream = list.stream();</span><br><span class="line"><span class="comment">//创建一个并行流</span></span><br><span class="line">Stream&lt;String&gt; parallelStream = list.parallelStream();</span><br><span class="line"></span><br><span class="line"><span class="comment">//将示例数据转换成流</span></span><br><span class="line">Stream&lt;User&gt; userStream = userList.stream();</span><br></pre></td></tr></table></figure>

<ul>
<li>顺序流与并行流的区别</li>
</ul>
<p>stream是顺序流，由主线程按顺序对流执行操作； parallelStream是并行流，内部以多线程并行执行的方式对流进行操作，但前提是流中的数据处理没有顺序要求。</p>
<h4 id="collect收集"><a href="#collect收集" class="headerlink" title="collect收集"></a>collect收集</h4><p><strong>collect方法用于传入一个Collector实例，将流转换为其他数据结构并返回</strong></p>
<ul>
<li>将List集合转换为Set集合</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Set&lt;User&gt; collect = userList.stream()</span><br><span class="line">        .collect(Collectors.toSet());</span><br></pre></td></tr></table></figure>

<ul>
<li>将List集合转换为Map集合</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;Long, User&gt; collect = userList.stream()</span><br><span class="line">        .collect(Collectors.toMap(User::getUserId, user -&gt; user));</span><br></pre></td></tr></table></figure>

<h4 id="filter过滤"><a href="#filter过滤" class="headerlink" title="filter过滤"></a>filter过滤</h4><p><strong>根据一定规则对stream流进行过滤，将符合条件的元素提取到新的流中</strong></p>
<ul>
<li>筛选出List集合大于6的数据</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamAPI</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; list = Arrays.asList(<span class="number">2</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>);</span><br><span class="line">        Stream&lt;Integer&gt; stream = list.stream();</span><br><span class="line">        stream.filter(num -&gt; num &gt; <span class="number">6</span>).forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>将示例数据中年龄大于24的数据筛选出来</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;User&gt; collect = userList.stream()</span><br><span class="line">                .filter(user -&gt; user.getAge() &lt; <span class="number">24</span>)</span><br><span class="line">                .collect(Collectors.toList());</span><br></pre></td></tr></table></figure>

<h4 id="map映射"><a href="#map映射" class="headerlink" title="map映射"></a>map映射</h4><p>将流的元素按照一定映射规则进行转换处理后映射到另一个流中</p>
<ul>
<li>将实例集合中的对象的name映射为新的List集合</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; collect = userList.stream()</span><br><span class="line">        .map(user -&gt; user.getUserName())</span><br><span class="line">        .collect(Collectors.toList());</span><br></pre></td></tr></table></figure>

<h4 id="distinct去重"><a href="#distinct去重" class="headerlink" title="distinct去重"></a>distinct去重</h4><p>将stream流中的相同元素进行去重处理（通过流中元素的 hashCode() 和 equals() 去除重复元素）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;User&gt; collect = userList.stream()</span><br><span class="line">        .distinct()</span><br><span class="line">        .collect(Collectors.toList());</span><br></pre></td></tr></table></figure>

<h4 id="limit"><a href="#limit" class="headerlink" title="limit"></a>limit</h4><p>从stream流中获取指定个数的元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;User&gt; collect = userList.stream()</span><br><span class="line">        .limit(<span class="number">2</span>)</span><br><span class="line">        .collect(Collectors.toList());</span><br></pre></td></tr></table></figure>

<h4 id="skip"><a href="#skip" class="headerlink" title="skip"></a>skip</h4><p>跳过指定个数的流中的元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;User&gt; collect = userList.stream()</span><br><span class="line">        .skip(<span class="number">2</span>)</span><br><span class="line">        .collect(Collectors.toList());</span><br></pre></td></tr></table></figure>

<h4 id="分页操作"><a href="#分页操作" class="headerlink" title="分页操作"></a>分页操作</h4><p>使用limit配合skip可实现分页操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;User&gt; collect = userList.stream()</span><br><span class="line">        .skip(<span class="number">0</span>)</span><br><span class="line">        .limit(<span class="number">2</span>)</span><br><span class="line">        .collect(Collectors.toList());</span><br></pre></td></tr></table></figure>

<h4 id="count"><a href="#count" class="headerlink" title="count"></a>count</h4><p>返回stream流中元素个数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">long</span> count = userList.stream().count();</span><br></pre></td></tr></table></figure>

<h4 id="sorted排序"><a href="#sorted排序" class="headerlink" title="sorted排序"></a>sorted排序</h4><p>按照某种规则对元素进行排序</p>
<p>排序有两种方式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 自然排序，流中元素需要实现Comparable接口</span></span><br><span class="line"><span class="function">Stream&lt;T&gt; <span class="title">sorted</span><span class="params">()</span></span>;		</span><br><span class="line"><span class="comment">// Comparator自定义排序</span></span><br><span class="line"><span class="function">Stream&lt;T&gt; <span class="title">sorted</span><span class="params">(Comparator&lt;? <span class="keyword">super</span> T&gt; comparator)</span></span>;	</span><br></pre></td></tr></table></figure>

<ul>
<li>年龄大的排在前面</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;User&gt; collect = userList.stream()</span><br><span class="line">        .sorted((userA, userB) -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> userB.getAge().compareTo(userA.getAge());</span><br><span class="line">        &#125;)</span><br><span class="line">        .collect(Collectors.toList());</span><br></pre></td></tr></table></figure>



<h2 id="Optional类"><a href="#Optional类" class="headerlink" title="Optional类"></a>Optional类</h2><p>Optional类主要是用于解决<strong>空指针异常NullPointerException</strong>，它能帮助我们减少各种null检查的代码，使程序变得更加简洁，从Java 8开始成为类库的一部分。</p>
<h4 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h4><p>从下面源码可以发现，Optional类维护了一个变量value，初始时其值为null。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Optional</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Optional&lt;?&gt; EMPTY = <span class="keyword">new</span> Optional&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> T value;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Optional</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span>&lt;T&gt; Optional&lt;T&gt; <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">        Optional&lt;T&gt; t = (Optional&lt;T&gt;) EMPTY;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Constructs an instance with the value present.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Optional</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = Objects.requireNonNull(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns an &#123;<span class="doctag">@code</span> Optional&#125; with the specified present non-null value.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Optional&lt;T&gt; <span class="title">of</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Optional&lt;&gt;(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Optional&lt;T&gt; <span class="title">ofNullable</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value == <span class="keyword">null</span> ? empty() : of(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果value值为空，则抛出异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException(<span class="string">&quot;No value present&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p>可以看到，<code>of</code>以及<code>ofNullable</code>这两个方法都可以创建Optional对象，那么它们有上面不同呢。主要在于使用<code>of</code>方法创建对象时，如果传入的value值为null，则会报NullPointerException空指针异常；而<code>ofNullable</code>方法不会报空指针异常，而是创建一个空的Optional对象。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://blog.nowcoder.net/n/4e5c389e638147938bcd7b2340474a45">字节二面被问“Java Stream 流操作‘’？看完这篇，教你自信应对！</a></p>
<p><a href="http://www.macrozheng.com/#/technology/java_stream?id=java-8%E9%83%BD%E5%87%BA%E9%82%A3%E4%B9%88%E4%B9%85%E4%BA%86%EF%BC%8Cstream-api%E4%BA%86%E8%A7%A3%E4%B8%8B%EF%BC%9F">Java 8都出那么久了，Stream API了解下？</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot实现MySQL读写分离</title>
    <url>/2021/05/27/SpringBoot%E5%AE%9E%E7%8E%B0MySQL%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB/</url>
    <content><![CDATA[<h2 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a>读写分离</h2><p>在高并发下，需要对应用进行读写分离，配置多数据源，即写操作走主库，读操作则走从库，主从数据库负责各自的读和写，缓解了锁的争用，提高了读取性能。</p>
<p>实现读写分离有多种方式，如使用中间件MyCat、Sharding-JDBC等，这里我们使用<strong>Aop</strong>的方式在代码层面实现读写分离。</p>
<h4 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h4><p>实现读写分离，首先要对Mysql做主从复制，即搭建一个主数据库，以及一个或多个从数据库。</p>
<p>具体实现主从复制，可参照<a href="https://blog.tojintao.cn/2021/05/27/%E5%9F%BA%E4%BA%8Edocker%E5%AE%9E%E7%8E%B0MySQL%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/">《基于docker实现MySQL主从复制》</a></p>
<p>使用Aop的方式，当调用业务层方法前，判断请求是否是只读操作，动态切换数据源，如果是只读操作，则切换从数据库的数据源，否则使用主数据库的数据源。</p>
<h4 id="系统架构"><a href="#系统架构" class="headerlink" title="系统架构"></a>系统架构</h4><p>:rocket: 项目仓库：<a href="https://github.com/KimTou/Open-LetFit">KimTou/Open-LetFit: LetFit小程序后台开源版 </a></p>
<p>这是我之前写的一个项目，具体代码可以在可以在上面我的GitHub仓库中找到，项目就是使用了本文章介绍的读写分离方式，感兴趣的同学可以作为参考。</p>
<p><img src="https://gitee.com/KIMTOU/img/raw/master/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84.png"></p>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><ul>
<li><strong>在application.yml配置MySQL</strong></li>
</ul>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">com.alibaba.druid.pool.DruidDataSource</span></span><br><span class="line">    <span class="comment">#主机</span></span><br><span class="line">    <span class="attr">master:</span></span><br><span class="line">      <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">      <span class="attr">password:</span> <span class="number">123456</span></span><br><span class="line">      <span class="attr">url:</span> <span class="string">jdbc:mysql://服务器ip:3306/letfit?useSSL=false&amp;useUnicode=true&amp;characterEncoding=utf8&amp;serverTimezone=GMT</span></span><br><span class="line">      <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">    <span class="comment">#从机</span></span><br><span class="line">    <span class="attr">slave:</span></span><br><span class="line">      <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">      <span class="attr">password:</span> <span class="number">123456</span></span><br><span class="line">      <span class="attr">url:</span> <span class="string">jdbc:mysql://服务器ip:3307/letfit?useSSL=false&amp;useUnicode=true&amp;characterEncoding=utf8&amp;serverTimezone=GMT</span></span><br><span class="line">      <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">    <span class="comment">#连接池</span></span><br><span class="line">    <span class="attr">druid:</span></span><br><span class="line">      <span class="attr">initialSize:</span> <span class="number">5</span></span><br><span class="line">      <span class="attr">minIdle:</span> <span class="number">5</span></span><br><span class="line">      <span class="attr">maxActive:</span> <span class="number">20</span></span><br><span class="line">      <span class="attr">maxWait:</span> <span class="number">60000</span></span><br><span class="line">      <span class="attr">timeBetweenEvictionRunsMillis:</span> <span class="number">60000</span></span><br><span class="line">      <span class="attr">minEvictableIdleTimeMillis:</span> <span class="number">300000</span></span><br><span class="line">      <span class="attr">validationQuery:</span> <span class="string">SELECT</span> <span class="number">1</span> <span class="string">FROM</span> <span class="string">DUAL</span></span><br><span class="line">      <span class="attr">testWhileIdle:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">testOnBorrow:</span> <span class="literal">false</span></span><br><span class="line">      <span class="attr">testOnReturn:</span> <span class="literal">false</span></span><br><span class="line">      <span class="attr">poolPreparedStatements:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">filters:</span> <span class="string">stat,wall</span></span><br><span class="line">      <span class="attr">maxPoolPreparedStatementPerConnectionSize:</span> <span class="number">20</span></span><br><span class="line">      <span class="attr">useGlobalDataSourceStat:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">connectionProperties:</span> <span class="string">druid.stat.mergeSql=true;druid.stat.slowSqlMillis=500</span></span><br></pre></td></tr></table></figure>



<ul>
<li><strong>创建 <code>ReadOnly</code> 注解</strong></li>
</ul>
<p>在业务层的方法上使用该注解，使用 <code>ReadOnly</code> 注解的方法只处理读操作，会切换到从机的数据源</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.letfit.aop.annotation;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 只读注解</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.METHOD, ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> ReadOnly &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li><strong>创建枚举类</strong></li>
</ul>
<p>定义两个枚举类型 <code>MASTER</code>、<code>slave</code>分别代表数据库类型</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.letfit.common;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 数据库类型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">DBTypeEnum</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 主数据库</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    MASTER,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从数据库</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    SLAVE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li><strong>编写动态切换数据源的工具类</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.letfit.util;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 动态切换数据源工具类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicDbUtil</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用来存储代表数据源的对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;DBTypeEnum&gt; CONTEXT_HAND = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 切换当前线程要使用的数据源</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> dbTypeEnum</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(DBTypeEnum dbTypeEnum)</span></span>&#123;</span><br><span class="line">        CONTEXT_HAND.set(dbTypeEnum);</span><br><span class="line">        log.info(<span class="string">&quot;切换数据源:&#123;&#125;&quot;</span>, dbTypeEnum);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 切换到主数据库</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">master</span><span class="params">()</span></span>&#123;</span><br><span class="line">        set(DBTypeEnum.MASTER);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 切换到从数据库</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">slave</span><span class="params">()</span></span>&#123;</span><br><span class="line">        set(DBTypeEnum.SLAVE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 移除当前线程使用的数据源</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span></span>&#123;</span><br><span class="line">        CONTEXT_HAND.remove();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取当前线程使用的枚举类</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DBTypeEnum <span class="title">get</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> CONTEXT_HAND.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li><strong>编写 <code>AbstractRoutingDataSource</code>的实现类</strong></li>
</ul>
<blockquote>
<p>Spring boot提供了AbstractRoutingDataSource 根据用户定义的规则选择当前的数据源，这样我们可以在执行查询之前，设置使用的数据源。实现可动态路由的数据源，在每次数据库查询操作前执行。它的抽象方法 determineCurrentLookupKey() 决定使用哪个数据源。</p>
</blockquote>
<p>AbstractRoutingDataSource 的部分源码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractRoutingDataSource</span> <span class="keyword">extends</span> <span class="title">AbstractDataSource</span> <span class="keyword">implements</span> <span class="title">InitializingBean</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 用来存储多个数据源</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;Object, Object&gt; targetDataSources;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 默认数据源</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">private</span> Object defaultTargetDataSource;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;Object, DataSource&gt; resolvedDataSources;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">private</span> DataSource resolvedDefaultDataSource;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AbstractRoutingDataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 设置多数据源，最终使用哪个数据源由determineTargetDataSource()返回决定</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTargetDataSources</span><span class="params">(Map&lt;Object, Object&gt; targetDataSources)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.targetDataSources = targetDataSources;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 设置默认数据源</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDefaultTargetDataSource</span><span class="params">(Object defaultTargetDataSource)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.defaultTargetDataSource = defaultTargetDataSource;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 决定使用的数据源，选择的策略需要我们自己去定义</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> DataSource <span class="title">determineTargetDataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Assert.notNull(<span class="keyword">this</span>.resolvedDataSources, <span class="string">&quot;DataSource router not initialized&quot;</span>);</span><br><span class="line">        <span class="comment">//调用determineCurrentLookupKey()获取数据源的key</span></span><br><span class="line">        Object lookupKey = <span class="keyword">this</span>.determineCurrentLookupKey();</span><br><span class="line">        <span class="comment">//根据key获取对应数据源</span></span><br><span class="line">        DataSource dataSource = (DataSource)<span class="keyword">this</span>.resolvedDataSources.get(lookupKey);</span><br><span class="line">        <span class="keyword">if</span> (dataSource == <span class="keyword">null</span> &amp;&amp; (<span class="keyword">this</span>.lenientFallback || lookupKey == <span class="keyword">null</span>)) &#123;</span><br><span class="line">            dataSource = <span class="keyword">this</span>.resolvedDefaultDataSource;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (dataSource == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Cannot determine target DataSource for lookup key [&quot;</span> + lookupKey + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> dataSource;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 抽象方法，需要我们自己去实现</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> Object <span class="title">determineCurrentLookupKey</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编写 <code>DynamicDataSource</code>继承 <code>AbstractRoutingDataSource</code>    </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.letfit.common;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicDataSource</span> <span class="keyword">extends</span> <span class="title">AbstractRoutingDataSource</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回当前线程正在使用代表数据库的枚举对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">determineCurrentLookupKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> DynamicDbUtil.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>流程步骤：</p>
<p>1、重写数据源选择策略determineCurrentLookupKey()。</p>
<p>2、数据源配置类将数据源存放在AbstractRoutingDataSource的 targetDataSources和defaultTargetDataSource中，然后通过afterPropertiesSet()方法将数据源分别进行复制到resolvedDataSources和resolvedDefaultDataSource中。</p>
<p>3、进行数据库连接时，调用AbstractRoutingDataSource的getConnection()的方法，此时会先调用determineTargetDataSource()方法返回DataSource再进行getConnection()。</p>
<ul>
<li><strong>编写多数据源配置类</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.letfit.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.druid.spring.boot.autoconfigure.DruidDataSourceBuilder;</span><br><span class="line"><span class="keyword">import</span> com.letfit.common.DBTypeEnum;</span><br><span class="line"><span class="keyword">import</span> com.letfit.common.DynamicDataSource;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Qualifier;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.context.properties.ConfigurationProperties;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Primary;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.sql.DataSource;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DataSourceConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 主数据库数据源，存入Spring容器</span></span><br><span class="line"><span class="comment">     * 注解<span class="doctag">@Primary</span>表示主数据源</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ConfigurationProperties(prefix = &quot;spring.datasource.master&quot;)</span></span><br><span class="line">    <span class="meta">@Primary</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">masterDataSource</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> DruidDataSourceBuilder.create().build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从数据库数据源，存入Spring容器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ConfigurationProperties(prefix = &quot;spring.datasource.slave&quot;)</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">slaveDataSource</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> DruidDataSourceBuilder.create().build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 决定最终数据源</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> masterDataSource</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> slaveDataSource</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">targetDataSource</span><span class="params">(<span class="meta">@Qualifier(&quot;masterDataSource&quot;)</span> DataSource masterDataSource, <span class="meta">@Qualifier(&quot;slaveDataSource&quot;)</span> DataSource slaveDataSource)</span></span>&#123;</span><br><span class="line">        <span class="comment">//存放主从数据源</span></span><br><span class="line">        Map&lt;Object,Object&gt; targetDataSource = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">2</span>);</span><br><span class="line">        <span class="comment">//主数据源</span></span><br><span class="line">        targetDataSource.put(DBTypeEnum.MASTER, masterDataSource);</span><br><span class="line">        <span class="comment">//从数据源</span></span><br><span class="line">        targetDataSource.put(DBTypeEnum.SLAVE, slaveDataSource);</span><br><span class="line">        <span class="comment">//实现动态切换</span></span><br><span class="line">        DynamicDataSource dynamicDataSource = <span class="keyword">new</span> DynamicDataSource();</span><br><span class="line">        <span class="comment">//绑定所有数据源</span></span><br><span class="line">        dynamicDataSource.setTargetDataSources(targetDataSource);</span><br><span class="line">        <span class="comment">//设置默认数据源</span></span><br><span class="line">        dynamicDataSource.setDefaultTargetDataSource(masterDataSource);</span><br><span class="line">        <span class="keyword">return</span> dynamicDataSource;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li><strong>配置Mybatis</strong></li>
</ul>
<p>当我们只有一个数据源时，SpringBoot会默认配置Mybatis，现在我们有多个数据源，就需要手动配置Mybatis的SqlSessionFactory</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.letfit.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.session.SqlSessionFactory;</span><br><span class="line"><span class="keyword">import</span> org.mybatis.spring.SqlSessionFactoryBean;</span><br><span class="line"><span class="keyword">import</span> org.mybatis.spring.SqlSessionTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Qualifier;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.io.support.PathMatchingResourcePatternResolver;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.datasource.DataSourceTransactionManager;</span><br><span class="line"><span class="keyword">import</span> org.springframework.transaction.PlatformTransactionManager;</span><br><span class="line"><span class="keyword">import</span> org.springframework.transaction.annotation.EnableTransactionManagement;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.Resource;</span><br><span class="line"><span class="keyword">import</span> javax.sql.DataSource;</span><br><span class="line"><span class="keyword">import</span> java.util.Objects;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 多数据源需要手动配置SqlSessionFactory</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableTransactionManagement</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MybatisConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource(name = &quot;targetDataSource&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> DataSource dataSource;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 配置SqlSessionFactory</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SqlSessionFactory <span class="title">sqlSessionFactory</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        SqlSessionFactoryBean factoryBean = <span class="keyword">new</span> SqlSessionFactoryBean();</span><br><span class="line">        factoryBean.setDataSource(dataSource);</span><br><span class="line">        <span class="comment">//配置映射文件路径</span></span><br><span class="line">        factoryBean.setMapperLocations(<span class="keyword">new</span> PathMatchingResourcePatternResolver().getResources(<span class="string">&quot;classpath:mapper/*.xml&quot;</span>));</span><br><span class="line">        <span class="comment">//配置别名</span></span><br><span class="line">        factoryBean.setTypeAliasesPackage(<span class="string">&quot;com.letfit.pojo&quot;</span>);</span><br><span class="line">        <span class="comment">//设置驼峰命名</span></span><br><span class="line">        Objects.requireNonNull(factoryBean.getObject()).getConfiguration().setMapUnderscoreToCamelCase(<span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">return</span> factoryBean.getObject();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 配置事务管理</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> PlatformTransactionManager <span class="title">transactionManager</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DataSourceTransactionManager(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SqlSessionTemplate <span class="title">sqlSessionTemplate</span><span class="params">(<span class="meta">@Qualifier(&quot;sqlSessionFactory&quot;)</span> SqlSessionFactory sqlSessionFactory)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SqlSessionTemplate(sqlSessionFactory);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li><strong>配置Aop</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.letfit.aop;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DataSourceAop</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Pointcut(&quot;@annotation(com.letfit.aop.annotation.ReadOnly)&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readPointcut</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 配置前置通知，切换数据源为从数据库</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Before(&quot;readPointcut()&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readAdvise</span><span class="params">()</span></span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;切换数据源为从数据库&quot;</span>);</span><br><span class="line">        DynamicDbUtil.slave();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li><strong>业务层方法上使用 <code>ReadOnly</code> 注解</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据标题关键字模糊查询资源</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> title</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@ReadOnly</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> ResultInfo&lt;List&lt;Source&gt;&gt; searchSource(String title) &#123;</span><br><span class="line">    <span class="keyword">if</span>(!ValiDateUtil.isLegalString(title))&#123;</span><br><span class="line">        <span class="keyword">return</span> ResultInfo.error(CodeEnum.PARAM_NOT_IDEAL, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;Source&gt; sourceList = sourceMapper.searchSource(title);</span><br><span class="line">    <span class="keyword">return</span> ResultInfo.success(CodeEnum.SUCCESS, sourceList);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><img src="https://gitee.com/KIMTOU/img/raw/master/20210528134946.png" alt="从数据源"></p>
<ul>
<li>至此，读写分离的工作就完成了！</li>
</ul>
]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>SpingBoot</tag>
        <tag>MySQL</tag>
        <tag>环境配置</tag>
      </tags>
  </entry>
  <entry>
    <title>写在开头</title>
    <url>/2021/04/29/%E5%86%99%E5%9C%A8%E5%BC%80%E5%A4%B4/</url>
    <content><![CDATA[<h4 id="关于我"><a href="#关于我" class="headerlink" title="关于我"></a>关于我</h4><p>本人目前是软件工程专业的一名在读本科生，主要方向是java后台开发。平时也喜欢打篮球与听音乐，欢迎小伙伴与我交流，我的个人邮箱：<a href="mailto:&#x37;&#x35;&#x32;&#x31;&#54;&#x30;&#x36;&#x35;&#53;&#x40;&#113;&#113;&#x2e;&#x63;&#111;&#109;">&#x37;&#x35;&#x32;&#x31;&#54;&#x30;&#x36;&#x35;&#53;&#x40;&#113;&#113;&#x2e;&#x63;&#111;&#109;</a></p>
]]></content>
      <categories>
        <category>感想</category>
      </categories>
      <tags>
        <tag>感想</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指 Offer 06.从尾到头打印链表</title>
    <url>/2021/05/24/%E5%89%91%E6%8C%87-Offer-06-%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><strong>输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）</strong></p>
<p>示例 1：</p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">输入：head = <span class="comment">[1,3,2]</span></span><br><span class="line">输出：<span class="comment">[2,3,1]</span></span><br></pre></td></tr></table></figure>


<p>限制：</p>
<p><code>0 &lt;= 链表长度 &lt;= 10000</code></p>
<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><h4 id="方式一：递归法"><a href="#方式一：递归法" class="headerlink" title="方式一：递归法"></a>方式一：递归法</h4><p>解题思路：递归到链表尾端，在回溯时存入数组。</p>
<p>算法实现：</p>
<ul>
<li>变量：先创建一个result数组，用size变量记录当前数组的下标索引，node为当前链表结点。</li>
<li>递归结束条件：当链表结点为null，node==null。</li>
<li>结果：result即为逆序排列链表数值后的数组，根据size对数组做截断并返回即可。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10000</span>];</span><br><span class="line">    <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] reversePrint(ListNode head) &#123;</span><br><span class="line">        recurGet(head);</span><br><span class="line">        <span class="keyword">return</span> Arrays.copyOfRange(result,<span class="number">0</span>,size);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recurGet</span><span class="params">(ListNode node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        recurGet(node.next);</span><br><span class="line">        result[size++] = node.val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>复杂度分析：</p>
<ul>
<li>时间复杂度O(N)：遍历整个链表</li>
<li>空间复杂度：本解法创建了一个大小为链表长度最大值的数组，结果对其做截断处理，故空间大小即为链表长度最大值；也可以使用集合代替数组，则空间复杂度为O(N)</li>
</ul>
<h4 id="方法二：栈"><a href="#方法二：栈" class="headerlink" title="方法二：栈"></a>方法二：栈</h4><p>解题思路：由于栈具有先进后出的特点，故可用来将链表倒置。</p>
<p>算法实现：创建一个栈，顺序遍历链表便依次将结点值push入栈。最后根据栈的大小创建数组result，遍历栈赋值给数组。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] reversePrint(ListNode head) &#123;</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack();</span><br><span class="line">        <span class="keyword">while</span>(head != <span class="keyword">null</span>)&#123;</span><br><span class="line">            stack.push(head.val);</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[stack.size()];</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">            result[i++] = stack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>复杂度分析：</p>
<ul>
<li>时间复杂度O(N): 先遍历链表给栈赋值（入栈），再遍历栈给数组赋值（出栈）</li>
<li>空间复杂度O(N): 栈与数组的大小均与链表长度有关</li>
</ul>
<h4 id="方法三：使用两个数组模拟栈"><a href="#方法三：使用两个数组模拟栈" class="headerlink" title="方法三：使用两个数组模拟栈"></a>方法三：使用两个数组模拟栈</h4><p>解题思路：遍历链表给第1个数组赋值，再将第1个数组逆序赋值给第2个数组</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] reversePrint(ListNode head) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] node = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10000</span>];</span><br><span class="line">        <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(head!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            node[size++] = head.val;</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[size--];</span><br><span class="line">        <span class="keyword">while</span>(size&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            result[i++] = node[size--];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>基于docker实现MySQL主从复制</title>
    <url>/2021/05/27/%E5%9F%BA%E4%BA%8Edocker%E5%AE%9E%E7%8E%B0MySQL%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/</url>
    <content><![CDATA[<h2 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h2><h4 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h4><p>主从复制是MySQL提供的一种高可用高性能的解决方案。</p>
<p>工作原理分为以下3个步骤：</p>
<p>1、主库（master）把数据更改记录到<strong>二进制日志（binlog）</strong>中。</p>
<p>2、从库（slave）的<strong>I/O线程</strong>把主库的二进制日志读取保存到自己的<strong>中继日志（relay log）</strong>中。</p>
<p>3、从库的<strong>SQL线程</strong>执行中继日志，重做中继日志中的日志，即再执行一遍SQL，更新自己的数据库，以达到数据的一致性。</p>
<p><img src="https://gitee.com/KIMTOU/img/raw/master/20210528000926.png" alt="主从复制"></p>
<p>注意要点：</p>
<p>主从复制不是完全实时地进行同步，而是<strong>异步实时</strong>。从库同步主库数据的过程是串行化的，也就是说主库上并行的操作，在从库上会串行执行。由于从库从主库拷贝日志以及串行执行 SQL 的特点，会有<strong>主从同步时延</strong>，在高并发的情况下，该问题就越明显。</p>
<h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><p>使用主从复制能够预防MySQ的单点故障，对数据进行备份。</p>
<p>在高并发下，需要对应用进行读写分离，配置多数据源，即写操作走主库，读操作则走从库，以减少锁的争用，此时也需要进行主从复制。</p>
<h4 id="部署数据库实例"><a href="#部署数据库实例" class="headerlink" title="部署数据库实例"></a>部署数据库实例</h4><p>1、拉取镜像</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker pull mysql:5.7</span><br></pre></td></tr></table></figure>

<p>2、运行容器</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 主库（端口3306）</span></span><br><span class="line">docker run -d -p 3306:3306 -e MYSQL_ROOT_PASSWORD=123456 --name master_mysql mysql:5.7</span><br><span class="line"><span class="meta">#</span><span class="bash"> 从库（端口3307）</span></span><br><span class="line">docker run -d -p 3307:3306 -e MYSQL_ROOT_PASSWORD=123456 --name slave_mysql mysql:5.7</span><br></pre></td></tr></table></figure>

<p>3、查看状态</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker ps	#查看是否运行成功</span><br></pre></td></tr></table></figure>

<p>4、使用Navicat等数据库管理工具进行连接</p>
<h4 id="主从复制配置"><a href="#主从复制配置" class="headerlink" title="主从复制配置"></a>主从复制配置</h4><p><strong>一、配置主库</strong></p>
<ul>
<li>进入容器修改配置文件</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker exec -it master_mysql /bin/bash</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">由于容器内没有vim工具，需进行安装</span></span><br><span class="line">apt-get update</span><br><span class="line">apt-get install vim</span><br><span class="line"></span><br><span class="line">vim /etc/mysql/my.cnf</span><br></pre></td></tr></table></figure>

<ul>
<li>在 my.cnf 配置文件中添加如下代码</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">server-id=10</span><br><span class="line">log-bin=mysql-bin</span><br><span class="line">innodb_flush_log_at_trx_commit=1</span><br><span class="line">sync_binlog=1</span><br></pre></td></tr></table></figure>

<img src="https://gitee.com/KIMTOU/img/raw/master/20210528000934.PNG" alt="mycnf" style="zoom: 67%;" />



<ul>
<li>进入<strong>主库</strong>为<strong>从库</strong>创建一个用户用来复制数据，从库通过这个用户连接至主库</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 登录mysql</span></span><br><span class="line">mysql -u root -p</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 创建用户</span></span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> CREATE user <span class="string">&#x27;slave&#x27;</span>@<span class="string">&#x27;%&#x27;</span> identified by <span class="string">&#x27;slave&#x27;</span>;</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 赋予权限</span></span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> GRANT REPLICATION SLAVE, REPLICATION CLIENT ON *.* TO <span class="string">&#x27;slave&#x27;</span>@<span class="string">&#x27;%&#x27;</span>;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>查看主库状态</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> show master status;</span></span><br><span class="line">+------------------+----------+--------------+------------------+-------------------+</span><br><span class="line">| File             | Position | Binlog_Do_DB | Binlog_Ignore_DB | Executed_Gtid_Set |</span><br><span class="line">+------------------+----------+--------------+------------------+-------------------+</span><br><span class="line">| mysql-bin.000001 |     617  |              |                  |                   |</span><br><span class="line">+------------------+----------+--------------+------------------+-------------------+</span><br></pre></td></tr></table></figure>

<ul>
<li>重启生效</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker restart master_mysql</span><br></pre></td></tr></table></figure>



<p><strong>二、从库配置</strong></p>
<ul>
<li>同样的进入容器修改配置文件</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker exec -it slave_mysql /bin/bash</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">由于容器内没有vim工具，需进行安装</span></span><br><span class="line">apt-get update</span><br><span class="line">apt-get install vim</span><br><span class="line"></span><br><span class="line">vim /etc/mysql/my.cnf</span><br></pre></td></tr></table></figure>

<ul>
<li>在 my.cnf 配置文件中添加如下代码</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">server_id=11</span><br><span class="line">log-bin=mysql-slave-bin</span><br><span class="line">relay_log=edu-mysql-relay-bin</span><br></pre></td></tr></table></figure>

<ul>
<li>重启生效</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker restart slave_mysql</span><br></pre></td></tr></table></figure>



<p><strong>三、绑定主库</strong></p>
<ul>
<li>docker查看主mysql容器的ip</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker inspect --format=&#x27;&#123;&#123;.NetworkSettings.IPAddress&#125;&#125;&#x27; master_mysql</span><br></pre></td></tr></table></figure>

<ul>
<li>进入从库</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker exec -it slave_mysql /bin/bash</span><br><span class="line">mysql -u root -p</span><br></pre></td></tr></table></figure>

<ul>
<li>绑定主库</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> change master to master_host=<span class="string">&#x27;172.17.0.2&#x27;</span>, master_user=<span class="string">&#x27;slave&#x27;</span>, master_password=<span class="string">&#x27;slave&#x27;</span>, master_port=3306, master_log_file=<span class="string">&#x27;mysql-bin.000001&#x27;</span>, master_log_pos=617, master_connect_retry=30;</span></span><br></pre></td></tr></table></figure>

<p>这里的<strong>master_host</strong>为刚刚查到的<strong>主mysql容器的ip</strong>，是容器独立的ip </p>
<ul>
<li>查看从库的状态</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">show slave status \G;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 发现IO线程和SQL线程运行状态都为No，默认是没有开启，需要手动开启</span></span><br><span class="line">Slave_IO_Running: No</span><br><span class="line">Slave_SQL_Running: No</span><br></pre></td></tr></table></figure>

<ul>
<li>开启主从复制</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">start slave;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指 Offer 31.栈的压入、弹出序列</title>
    <url>/2021/09/12/%E5%89%91%E6%8C%87-Offer-31-%E6%A0%88%E7%9A%84%E5%8E%8B%E5%85%A5%E3%80%81%E5%BC%B9%E5%87%BA%E5%BA%8F%E5%88%97/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><strong>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如，序列 {1,2,3,4,5} 是某栈的压栈序列，序列 {4,5,3,2,1} 是该压栈序列对应的一个弹出序列，但 {4,3,5,1,2} 就不可能是该压栈序列的弹出序列。</strong></p>
<p>示例 1：</p>
<figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line">输入：pushed = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>], popped = [<span class="number">4</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">输出：<span class="literal">true</span></span><br><span class="line">解释：我们可以按以下顺序执行：</span><br><span class="line">push<span class="function"><span class="params">(<span class="number">1</span>)</span>, <span class="title">push</span><span class="params">(<span class="number">2</span>)</span>, <span class="title">push</span><span class="params">(<span class="number">3</span>)</span>, <span class="title">push</span><span class="params">(<span class="number">4</span>)</span>, <span class="title">pop</span><span class="params">()</span> -&gt;</span> <span class="number">4</span>,</span><br><span class="line">push<span class="function"><span class="params">(<span class="number">5</span>)</span>, <span class="title">pop</span><span class="params">()</span> -&gt;</span> <span class="number">5</span>, pop<span class="function"><span class="params">()</span> -&gt;</span> <span class="number">3</span>, pop<span class="function"><span class="params">()</span> -&gt;</span> <span class="number">2</span>, pop<span class="function"><span class="params">()</span> -&gt;</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>示例 2：</p>
<figure class="highlight nix"><table><tr><td class="code"><pre><span class="line">输入：<span class="attr">pushed</span> = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>], <span class="attr">popped</span> = [<span class="number">4</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">输出：<span class="literal">false</span></span><br><span class="line">解释：<span class="number">1</span> 不能在 <span class="number">2</span> 之前弹出。</span><br></pre></td></tr></table></figure>


<p>提示：</p>
<ol>
<li>0 &lt;= pushed.length == popped.length &lt;= 1000</li>
<li>0 &lt;= pushed[i], popped[i] &lt; 1000</li>
<li>pushed 是 popped 的排列。</li>
</ol>
<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><h3 id="利用数组模拟栈"><a href="#利用数组模拟栈" class="headerlink" title="利用数组模拟栈"></a>利用数组模拟栈</h3><h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>既然题目给我们的压入、弹出序列是数组，那么我们创建一个数组来模拟一个栈，作为中间的一个辅助栈，其长度最大不会超过pushed压入序列的长度。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] stack = <span class="keyword">new</span> <span class="keyword">int</span>[pushed.length];</span><br></pre></td></tr></table></figure>

<p><strong>算法实现：</strong></p>
<p>1、遍历压入序列<code>pushed</code>的元素，并将其压入辅助栈<code>stack</code>。若遍历完压入序列<code>pushed</code>，则进行步骤三。</p>
<p>2、辅助栈每压入一个元素，就去循环判断自己的栈顶元素与<code>popped</code>序列的栈顶元素是否相同。相同则一起弹出该元素并指针下移，继续判断下一栈顶元素是否相同；若不相同，则回到步骤一。</p>
<p>3、检查辅助栈是否为空，若辅助栈不为空，则popped序列不是弹出序列。</p>
<p><strong>关于循环条件的说明：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (stackIndex &gt;= <span class="number">0</span> &amp;&amp; popIndex &lt; popped.length &amp;&amp;</span><br><span class="line">                                 stack[stackIndex] == popped[popIndex])</span><br></pre></td></tr></table></figure>

<p>由于题目说明指出压入序列与弹出序列长度相同（<code>0 &lt;= pushed.length == popped.length &lt;= 1000</code>），且stack数组在当前循环中的长度小于等于pushed压入序列，故可知stack数组在当前循环中的长度必然小于等于poped弹出序列长度，因此我们便可把循环条件简化为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (stackIndex &gt;= <span class="number">0</span> &amp;&amp; stack[stackIndex] == popped[popIndex])</span><br></pre></td></tr></table></figure>

<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">validateStackSequences</span><span class="params">(<span class="keyword">int</span>[] pushed, <span class="keyword">int</span>[] popped)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pushIndex = <span class="number">0</span>, popIndex = <span class="number">0</span>, stackIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] stack = <span class="keyword">new</span> <span class="keyword">int</span>[pushed.length];</span><br><span class="line">        <span class="keyword">while</span> (pushIndex &lt; pushed.length)&#123;</span><br><span class="line">            stack[stackIndex] = pushed[pushIndex++];</span><br><span class="line">            <span class="keyword">while</span> (stackIndex &gt;= <span class="number">0</span> &amp;&amp; stack[stackIndex] == popped[popIndex])&#123;</span><br><span class="line">                stackIndex--;</span><br><span class="line">                popIndex++;</span><br><span class="line">            &#125;</span><br><span class="line">            stackIndex++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stackIndex == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度O(N)：N为<code>pushed</code>压入序列的元素个数，每个元素最多入栈、出栈一次，即最多2N次出入栈操作</li>
<li>空间复杂度O(N)：创建模拟栈stack，最多同时存储N个元素</li>
</ul>
<h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">validateStackSequences</span><span class="params">(<span class="keyword">int</span>[] pushed, <span class="keyword">int</span>[] popped)</span> </span>&#123;</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : pushed)&#123;</span><br><span class="line">            stack.push(num);</span><br><span class="line">            <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; stack.peek() == popped[i])&#123;</span><br><span class="line">                stack.pop();</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<ul>
<li>题目链接：<a href="https://leetcode-cn.com/problems/zhan-de-ya-ru-dan-chu-xu-lie-lcof/">剑指 Offer 31. 栈的压入、弹出序列 - 力扣（LeetCode） (leetcode-cn.com)</a></li>
<li>题解链接：<a href="https://leetcode-cn.com/problems/zhan-de-ya-ru-dan-chu-xu-lie-lcof/solution/zhi-xing-yong-shi-0-ms-li-yong-shu-zu-mo-1vwk/">执行用时: 0 ms 利用数组模拟栈（剑指31.栈的压入、弹出序列） - 栈的压入、弹出序列 - 力扣（LeetCode） (leetcode-cn.com)</a></li>
</ul>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>RocketMQ底层设计与原理</title>
    <url>/2021/09/13/RocketMQ%E5%BA%95%E5%B1%82%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h2 id="RocketMQ的消息模型"><a href="#RocketMQ的消息模型" class="headerlink" title="RocketMQ的消息模型"></a>RocketMQ的消息模型</h2><h4 id="消息模型-Message-Model"><a href="#消息模型-Message-Model" class="headerlink" title="消息模型 Message Model"></a>消息模型 Message Model</h4><p>RocketMQ主要由 Producer、Broker、Consumer 三部分组成，其中Producer 负责生产消息，Consumer 负责消费消息，Broker 负责存储消息。Broker 在实际部署过程中对应一台服务器，<strong>每个 Broker 可以存储多个Topic的消息，每个Topic的消息也可以分片存储于不同的 Broker。</strong>Message Queue 用于存储消息的物理地址，每个Topic中的消息地址存储于多个 Message Queue 中。ConsumerGroup 由多个Consumer 实例构成。</p>
<h4 id="消息-Message"><a href="#消息-Message" class="headerlink" title="消息 Message"></a>消息 Message</h4><p><strong>消息系统所传输信息的物理载体，生产和消费数据的最小单位</strong>，每条消息必须属于一个主题。RocketMQ中每个消息拥有唯一的Message ID，且可以携带具有业务标识的Key。系统提供了通过Message ID和Key查询消息的功能。</p>
<h4 id="主题-Topic"><a href="#主题-Topic" class="headerlink" title="主题 Topic"></a>主题 Topic</h4><p><strong>表示一类消息的集合</strong>，每个主题包含若干条消息，每条消息只能属于一个主题，是RocketMQ进行消息订阅的基本单位。</p>
<blockquote>
<p><strong>Topic</strong> 与生产者和消费者的关系非常松散，一个 Topic 可以有0个、1个、多个生产者向其发送消息，一个生产者也可以同时向不同的 Topic 发送消息。</p>
<p>一个 Topic 也可以被 0个、1个、多个消费者订阅。</p>
</blockquote>
<h4 id="标签-Tag"><a href="#标签-Tag" class="headerlink" title="标签 Tag"></a>标签 Tag</h4><p><strong>为消息设置的标志，用于同一主题下区分不同类型的消息</strong>。来自同一业务单元的消息，可以根据不同业务目的在同一主题下设置不同标签。标签能够有效地保持代码的清晰度和连贯性，并优化RocketMQ提供的查询系统。消费者可以根据Tag实现对不同子主题的不同消费逻辑，实现更好的扩展性。</p>
<h4 id="分组-Group"><a href="#分组-Group" class="headerlink" title="分组 Group"></a>分组 Group</h4><p>分为ProducerGroup，ConsumerGroup，代表某一类的生产者和消费者，一个组可以订阅多个Topic。</p>
<p><strong>ProducerGroup</strong>代表同一类Producer的集合，这类Producer发送同一类消息且发送逻辑一致。如果发送的是事务消息且原始生产者在发送之后崩溃，则Broker服务器会联系同一生产者组的其他生产者实例以提交或回溯消费。</p>
<p><strong>ConsumerGroup</strong>代表同一类Consumer的集合，这类Consumer通常消费同一类消息且消费逻辑一致。消费者组使得在消息消费方面，实现负载均衡和容错的目标变得非常容易。要注意的是，消费者组的消费者实例必须订阅完全相同的Topic。RocketMQ 支持两种消息模式：集群消费（Clustering）和广播消费（Broadcasting）。</p>
<h4 id="队列-Queue"><a href="#队列-Queue" class="headerlink" title="队列 Queue"></a>队列 Queue</h4><p>在<strong>Kafka</strong>中叫Partition，每个Queue内部是有序的，在<strong>RocketMQ</strong>中分为读和写两种队列，一般来说读写队列数量一致，如果不一致就会出现很多问题。</p>
<h4 id="消费位移-Offset"><a href="#消费位移-Offset" class="headerlink" title="消费位移 Offset"></a>消费位移 Offset</h4><p>在RocketMQ 中，所有消息队列都是持久化，长度无限的数据结构，所谓长度无限是指队列中的每个存储单元都是定长，访问其中的存储单元使用Offset 来访问，Offset 为 java long 类型，64 位，理论上在 100年内不会溢出，所以认为是长度无限。也可以认为 Message Queue 是一个长度无限的数组，Offset 就是下标。</p>
<p><img src="https://gitee.com/KIMTOU/img/raw/master/20210913210810.png" alt="消息模型"></p>
<p><strong>一个主题存在多个队列</strong>，生产者每次生产消息后向指定主题中的某个队列发送消息。在集群消费模式下，一个消费者集群的多个消费者共同消费一个<code>Topic</code>的多个队列，<strong>一个队列只会被一个消费者消费</strong>，如果某个消费者挂掉，分组内其它消费者会接替挂掉的消费者继续消费。一般来讲要控制<strong>消费者组中的消费者个数和主题中队列个数相同</strong> ，当然也可以消费者个数小于队列个数，只不过不太建议。</p>
<p><strong>同时每个消费者组在每个队列上维护一个消费位移offset</strong></p>
<blockquote>
<p>在发布订阅模式中一般会涉及到多个消费者组，而<strong>每个消费者组在每个队列中的消费位置都是不同的</strong>。如果此时有多个消费者组，那么消息被一个消费者组消费完之后是不会删除的（因为一个Topic可以被多个消费者订阅，那么其它消费者组也需要呀），它仅仅是为每个消费者组维护一个 <strong>消费位移(offset)</strong> ，每次消费者组消费完会返回一个成功的响应，然后队列再把维护的消费位移加一，这样就不会出现刚刚消费过的消息再一次被消费了。</p>
</blockquote>
<h2 id="为什么一个主题中需要维护多个队列"><a href="#为什么一个主题中需要维护多个队列" class="headerlink" title="为什么一个主题中需要维护多个队列"></a>为什么一个主题中需要维护多个队列</h2><ul>
<li><strong>提高并发能力</strong></li>
</ul>
<p>可以从生产者、消费者两个方面来解释。倘如一个主题Topic只有一个队列，这样生产者只能向一个队列发送消息，并且由于一个队列只能对应消费者组中的一个消费者（因为需要维护消费位移），这样该消费者组中的其他消费者便失去用武之地。</p>
<blockquote>
<p><code>RocketMQ</code> 通过<strong>使用在一个 <code>Topic</code> 中配置多个队列并且每个队列维护每个消费者组的消费位置</strong> 实现了 <strong>主题模式/发布订阅模式</strong></p>
</blockquote>
<h2 id="如何解决消息重复问题"><a href="#如何解决消息重复问题" class="headerlink" title="如何解决消息重复问题"></a>如何解决消息重复问题</h2><p><strong>首先分析引起重复消费的原因：</strong></p>
<p><strong>1、ACK （网络因素）</strong></p>
<p>正常情况下在consumer真正消费完消息后应该发送ack，通知broker该消息已正常消费。<strong>当ack因为网络原因无法发送到broker，broker会认为此条消息没有被消费</strong>，此后会开启消息重投机制把消息再次投递到consumer。</p>
<p><strong>2、消费模式</strong></p>
<p>在CLUSTERING集群消费模式下，消息在broker中会保证相同group的consumer消费一次，但是针对不同group的consumer会推送多次。</p>
<h4 id="消息去重"><a href="#消息去重" class="headerlink" title="消息去重"></a>消息去重</h4><p><strong>去重原则：使用业务端逻辑保持幂等性</strong></p>
<p><strong>幂等性</strong>：就是用户对于同一操作发起的一次请求或者多次请求的结果是一致的，不会因为多次点击而产生了副作用，数据库的结果都是唯一的，不可变的。</p>
<p>只要保持幂等性，不管来多少条重复消息，最后处理的结果都一样。</p>
<p>RocketMQ无法避免消息重复（Exactly-Once），所以如果业务对消费重复非常敏感，务必要在业务层面进行去重处理。可以借助关系数据库进行去重。首先需要确定消息的唯一键，可以是msgId，也可以是消息内容中的唯一标识字段，例如订单Id等。在消费之前判断唯一键是否在关系数据库中存在。如果不存在则插入，并消费，否则跳过。（实际过程要考虑原子性问题，判断是否存在可以尝试插入，如果报主键冲突，则插入失败，直接跳过）</p>
<p>msgId一定是全局唯一标识符，但是实际使用中，可能会存在相同的消息有两个不同msgId的情况（消费者主动重发、因客户端重投机制导致的重复等），这种情况就需要使业务字段进行重复消费。</p>
<h2 id="如何保证消息的顺序消费"><a href="#如何保证消息的顺序消费" class="headerlink" title="如何保证消息的顺序消费"></a>如何保证消息的顺序消费</h2><p>首先Topic内的queue队列满足FIFO先进先出原则，本身就是顺序的，但多个queue同时消费并无法保证消息有序。那么此时我们只要保证将一类消息（如一个订单的创建、支付、完成）固定发送至同一queue队列即可。</p>
<h4 id="那么如何保证消息发送至同一queue"><a href="#那么如何保证消息发送至同一queue" class="headerlink" title="那么如何保证消息发送至同一queue"></a>那么如何保证消息发送至同一queue</h4><p><strong>RocketMQ提供了MessageQueueSelector接口，可以重写接口的select方法，定义自己的选择策略。</strong></p>
<p><strong>比如使用Hash取模法</strong>，让同一个订单发送到同一个队列中，再使用同步发送，只有同个订单的创建消息发送成功，再发送支付消息，这样我们保证了发送有序。</p>
<ul>
<li>Producer端</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="comment">// 加个时间前缀</span></span><br><span class="line">    String body = dateStr + <span class="string">&quot; Hello RocketMQ &quot;</span> + orderList.get(i);</span><br><span class="line">    Message msg = <span class="keyword">new</span> Message(<span class="string">&quot;TopicTest&quot;</span>, tags[i % tags.length], <span class="string">&quot;KEY&quot;</span> + i, body.getBytes());</span><br><span class="line"></span><br><span class="line">    SendResult sendResult = producer.send(msg, <span class="keyword">new</span> MessageQueueSelector() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> MessageQueue <span class="title">select</span><span class="params">(List&lt;MessageQueue&gt; mqs, Message msg, Object arg)</span> </span>&#123;</span><br><span class="line">            Long id = (Long) arg;  <span class="comment">//根据订单id选择发送queue</span></span><br><span class="line">            <span class="keyword">long</span> index = id % mqs.size();</span><br><span class="line">            <span class="keyword">return</span> mqs.get((<span class="keyword">int</span>) index);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, orderList.get(i).getOrderId());<span class="comment">//订单id</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Consume端</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">consumer.registerMessageListener(<span class="keyword">new</span> MessageListenerOrderly() &#123;</span><br><span class="line"></span><br><span class="line">    Random random = <span class="keyword">new</span> Random();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ConsumeOrderlyStatus <span class="title">consumeMessage</span><span class="params">(List&lt;MessageExt&gt; msgs, ConsumeOrderlyContext context)</span> </span>&#123;</span><br><span class="line">        context.setAutoCommit(<span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">for</span> (MessageExt msg : msgs) &#123;</span><br><span class="line">            <span class="comment">// 可以看到每个queue有唯一的consume线程来消费, 订单对每个queue(分区)有序</span></span><br><span class="line">            System.out.println(<span class="string">&quot;consumeThread=&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;queueId=&quot;</span> + msg.getQueueId() + <span class="string">&quot;, content:&quot;</span> + <span class="keyword">new</span> String(msg.getBody()));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//模拟业务逻辑处理中...</span></span><br><span class="line">            TimeUnit.SECONDS.sleep(random.nextInt(<span class="number">10</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ConsumeOrderlyStatus.SUCCESS;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>



<h2 id="RocketMQ如何保证消息不丢失"><a href="#RocketMQ如何保证消息不丢失" class="headerlink" title="RocketMQ如何保证消息不丢失"></a>RocketMQ如何保证消息不丢失</h2><p>首先在如下三个部分都可能会出现丢失消息的情况：</p>
<ul>
<li>Producer端</li>
<li>Broker端</li>
<li>Consumer端</li>
</ul>
<h4 id="Producer端如何保证消息不丢失"><a href="#Producer端如何保证消息不丢失" class="headerlink" title="Producer端如何保证消息不丢失"></a>Producer端如何保证消息不丢失</h4><ul>
<li>采取send()同步发消息，发送结果是同步感知的。</li>
<li>发送失败后可以重试，设置重试次数。默认2次。</li>
</ul>
<blockquote>
<p>producer.setRetryTimesWhenSendFailed(10);</p>
</blockquote>
<ul>
<li>集群部署，比如发送失败了的原因可能是当前Broker宕机了，重试的时候会发送到其他Broker上。</li>
</ul>
<h4 id="Broker端如何保证消息不丢失"><a href="#Broker端如何保证消息不丢失" class="headerlink" title="Broker端如何保证消息不丢失"></a>Broker端如何保证消息不丢失</h4><ul>
<li>修改刷盘策略为同步刷盘。默认情况下是异步刷盘的。</li>
</ul>
<blockquote>
<p>flushDiskType = SYNC_FLUSH</p>
</blockquote>
<ul>
<li>集群部署，主从模式，高可用。</li>
</ul>
<h4 id="Consumer端如何保证消息不丢失"><a href="#Consumer端如何保证消息不丢失" class="headerlink" title="Consumer端如何保证消息不丢失"></a>Consumer端如何保证消息不丢失</h4><ul>
<li>完全消费正常后在进行手动ack确认。</li>
</ul>
<h2 id="消息刷盘机制"><a href="#消息刷盘机制" class="headerlink" title="消息刷盘机制"></a>消息刷盘机制</h2><blockquote>
<p><strong>Broker</strong> 在消息的存取时直接操作的是内存（内存映射文件），这可以提供系统的吞吐量，但是无法避免机器掉电时数据丢失，所以需要持久化到磁盘中。</p>
<p><strong>刷盘的最终实现都是使用NIO中的 MappedByteBuffer.force() 将映射区的数据写入到磁盘</strong></p>
</blockquote>
<p><strong>同步刷盘</strong>：在Broker把消息写到<strong>CommitLog</strong>映射区后，便进行持久化。只有在消息真正持久化至磁盘后RocketMQ的Broker端才会真正返回给Producer端一个成功的ACK响应。同步刷盘对MQ消息可靠性更好，但是性能上会有较大影响。</p>
<p><strong>异步刷盘</strong>：能够充分利用OS的PageCache的优势，只要消息写入PageCache即可将成功的ACK返回给Producer端。<strong>消息刷盘采用后台异步线程提交的方式进行，降低了读写延迟</strong>，提高了MQ的性能和吞吐量。</p>
<h2 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h2><blockquote>
<p>常见的分布式事务实现有 2PC(两阶段提交）、TCC 和事务消息(half 半消息机制)。每一种实现都有其特定的使用场景，但是也有各自的问题，<strong>都不是完美的解决方案</strong>。</p>
</blockquote>
<p> <code>RocketMQ</code> 使用 <strong>事务消息（half半消息）加上事务消息回查机制</strong> 来解决分布式事务问题的</p>
<h4 id="Half-Message-半消息"><a href="#Half-Message-半消息" class="headerlink" title="Half Message 半消息"></a>Half Message 半消息</h4><p><strong>是指暂不能被Consumer消费的消息</strong>。Producer 已经把消息成功发送到了 Broker 端，但此消息被标记为<code>暂不能投递</code>状态，处于该种状态下的消息称为半消息。需要 Producer对消息的<code>二次确认</code>后，Consumer才能去消费它。当broker收到此类消息后，会存储到RMQ_SYS_TRANS_HALF_TOPIC的消息消费队列中</p>
<h4 id="事务消息回查"><a href="#事务消息回查" class="headerlink" title="事务消息回查"></a>事务消息回查</h4><p>由于网络波动，生产者应用重启等原因。导致 Producer 端一直没有收到对 Half Message(半消息) 进行二次确认。<strong>这时Broker会开启一个定时任务，从Topic为RMQ_SYS_TRANS_HALF_TOPIC中拉取消息进行消费</strong>，主动向Producer消息发送者确认事务执行状态（提交、回滚、未知），根据事务状态来决定是提交或回滚消息。如果是未知，Broker会定时去回调在重新检查，如果超过回查次数（超时），默认回滚消息。</p>
<p><img src="https://gitee.com/KIMTOU/img/raw/master/20210921155621.png"></p>
<h4 id="事务消息流程"><a href="#事务消息流程" class="headerlink" title="事务消息流程"></a>事务消息流程</h4><p>分为两个流程：正常事务消息的发送及提交、事务消息的补偿流程。</p>
<p>1、事务消息发送及提交：</p>
<p>(1) 发送消息（half半消息）。</p>
<p>(2) 服务端响应消息写入结果。</p>
<p>(3) 根据发送结果执行本地事务（如果写入失败，此时half消息对业务不可见，本地逻辑不执行）。</p>
<p>(4) 根据本地事务状态执行Commit或者Rollback（Commit操作生成消息索引，消息对消费者可见）</p>
<p>2、补偿流程（回查）：</p>
<p>(1) 对没有Commit/Rollback的事务消息（pending状态的消息），从服务端发起一次“回查”</p>
<p>(2) Producer收到回查消息，检查回查消息对应的本地事务的状态</p>
<p>(3) 根据本地事务状态，重新Commit或者Rollback</p>
<p>其中，补偿阶段用于解决消息Commit或者Rollback发生超时或者失败的情况。</p>
<h4 id="事务消息在一阶段对用户不可见"><a href="#事务消息在一阶段对用户不可见" class="headerlink" title="事务消息在一阶段对用户不可见"></a>事务消息在一阶段对用户不可见</h4><p>事务消息相对普通消息最大的特点就是一阶段发送的消息对用户是不可见的。RocketMQ事务消息的做法是：<strong>如果消息是half消息，将备份原消息的主题与消息消费队列，然后改变主题为RMQ_SYS_TRANS_HALF_TOPIC。由于消费组未订阅该主题，故消费端无法消费half类型的消息</strong>，然后Broker会开启一个定时任务，从Topic为RMQ_SYS_TRANS_HALF_TOPIC中拉取消息进行消费，根据生产者组获取一个服务提供者<strong>发送回查事务状态请求</strong>，根据事务状态来决定是提交或回滚消息。若Commit，则恢复原消息的主题与队列，重新发送到Broker，消费端感知后消费。</p>
<hr>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://github.com/apache/rocketmq/blob/master/docs/cn">https://github.com/apache/rocketmq/blob/master/docs/cn</a></p>
<p><a href="https://blog.csdn.net/qq_35190492/article/details/103341634?ops_request_misc=%7B%22request_id%22:%22162972269016780271584378%22,%22scm%22:%2220140713.130102334.pc_blog.%22%7D&request_id=162972269016780271584378&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_v2~rank_v29-1-103341634.pc_v2_rank_blog_default&utm_term=rocket&spm=1018.2226.3001.4450">看完保送阿里的RocketMQ知识点（超详细）_敖丙-CSDN博客</a></p>
<p><a href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/system-design/distributed-system/message-queue/RocketMQ.md">JavaGuide/RocketMQ.md at master · Snailclimb/JavaGuide (github.com)</a></p>
<p><a href="https://mp.weixin.qq.com/s/vxHzNs23-P4BvYvyME6_nQ">RocketMQ在面试中那些常见问题及答案 (qq.com)</a></p>
]]></content>
      <categories>
        <category>消息队列</category>
      </categories>
      <tags>
        <tag>消息队列</tag>
      </tags>
  </entry>
  <entry>
    <title>RocketMQ实战与最佳实践</title>
    <url>/2021/09/21/RocketMQ%E5%AE%9E%E6%88%98%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/</url>
    <content><![CDATA[<h2 id="实战应用"><a href="#实战应用" class="headerlink" title="实战应用"></a>实战应用</h2><p>maven依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.rocketmq<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>rocketmq-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.9.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h3 id="普通消息"><a href="#普通消息" class="headerlink" title="普通消息"></a>普通消息</h3><h4 id="消息发送"><a href="#消息发送" class="headerlink" title="消息发送"></a>消息发送</h4><h5 id="1、Producer端发送同步消息"><a href="#1、Producer端发送同步消息" class="headerlink" title="1、Producer端发送同步消息"></a><strong>1、Producer端发送同步消息</strong></h5><p>这种可靠性同步地发送方式使用的比较广泛，比如：重要的消息通知，短信通知。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">syncProducer</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    <span class="comment">// 实例化消息生产者Producer</span></span><br><span class="line">    DefaultMQProducer producer = <span class="keyword">new</span> DefaultMQProducer(<span class="string">&quot;Group_A&quot;</span>);</span><br><span class="line">    <span class="comment">// 设置NameServer的地址</span></span><br><span class="line">    producer.setNamesrvAddr(<span class="string">&quot;localhost:9876&quot;</span>);</span><br><span class="line">    <span class="comment">//启动Producer实例</span></span><br><span class="line">    producer.start();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// 创建消息，并指定Topic，Tag和消息体</span></span><br><span class="line">        Message message = <span class="keyword">new</span> Message(<span class="string">&quot;TopicTest&quot;</span>, <span class="string">&quot;TagA&quot;</span>,</span><br><span class="line">                (<span class="string">&quot;Hello RocketMQ &quot;</span> + i).getBytes(RemotingHelper.DEFAULT_CHARSET));</span><br><span class="line">        <span class="comment">// 发送消息到一个Broker</span></span><br><span class="line">        SendResult sendResult = producer.send(message);</span><br><span class="line">        System.out.println(sendResult);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 不再发送消息，关闭Producer实例</span></span><br><span class="line">    producer.shutdown();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2、发送异步消息"><a href="#2、发送异步消息" class="headerlink" title="2、发送异步消息"></a><strong>2、发送异步消息</strong></h5><p>异步消息通常用在对响应时间敏感的业务场景，即发送端不能容忍长时间地等待Broker的响应。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">asyncProducer</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    DefaultMQProducer producer = <span class="keyword">new</span> DefaultMQProducer(<span class="string">&quot;Group_A&quot;</span>);</span><br><span class="line">    producer.setNamesrvAddr(<span class="string">&quot;localhost:9876&quot;</span>);</span><br><span class="line">    producer.start();</span><br><span class="line">    <span class="comment">// 重试次数</span></span><br><span class="line">    producer.setRetryTimesWhenSendAsyncFailed(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 根据消息数量实例化倒计时计算器</span></span><br><span class="line">    <span class="keyword">final</span> CountDownLatch2 countDownLatch2 = <span class="keyword">new</span> CountDownLatch2(messageCount);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; messageCount; i++)&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> index = i;</span><br><span class="line">        Message message = <span class="keyword">new</span> Message(<span class="string">&quot;TopicTest&quot;</span>, <span class="string">&quot;TagB&quot;</span>,</span><br><span class="line">                <span class="string">&quot;OrderID909&quot;</span>, <span class="string">&quot;Hello World&quot;</span>.getBytes(RemotingHelper.DEFAULT_CHARSET));</span><br><span class="line">        <span class="comment">// SendCallBack接受异步返回结果的回调</span></span><br><span class="line">        producer.send(message, <span class="keyword">new</span> SendCallback() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">(SendResult sendResult)</span> </span>&#123;</span><br><span class="line">                System.out.printf(<span class="string">&quot;%-10d OK %s %n&quot;</span>, index, sendResult.getMsgId());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onException</span><span class="params">(Throwable throwable)</span> </span>&#123;</span><br><span class="line">                System.out.printf(<span class="string">&quot;%-10d Exception %s %n&quot;</span>, index, throwable);</span><br><span class="line">                throwable.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 等待5s</span></span><br><span class="line">    countDownLatch2.await(<span class="number">5</span>, TimeUnit.SECONDS);</span><br><span class="line">    producer.shutdown();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3、发送单向消息"><a href="#3、发送单向消息" class="headerlink" title="3、发送单向消息"></a>3、发送单向消息</h5><p>这种方式主要用在不特别关心发送结果的场景，例如日志发送。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">onewayProducer</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    DefaultMQProducer producer = <span class="keyword">new</span> DefaultMQProducer(<span class="string">&quot;Group_A&quot;</span>);</span><br><span class="line">    producer.setNamesrvAddr(<span class="string">&quot;localhost:9876&quot;</span>);</span><br><span class="line">    producer.start();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; messageCount; i++) &#123;</span><br><span class="line">        Message message = <span class="keyword">new</span> Message(<span class="string">&quot;TopicTest&quot;</span>, <span class="string">&quot;TagC&quot;</span>,</span><br><span class="line">                (<span class="string">&quot;Hello RocketMQ &quot;</span> + i).getBytes(RemotingHelper.DEFAULT_CHARSET));</span><br><span class="line">        <span class="comment">// 发送单向消息，没有返回结果</span></span><br><span class="line">        producer.sendOneway(message);</span><br><span class="line">    &#125;</span><br><span class="line">    producer.shutdown();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="消费消息"><a href="#消费消息" class="headerlink" title="消费消息"></a>消费消息</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">consumer</span><span class="params">()</span> <span class="keyword">throws</span> MQClientException </span>&#123;</span><br><span class="line">    <span class="comment">// 实例化消费者</span></span><br><span class="line">    DefaultMQPushConsumer consumer = <span class="keyword">new</span> DefaultMQPushConsumer(<span class="string">&quot;Consumer_GroupA&quot;</span>);</span><br><span class="line">    <span class="comment">//设置NameServer地址</span></span><br><span class="line">    consumer.setNamesrvAddr(<span class="string">&quot;localhost:9876&quot;</span>);</span><br><span class="line">    <span class="comment">// 订阅一个或者多个Topic，以及Tag来过滤需要消费的消息</span></span><br><span class="line">    consumer.subscribe(<span class="string">&quot;TopicTest&quot;</span>, <span class="string">&quot;*&quot;</span>);</span><br><span class="line">    <span class="comment">// 注册回调实现类来处理从broker拉取回来的消息</span></span><br><span class="line">    consumer.registerMessageListener(<span class="keyword">new</span> MessageListenerConcurrently() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> ConsumeConcurrentlyStatus <span class="title">consumeMessage</span><span class="params">(List&lt;MessageExt&gt; msgList, ConsumeConcurrentlyContext context)</span> </span>&#123;</span><br><span class="line">            System.out.printf(<span class="string">&quot;%s Receive New Messages: %s %n&quot;</span>, Thread.currentThread().getName(), msgList);</span><br><span class="line">            <span class="comment">// 标记该消息已经被成功消费</span></span><br><span class="line">            <span class="keyword">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">//启动消费者实例</span></span><br><span class="line">    consumer.start();</span><br><span class="line">    System.out.println(<span class="string">&quot;Consumer Started&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="发送延时消息"><a href="#发送延时消息" class="headerlink" title="发送延时消息"></a>发送延时消息</h4><p>只需要给消息设置 <code>DelayTimeLevel</code> 延时等级即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; totalMessagesToSend; i++) &#123;</span><br><span class="line">    Message message = <span class="keyword">new</span> Message(<span class="string">&quot;TestTopic&quot;</span>, (<span class="string">&quot;Hello scheduled message &quot;</span> + i).getBytes());</span><br><span class="line">    <span class="comment">// 设置延时等级3,这个消息将在10s之后发送(现在只支持固定的几个时间,详看delayTimeLevel)</span></span><br><span class="line">    message.setDelayTimeLevel(<span class="number">3</span>);</span><br><span class="line">    <span class="comment">// 发送消息</span></span><br><span class="line">    producer.send(message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="顺序消息"><a href="#顺序消息" class="headerlink" title="顺序消息"></a>顺序消息</h3><p>消息有序指的是可以按照消息的发送顺序来消费(FIFO)。RocketMQ可以严格的保证消息有序，可以分为分区有序或者全局有序。</p>
<p>顺序消费的原理解析，在默认的情况下消息发送会采取Round Robin轮询方式把消息发送到不同的queue(分区队列)；而消费消息的时候从多个queue上拉取消息，这种情况发送和消费是不能保证顺序。但是如果<strong>控制发送的顺序消息只依次发送到同一个queue中，消费的时候只从这个queue上依次拉取</strong>，则就保证了顺序。当发送和消费参与的queue只有一个，则是全局有序；如果多个queue参与，则为分区有序，即相对每个queue，消息都是有序的。</p>
<blockquote>
<p>在局部有序中：<strong>一个MessageQueue只能由一个消费者消费，且只能单线程消费。但是这个消费者可以开启多线程，同时消费多个MessageQueue。</strong></p>
</blockquote>
<h4 id="顺序消息生产"><a href="#顺序消息生产" class="headerlink" title="顺序消息生产"></a>顺序消息生产</h4><p>下面用订单进行分区有序的示例。一个订单的顺序流程是：创建、付款、推送、完成。</p>
<p>生产消息时，订单号相同的消息会被先后发送到同一个队列 <code>MessageQueue</code> 中；消费时，同一个OrderId获取到的肯定是同一个队列。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 顺序消息生产</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">orderProducer</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    DefaultMQProducer producer = <span class="keyword">new</span> DefaultMQProducer(<span class="string">&quot;ProducerA&quot;</span>);</span><br><span class="line">    producer.setNamesrvAddr(<span class="string">&quot;localhost:9876&quot;</span>);</span><br><span class="line">    producer.start();</span><br><span class="line"></span><br><span class="line">    String[] tags = <span class="keyword">new</span> String[]&#123;<span class="string">&quot;TagA&quot;</span>, <span class="string">&quot;TagC&quot;</span>, <span class="string">&quot;TagD&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 订单列表</span></span><br><span class="line">    List&lt;OrderStep&gt; orderList = <span class="keyword">new</span> Producer().buildOrders();</span><br><span class="line"></span><br><span class="line">    Date date = <span class="keyword">new</span> Date();</span><br><span class="line">    SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">    String dateStr = sdf.format(date);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// 加个时间前缀</span></span><br><span class="line">        String body = dateStr + <span class="string">&quot; Hello RocketMQ &quot;</span> + orderList.get(i);</span><br><span class="line">        Message msg = <span class="keyword">new</span> Message(<span class="string">&quot;TopicTest&quot;</span>, tags[i % tags.length], <span class="string">&quot;KEY&quot;</span> + i, body.getBytes());</span><br><span class="line"></span><br><span class="line">        SendResult sendResult = producer.send(msg, <span class="keyword">new</span> MessageQueueSelector() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> MessageQueue <span class="title">select</span><span class="params">(List&lt;MessageQueue&gt; mqs, Message msg, Object arg)</span> </span>&#123;</span><br><span class="line">                Long id = (Long) arg;  <span class="comment">//根据订单id选择发送queue</span></span><br><span class="line">                <span class="keyword">long</span> index = id % mqs.size();	<span class="comment">//取模</span></span><br><span class="line">                <span class="keyword">return</span> mqs.get((<span class="keyword">int</span>) index);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, orderList.get(i).getOrderId());<span class="comment">//订单id</span></span><br><span class="line"></span><br><span class="line">        System.out.println(String.format(<span class="string">&quot;SendResult status:%s, queueId:%d, body:%s&quot;</span>,</span><br><span class="line">                sendResult.getSendStatus(),</span><br><span class="line">                sendResult.getMessageQueue().getQueueId(),</span><br><span class="line">                body));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    producer.shutdown();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="顺序消息消费"><a href="#顺序消息消费" class="headerlink" title="顺序消息消费"></a>顺序消息消费</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 顺序消息消费</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">orderConsumer</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    DefaultMQPushConsumer consumer = <span class="keyword">new</span> DefaultMQPushConsumer(<span class="string">&quot;ConsumerA&quot;</span>);</span><br><span class="line">    consumer.setNamesrvAddr(<span class="string">&quot;localhost:9876&quot;</span>);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置Consumer第一次启动是从队列头部开始消费还是队列尾部开始消费&lt;br&gt;</span></span><br><span class="line"><span class="comment">     * 如果非第一次启动，那么按照上次消费的位置继续消费</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET);</span><br><span class="line"></span><br><span class="line">    consumer.subscribe(<span class="string">&quot;TopicTest&quot;</span>, <span class="string">&quot;TagA || TagC || TagD&quot;</span>);</span><br><span class="line"></span><br><span class="line">    consumer.registerMessageListener(<span class="keyword">new</span> MessageListenerOrderly() &#123;</span><br><span class="line"></span><br><span class="line">        Random random = <span class="keyword">new</span> Random();</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> ConsumeOrderlyStatus <span class="title">consumeMessage</span><span class="params">(List&lt;MessageExt&gt; msgs, ConsumeOrderlyContext context)</span> </span>&#123;</span><br><span class="line">            context.setAutoCommit(<span class="keyword">true</span>);</span><br><span class="line">            <span class="keyword">for</span> (MessageExt msg : msgs) &#123;</span><br><span class="line">                <span class="comment">// 可以看到每个queue有唯一的consume线程来消费, 订单对每个queue(分区)有序</span></span><br><span class="line">                System.out.println(<span class="string">&quot;consumeThread=&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;queueId=&quot;</span> + msg.getQueueId() + <span class="string">&quot;, content:&quot;</span> + <span class="keyword">new</span> String(msg.getBody()));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//模拟业务逻辑处理中...</span></span><br><span class="line">                TimeUnit.SECONDS.sleep(random.nextInt(<span class="number">10</span>));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> ConsumeOrderlyStatus.SUCCESS;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    consumer.start();</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;Consumer Started.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>重点：每个queue有唯一的consume线程来消费, 订单对每个queue(分区)有序</strong></li>
</ul>
<p>从 <code>consumer.registerMessageListener(new MessageListenerOrderly() </code> 代码可以知道，顺序消息使用 <code>MessageListenerOrderly</code> 来告诉消费者进行顺序消费消息，并且只能单线程去消费同一个queue。而普通消息使用 <code>MessageListenerConcurrently</code> 进行并发消费消息。</p>
<h3 id="事务消息"><a href="#事务消息" class="headerlink" title="事务消息"></a>事务消息</h3><p>事务消息共有三种状态，提交状态、回滚状态、中间状态：</p>
<ul>
<li>TransactionStatus.CommitTransaction: 提交事务，它允许消费者消费此消息。</li>
<li>TransactionStatus.RollbackTransaction: 回滚事务，它代表该消息将被删除，不允许被消费。</li>
<li>TransactionStatus.Unknown: 中间状态，它代表需要检查消息队列来确定状态。</li>
</ul>
<h4 id="创建事务型生产者"><a href="#创建事务型生产者" class="headerlink" title="创建事务型生产者"></a>创建事务型生产者</h4><p>使用 <code>TransactionMQProducer</code>类创建生产者，并指定唯一的 <code>ProducerGroup</code>，就可以设置自定义线程池来处理这些检查请求。执行本地事务后、需要根据执行结果对消息队列进行回复。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">transactionProducer</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    TransactionListener transactionListener = <span class="keyword">new</span> TransactionListenerImpl();</span><br><span class="line">    TransactionMQProducer producer = <span class="keyword">new</span> TransactionMQProducer(<span class="string">&quot;TransactionProducer&quot;</span>);</span><br><span class="line">    ExecutorService executorService = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">2</span>, <span class="number">5</span>, <span class="number">100</span>, TimeUnit.SECONDS, <span class="keyword">new</span> ArrayBlockingQueue&lt;Runnable&gt;(<span class="number">2000</span>), <span class="keyword">new</span> ThreadFactory() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(Runnable runnable)</span> </span>&#123;</span><br><span class="line">            Thread thread = <span class="keyword">new</span> Thread(runnable);</span><br><span class="line">            thread.setName(<span class="string">&quot;client-transaction-msg-check-thread&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> thread;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    producer.setExecutorService(executorService);</span><br><span class="line">    producer.setTransactionListener(transactionListener);</span><br><span class="line">    producer.start();</span><br><span class="line">    String[] tags = <span class="keyword">new</span> String[] &#123;<span class="string">&quot;TagA&quot;</span>, <span class="string">&quot;TagB&quot;</span>, <span class="string">&quot;TagC&quot;</span>, <span class="string">&quot;TagD&quot;</span>, <span class="string">&quot;TagE&quot;</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Message message = <span class="keyword">new</span> Message(<span class="string">&quot;MyTopic&quot;</span>, tags[i % tags.length], <span class="string">&quot;KEY&quot;</span> + i,</span><br><span class="line">                    (<span class="string">&quot;Hello RocketMQ &quot;</span> + i).getBytes(RemotingHelper.DEFAULT_CHARSET));</span><br><span class="line">            TransactionSendResult sendResult = producer.sendMessageInTransaction(message, <span class="keyword">null</span>);</span><br><span class="line">            System.out.println(sendResult);</span><br><span class="line">            Thread.sleep(<span class="number">10</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (MQClientException | UnsupportedEncodingException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    producer.shutdown();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="实现事务的监听接口"><a href="#实现事务的监听接口" class="headerlink" title="实现事务的监听接口"></a>实现事务的监听接口</h4><p>当发送半消息成功时，我们使用 <code>executeLocalTransaction</code> 方法来执行本地事务。它返回前一节中提到的三个事务状态之一。<code>checkLocalTransaction</code> 方法用于检查本地事务状态，并回应消息队列的检查请求。它也是返回前一节中提到的三个事务状态之一。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransactionListenerImpl</span> <span class="keyword">implements</span> <span class="title">TransactionListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> AtomicInteger transactionIndex = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ConcurrentHashMap&lt;String, Integer&gt; localTrans = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 执行本地事务</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> LocalTransactionState <span class="title">executeLocalTransaction</span><span class="params">(Message msg, Object arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> value = transactionIndex.getAndIncrement();</span><br><span class="line">        <span class="keyword">int</span> status = value % <span class="number">3</span>;</span><br><span class="line">        localTrans.put(msg.getTransactionId(), status);</span><br><span class="line">        <span class="comment">//返回未知，让Broker回查事务状态</span></span><br><span class="line">        <span class="keyword">return</span> LocalTransactionState.UNKNOW;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 检查本地事务状态</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> LocalTransactionState <span class="title">checkLocalTransaction</span><span class="params">(MessageExt msg)</span> </span>&#123;</span><br><span class="line">        Integer status = localTrans.get(msg.getTransactionId());</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">null</span> != status)&#123;</span><br><span class="line">            <span class="keyword">switch</span> (status)&#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">return</span> LocalTransactionState.UNKNOW;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                    <span class="keyword">return</span> LocalTransactionState.COMMIT_MESSAGE;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                    <span class="keyword">return</span> LocalTransactionState.ROLLBACK_MESSAGE;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> LocalTransactionState.COMMIT_MESSAGE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="事务消息流程"><a href="#事务消息流程" class="headerlink" title="事务消息流程"></a>事务消息流程</h4><p><img src="https://gitee.com/KIMTOU/img/raw/master/20210921155621.png"></p>
<p>分为两个流程：正常事务消息的发送及提交、事务消息的补偿流程。</p>
<p>1、事务消息发送及提交：</p>
<p>(1) 发送消息（half半消息）。</p>
<p>(2) 服务端响应消息写入结果。</p>
<p>(3) 根据发送结果执行本地事务（如果写入失败，此时half消息对业务不可见，本地逻辑不执行）。</p>
<p>(4) 根据本地事务状态执行Commit或者Rollback（Commit操作生成消息索引，消息对消费者可见）</p>
<p>2、补偿流程（回查）：</p>
<p>(1) 对没有Commit/Rollback的事务消息（pending状态的消息），从服务端发起一次“回查”</p>
<p>(2) Producer收到回查消息，检查回查消息对应的本地事务的状态</p>
<p>(3) 根据本地事务状态，重新Commit或者Rollback</p>
<p>其中，补偿阶段用于解决消息Commit或者Rollback发生超时或者失败的情况。</p>
<h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h2><h4 id="Tags的使用"><a href="#Tags的使用" class="headerlink" title="Tags的使用"></a>Tags的使用</h4><p>一个应用尽可能用一个Topic，而消息子类型则可以用tags来标识。tags可以由应用自由设置，只有生产者在发送消息设置了tags，消费方在订阅消息时才可以利用tags通过broker做消息过滤：message.setTags(“TagA”)。</p>
<h4 id="Keys的使用"><a href="#Keys的使用" class="headerlink" title="Keys的使用"></a>Keys的使用</h4><p>每个消息在业务层面的唯一标识码要设置到keys字段，方便将来定位消息丢失问题。服务器会为每个消息创建索引（哈希索引），应用可以通过topic、key来查询这条消息内容，以及消息被谁消费。由于是哈希索引，请务必保证key尽可能唯一，这样可以避免潜在的哈希冲突。</p>
<h4 id="事务消息-1"><a href="#事务消息-1" class="headerlink" title="事务消息"></a>事务消息</h4><p>执行本地事务 <code>executeLocalTransaction</code> 时，如果业务执行失败，可明确告知回滚，直接返回 <code>Rollback</code>；如果业务成功，不建议直接返回 <code>Commit</code> ，而是建议返回 <code>UNKNOW</code>。</p>
<p>然后在进行事务回查 <code>checkLocalTransaction</code> 时如果能明确事务成功，才返回 <code>Commit</code>。如果不能明确本地事务成功，返回 <code>UNKNOW</code>，服务端默认回查15次。</p>
<h4 id="消息发送失败处理方式"><a href="#消息发送失败处理方式" class="headerlink" title="消息发送失败处理方式"></a>消息发送失败处理方式</h4><p>Producer的send方法本身支持内部重试，重试逻辑如下：</p>
<ul>
<li>至多重试2次。</li>
<li>如果同步模式发送失败，则轮转到下一个Broker，如果异步模式发送失败，则只会在当前Broker进行重试。这个方法的总耗时时间不超过sendMsgTimeout设置的值，默认10s。</li>
<li>如果本身向broker发送消息产生超时异常，就不会再重试。</li>
</ul>
<p>以上策略也是在一定程度上保证了消息可以发送成功。如果业务对消息可靠性要求比较高，建议应用增加相应的重试逻辑：比如调用send同步方法发送失败时，则尝试将消息存储到db，然后由后台线程定时重试，确保消息一定到达Broker。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://github.com/apache/rocketmq/tree/master/docs/cn">rocketmq/docs/cn at master · apache/rocketmq (github.com)</a></p>
]]></content>
      <categories>
        <category>消息队列</category>
      </categories>
      <tags>
        <tag>消息队列</tag>
      </tags>
  </entry>
  <entry>
    <title>初识RocketMQ——基本概念以及安装启动</title>
    <url>/2021/09/12/%E5%88%9D%E8%AF%86RocketMQ%E2%80%94%E2%80%94%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E4%BB%A5%E5%8F%8A%E5%AE%89%E8%A3%85%E5%90%AF%E5%8A%A8/</url>
    <content><![CDATA[<p><strong>RocketMQ</strong> 是一个 <strong>队列模型</strong> 的消息中间件，具有<strong>高性能、高可靠、高实时、分布式</strong> 的特点。</p>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="核心组成"><a href="#核心组成" class="headerlink" title="核心组成"></a>核心组成</h3><p>RocketMQ的四大核心组成部分：<strong>NameServer</strong>、<strong>Broker</strong>、<strong>Producer</strong>以及<strong>Consumer</strong></p>
<hr>
<h4 id="名字服务-NameServer"><a href="#名字服务-NameServer" class="headerlink" title="名字服务 NameServer"></a>名字服务 NameServer</h4><p><strong>作为注册中心，主要负责对于源数据的管理，提供Broker管理以及路由信息管理。</strong></p>
<p>名称服务充当路由消息的提供者。生产者或消费者能够通过名字服务查找各主题相应的Broker IP列表。多个Namesrv实例组成集群，<strong>每个NameServer节点相互独立，没有信息交换。</strong></p>
<p><strong>每个 Broker 在启动的时候会将信息注册到 NameServer ，Producer 在发送消息前会根据 Topic 到 NameServer 获取到 Broker 的路由信息，Consumer 也会定时获取 Topic 的路由信息。</strong></p>
<hr>
<h4 id="代理服务器-Broker"><a href="#代理服务器-Broker" class="headerlink" title="代理服务器 Broker"></a>代理服务器 Broker</h4><p><strong>消息中转角色，负责存储消息、转发消息。</strong>代理服务器在RocketMQ系统中负责接收从生产者发送来的消息并存储、同时为消费者的拉取请求作准备。代理服务器也存储消息相关的元数据，包括消费者组、消费进度偏移和主题和队列消息等。</p>
<hr>
<h4 id="消息生产者-Producer"><a href="#消息生产者-Producer" class="headerlink" title="消息生产者 Producer"></a>消息生产者 Producer</h4><p><strong>负责生产消息</strong>，一般由业务系统负责生产消息。一个消息生产者会把业务应用系统里产生的消息发送到broker服务器。RocketMQ提供多种发送方式，同步发送、异步发送、顺序发送、单向发送。同步和异步方式均需要Broker返回确认信息，单向发送不需要。</p>
<hr>
<h4 id="消息消费者-Consumer"><a href="#消息消费者-Consumer" class="headerlink" title="消息消费者 Consumer"></a>消息消费者 Consumer</h4><p><strong>负责消费消息</strong>，一般是后台系统负责异步消费。一个消息消费者会从Broker服务器拉取消息、并将其提供给应用程序。从用户应用的角度而言提供了两种消费形式：拉取式消费、推动式消费。</p>
<hr>
<h3 id="消息领域模型"><a href="#消息领域模型" class="headerlink" title="消息领域模型"></a>消息领域模型</h3><h4 id="消息模型-Message-Model"><a href="#消息模型-Message-Model" class="headerlink" title="消息模型 Message Model"></a>消息模型 Message Model</h4><p>RocketMQ主要由 Producer、Broker、Consumer 三部分组成，其中Producer 负责生产消息，Consumer 负责消费消息，Broker 负责存储消息。Broker 在实际部署过程中对应一台服务器，<strong>每个 Broker 可以存储多个Topic的消息，每个Topic的消息也可以分片存储于不同的 Broker。</strong>Message Queue 用于存储消息的物理地址，每个Topic中的消息地址存储于多个 Message Queue 中。ConsumerGroup 由多个Consumer 实例构成。</p>
<h4 id="消息-Message"><a href="#消息-Message" class="headerlink" title="消息 Message"></a>消息 Message</h4><p><strong>消息系统所传输信息的物理载体，生产和消费数据的最小单位</strong>，每条消息必须属于一个主题。RocketMQ中每个消息拥有唯一的Message ID，且可以携带具有业务标识的Key。系统提供了通过Message ID和Key查询消息的功能。</p>
<h4 id="主题-Topic"><a href="#主题-Topic" class="headerlink" title="主题 Topic"></a>主题 Topic</h4><p><strong>表示一类消息的集合</strong>，每个主题包含若干条消息，每条消息只能属于一个主题，是RocketMQ进行消息订阅的基本单位。</p>
<blockquote>
<p><strong>Topic</strong> 与生产者和消费者的关系非常松散，一个 Topic 可以有0个、1个、多个生产者向其发送消息，一个生产者也可以同时向不同的 Topic 发送消息。</p>
<p>一个 Topic 也可以被 0个、1个、多个消费者订阅。</p>
</blockquote>
<h4 id="标签-Tag"><a href="#标签-Tag" class="headerlink" title="标签 Tag"></a>标签 Tag</h4><p><strong>为消息设置的标志，用于同一主题下区分不同类型的消息</strong>。来自同一业务单元的消息，可以根据不同业务目的在同一主题下设置不同标签。标签能够有效地保持代码的清晰度和连贯性，并优化RocketMQ提供的查询系统。消费者可以根据Tag实现对不同子主题的不同消费逻辑，实现更好的扩展性。</p>
<h4 id="分组-Group"><a href="#分组-Group" class="headerlink" title="分组 Group"></a>分组 Group</h4><p>分为ProducerGroup，ConsumerGroup，代表某一类的生产者和消费者，一个组可以订阅多个Topic。</p>
<p><strong>ProducerGroup</strong>代表同一类Producer的集合，这类Producer发送同一类消息且发送逻辑一致。如果发送的是事务消息且原始生产者在发送之后崩溃，则Broker服务器会联系同一生产者组的其他生产者实例以提交或回溯消费。</p>
<p><strong>ConsumerGroup</strong>代表同一类Consumer的集合，这类Consumer通常消费同一类消息且消费逻辑一致。消费者组使得在消息消费方面，实现负载均衡和容错的目标变得非常容易。要注意的是，消费者组的消费者实例必须订阅完全相同的Topic。RocketMQ 支持两种消息模式：集群消费（Clustering）和广播消费（Broadcasting）。</p>
<h3 id="消费模式"><a href="#消费模式" class="headerlink" title="消费模式"></a>消费模式</h3><h4 id="集群消费-Clustering"><a href="#集群消费-Clustering" class="headerlink" title="集群消费 Clustering"></a>集群消费 Clustering</h4><p>集群消费模式下,相同Consumer Group的每个Consumer实例平均分摊消息。</p>
<h4 id="广播消费-Broadcasting"><a href="#广播消费-Broadcasting" class="headerlink" title="广播消费 Broadcasting"></a>广播消费 Broadcasting</h4><p>广播消费模式下，相同Consumer Group的每个Consumer实例都接收全量的消息。</p>
<h3 id="消费类型"><a href="#消费类型" class="headerlink" title="消费类型"></a>消费类型</h3><h4 id="拉取式消费-Pull-Consumer"><a href="#拉取式消费-Pull-Consumer" class="headerlink" title="拉取式消费 Pull Consumer"></a>拉取式消费 Pull Consumer</h4><p>Consumer消费的一种类型，应用通常主动调用Consumer的拉消息方法从Broker服务器拉消息、主动权由应用控制。一旦获取了批量消息，应用就会启动消费过程。</p>
<h4 id="推动式消费-Push-Consumer"><a href="#推动式消费-Push-Consumer" class="headerlink" title="推动式消费 Push Consumer"></a>推动式消费 Push Consumer</h4><p>Consumer消费的一种类型，该模式下Broker收到数据后会主动推送给消费端，该消费模式一般实时性较高。</p>
<hr>
<h2 id="架构设计"><a href="#架构设计" class="headerlink" title="架构设计"></a>架构设计</h2><img src="https://gitee.com/KIMTOU/img/raw/master/20210912214133.png" style="zoom:150%;" />



<p><strong>RocketMQ架构上主要分为四部分</strong>，如上图所示:</p>
<ul>
<li><strong>Producer：消息发布的角色</strong>，支持分布式集群方式部署。Producer通过MQ的负载均衡模块选择相应的Broker集群队列进行消息投递，投递的过程支持快速失败并且低延迟。</li>
<li><strong>Consumer：消息消费的角色</strong>，支持分布式集群方式部署。支持以push推，pull拉两种模式对消息进行消费。同时也支持集群方式和广播方式的消费，它提供实时消息订阅机制，可以满足大多数用户的需求。</li>
<li><strong>NameServer：NameServer是一个非常简单的Topic路由注册中心</strong>，其角色类似Dubbo中的zookeeper，支持Broker的动态注册与发现。<strong>主要包括两个功能：Broker管理</strong>，NameServer接受Broker集群的注册信息并且保存下来作为路由信息的基本数据。然后提供心跳检测机制，检查Broker是否还存活；<strong>路由信息管理</strong>，每个NameServer将保存关于Broker集群的整个路由信息和用于客户端查询的队列信息。然后Producer和Conumser通过NameServer就可以知道整个Broker集群的路由信息，从而进行消息的投递和消费。NameServer通常也是集群的方式部署，各实例间相互不进行信息通讯。Broker是向每一台NameServer注册自己的路由信息，所以每一个NameServer实例上面都保存一份完整的路由信息。当某个NameServer因某种原因下线了，Broker仍然可以向其它NameServer同步其路由信息，Producer,Consumer仍然可以动态感知Broker的路由的信息。</li>
<li><strong>BrokerServer：Broker主要负责消息的存储、投递和查询以及服务高可用保证</strong></li>
</ul>
<h4 id="RocketMQ-网络部署特点"><a href="#RocketMQ-网络部署特点" class="headerlink" title="RocketMQ 网络部署特点"></a>RocketMQ 网络部署特点</h4><ul>
<li>NameServer是一个几乎无状态节点，可集群部署，节点之间无任何信息同步。</li>
<li>Broker部署相对复杂，Broker分为Master与Slave，一个Master可以对应多个Slave，但是一个Slave只能对应一个Master，Master与Slave 的对应关系通过指定相同的BrokerName，不同的BrokerId 来定义，BrokerId为0表示Master，非0表示Slave。Master也可以部署多个。每个Broker与NameServer集群中的所有节点建立长连接，定时注册Topic信息到所有NameServer。 注意：当前RocketMQ版本在部署架构上支持一Master多Slave，但只有BrokerId=1的从服务器才会参与消息的读负载。</li>
<li>Producer与NameServer集群中的其中一个节点（随机选择）建立长连接，定期从NameServer获取Topic路由信息，并向提供Topic 服务的Master建立长连接，且定时向Master发送心跳。Producer完全无状态，可集群部署。</li>
<li>Consumer与NameServer集群中的其中一个节点（随机选择）建立长连接，定期从NameServer获取Topic路由信息，并向提供Topic服务的Master、Slave建立长连接，且定时向Master、Slave发送心跳。Consumer既可以从Master订阅消息，也可以从Slave订阅消息，消费者在向Master拉取消息时，Master服务器会根据拉取偏移量与最大偏移量的距离（判断是否读老消息，产生读I/O），以及从服务器是否可读等因素建议下一次是从Master还是Slave拉取。</li>
</ul>
<h4 id="集群工作流程"><a href="#集群工作流程" class="headerlink" title="集群工作流程"></a>集群工作流程</h4><ul>
<li>启动NameServer，NameServer起来后监听端口，等待Broker、Producer、Consumer连上来，相当于一个路由控制中心。</li>
<li>Broker启动，跟所有的NameServer保持长连接，定时发送心跳包。心跳包中包含当前Broker信息(IP+端口等)以及存储所有Topic信息。注册成功后，NameServer集群中就有Topic跟Broker的映射关系。</li>
<li>收发消息前，先创建Topic，创建Topic时需要指定该Topic要存储在哪些Broker上，也可以在发送消息时自动创建Topic。</li>
<li>Producer发送消息，启动时先跟NameServer集群中的其中一台建立长连接，并从NameServer中获取当前发送的Topic存在哪些Broker上，轮询从队列列表中选择一个队列，然后与队列所在的Broker建立长连接从而向Broker发消息。</li>
<li>Consumer跟Producer类似，跟其中一台NameServer建立长连接，获取当前订阅Topic存在哪些Broker上，然后直接跟Broker建立连接通道，开始消费消息。</li>
</ul>
<hr>
<h2 id="安装启动（Linux）"><a href="#安装启动（Linux）" class="headerlink" title="安装启动（Linux）"></a>安装启动（Linux）</h2><h4 id="1、下载压缩包"><a href="#1、下载压缩包" class="headerlink" title="1、下载压缩包"></a>1、下载压缩包</h4><p>镜像下载地址：<a href="https://mirrors.bfsu.edu.cn/apache/rocketmq/4.9.1/rocketmq-all-4.9.1-source-release.zip"><strong>https://mirrors.bfsu.edu.cn/apache/rocketmq/4.9.1/rocketmq-all-4.9.1-source-release.zip</strong></a></p>
<h4 id="2、将压缩包上传至Linux"><a href="#2、将压缩包上传至Linux" class="headerlink" title="2、将压缩包上传至Linux"></a>2、将压缩包上传至Linux</h4><ul>
<li>解压</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">unzip rocketmq-all-4.9.1-source-release.zip</span><br></pre></td></tr></table></figure>

<h4 id="3、修改配置文件"><a href="#3、修改配置文件" class="headerlink" title="3、修改配置文件"></a>3、修改配置文件</h4><p>启动顺序为先启动NameServer，再启动Broker。但是启动之前需要先检查自己服务器内存情况，因为默认参数需要的JVM内存较大，因此需要修改这两个的配置文件（<code>runserver.sh</code>、<code>runbroker.sh</code>）。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 进入对应目录</span></span><br><span class="line">cd /home/rocketmq/rocketmq-all-4.9.1-bin-release/bin</span><br><span class="line"><span class="meta">#</span><span class="bash"> 修改NameServer配置文件</span></span><br><span class="line">vim runserver.sh</span><br></pre></td></tr></table></figure>

<ul>
<li>查找JVM配置：</li>
</ul>
<p><img src="https://gitee.com/KIMTOU/img/raw/master/20210912214128.PNG"></p>
<ul>
<li>将其修改成：</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">JAVA_OPT=&quot;$&#123;JAVA_OPT&#125; -server -Xms256m -Xmx256m -Xmn128m -XX:MetaspaceSize=128m -XX:MaxMetaspaceSize=320m&quot;</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 修改Broker配置文件</span></span><br><span class="line">vim runbroker.sh</span><br></pre></td></tr></table></figure>

<ul>
<li>查找JVM配置：</li>
</ul>
<p><img src="https://gitee.com/KIMTOU/img/raw/master/20210912214122.PNG"></p>
<p>将其修改成：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">JAVA_OPT=&quot;$&#123;JAVA_OPT&#125; -server -Xms256m -Xmx256m&quot;</span><br></pre></td></tr></table></figure>

<h4 id="4、启动"><a href="#4、启动" class="headerlink" title="4、启动"></a>4、启动</h4><ul>
<li>进入bin目录</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@CJT-Linux bin]# pwd</span><br><span class="line">/home/rocketmq/rocketmq-all-4.9.1-bin-release/bin</span><br></pre></td></tr></table></figure>

<ul>
<li>启动NameServer</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nohup sh mqnamesrv &amp;</span><br></pre></td></tr></table></figure>

<ul>
<li>检查是否启动成功</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tail -f ~/logs/rocketmqlogs/namesrv.log</span><br><span class="line"><span class="meta">#</span><span class="bash"> 出现 The Name Server boot success...代表启动成功</span></span><br></pre></td></tr></table></figure>

<ul>
<li>启动Broker</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nohup sh mqbroker -n localhost:9876 &amp;</span><br></pre></td></tr></table></figure>

<ul>
<li>检查是否启动成功</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tail -f ~/logs/rocketmqlogs/broker.log </span><br></pre></td></tr></table></figure>

<h4 id="5、测试"><a href="#5、测试" class="headerlink" title="5、测试"></a>5、测试</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 配置NameServer地址</span></span><br><span class="line">export NAMESRV_ADDR=localhost:9876</span><br><span class="line"><span class="meta">#</span><span class="bash"> 生产数据</span></span><br><span class="line">sh tools.sh org.apache.rocketmq.example.quickstart.Producer</span><br><span class="line"><span class="meta">#</span><span class="bash"> 消费数据</span></span><br><span class="line">sh tools.sh org.apache.rocketmq.example.quickstart.Consumer</span><br></pre></td></tr></table></figure>



<h4 id="Window环境下安装启动"><a href="#Window环境下安装启动" class="headerlink" title="Window环境下安装启动"></a>Window环境下安装启动</h4><p>1、下载压缩包并解压</p>
<p>2、配置系统环境</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">ROCKETMQ_HOME</span>=<span class="string">&quot;D:\rocketmq&quot;</span></span><br><span class="line"><span class="attr">NAMESRV_ADDR</span>=<span class="string">&quot;localhost:9876&quot;</span></span><br></pre></td></tr></table></figure>

<p>3、在bin目录下启动<code>mqnamesrv.cmd</code>，再启动<code>mqbroker.cmd</code></p>
<hr>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>中文官方文档：<a href="https://github.com/apache/rocketmq/blob/master/docs/cn">https://github.com/apache/rocketmq/blob/master/docs/cn</a></p>
<p><a href="https://blog.csdn.net/qq_35190492/article/details/103341634?ops_request_misc=%7B%22request_id%22:%22162972269016780271584378%22,%22scm%22:%2220140713.130102334.pc_blog.%22%7D&request_id=162972269016780271584378&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_v2~rank_v29-1-103341634.pc_v2_rank_blog_default&utm_term=rocket&spm=1018.2226.3001.4450">看完保送阿里的RocketMQ知识点（超详细）_敖丙-CSDN博客</a></p>
<p><a href="http://rocketmq.apache.org/docs/quick-start/">Quick Start - Apache RocketMQ</a></p>
]]></content>
      <categories>
        <category>消息队列</category>
      </categories>
      <tags>
        <tag>消息队列</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式——单例模式</title>
    <url>/2021/09/26/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<ul>
<li><strong>作用：单例模式主要解决的是，防止一个全局使用的类频繁的创建和消费，从而提升提升整体的代码的性能。</strong></li>
</ul>
<ul>
<li><strong>特点：单例模式有一个特点就是不允许外部直接创建，因此在默认的构造函数上添加了私有属性 <code>private</code>。</strong></li>
</ul>
<h2 id="懒汉式（线程不安全）"><a href="#懒汉式（线程不安全）" class="headerlink" title="懒汉式（线程不安全）"></a>懒汉式（线程不安全）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 懒汉式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Lazy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Lazy instance;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 私有构造方法，防止被实例化</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Lazy</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Lazy <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Lazy();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>优点</strong>：延迟加载，真正用的时候才实例化对象，提高了资源的利用率</p>
<p><strong>缺点</strong>：存在并发访问的问题（可能进行了多次new操作）</p>
<h2 id="懒汉式（线程安全）"><a href="#懒汉式（线程安全）" class="headerlink" title="懒汉式（线程安全）"></a>懒汉式（线程安全）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 懒汉式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Lazy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Lazy instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Lazy</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> Lazy <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Lazy();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>拥有上面懒汉式的优点，同时也克服了其缺点，使用<code>synchronized</code>关键字同步加锁，保证了线程安全，但所有的访问都需要加锁，造成了资源的浪费。</p>
<h2 id="饿汉式（线程安全）"><a href="#饿汉式（线程安全）" class="headerlink" title="饿汉式（线程安全）"></a>饿汉式（线程安全）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 饿汉式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hungry</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Hungry hungry = <span class="keyword">new</span> Hungry();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 私有构造方法，防止被实例化</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Hungry</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Hungry <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> hungry;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>优点</strong>：static变量会在类装载时初始化，不存在并发访问问题，可以省略synchronized关键字</p>
<p><strong>缺点</strong>：类初始化时就创建了对象，如果只是加载本类，而不是要调用 getInstance()，甚至永远没有调用，则会造成资源浪费</p>
<h2 id="双重校验锁（线程安全）"><a href="#双重校验锁（线程安全）" class="headerlink" title="双重校验锁（线程安全）"></a>双重校验锁（线程安全）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 双重校验锁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DoubleLock</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> DoubleLock instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">DoubleLock</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DoubleLock <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance != <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> instance;</span><br><span class="line">        <span class="keyword">synchronized</span> (DoubleLock.class)&#123;</span><br><span class="line">            <span class="keyword">if</span>(instance == <span class="keyword">null</span>)</span><br><span class="line">                instance = <span class="keyword">new</span> DoubleLock();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>双重锁的方式是方法级锁的优化，减少了部分获取实例的耗时。</li>
<li>同时这种方式也满足了懒加载。</li>
</ul>
<p><strong>为什么使用<code>volatile</code> ？</strong></p>
<blockquote>
<p>采⽤ volatile 关键字修饰也是很有必要的， singleton = new Singleton(); 这段代码其实是分为三步执⾏： </p>
<ol>
<li><p>为 singleton 分配内存空间 </p>
</li>
<li><p>初始化 singleton </p>
</li>
<li><p>将 singleton 指向分配的内存地址 </p>
<p>但是由于 JVM 具有指令重排的特性，执⾏顺序有可能变成 1-3-2。指令重排在单线程环境下不会出 现问题，但是在多线程环境下会导致⼀个线程获得还没有初始化的实例。例如，线程 T1 执⾏了 1 和 3，此时 T2 调⽤ getInstance() 后发现 singleton 不为空，因此返回 singleton ，但此时 singleton 还未被初始化。 使⽤ volatile 可以禁⽌ JVM 的指令重排，保证在多线程环境下也能正常运⾏。</p>
</li>
</ol>
</blockquote>
<h2 id="静态内部类（线程安全）"><a href="#静态内部类（线程安全）" class="headerlink" title="静态内部类（线程安全）"></a>静态内部类（线程安全）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 静态内部类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerClass</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">inner</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> InnerClass instance = <span class="keyword">new</span> InnerClass();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">InnerClass</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> InnerClass <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> inner.instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>既保证了线程安全又保证了懒加载，同时不会因为加锁的方式耗费性能。</li>
</ul>
<ul>
<li>这主要是因为JVM虚拟机可以保证多线程并发访问的正确性，也就是一个类的构造方法在多线程环境下可以被正确的加载。</li>
</ul>
<h2 id="CAS（线程安全）"><a href="#CAS（线程安全）" class="headerlink" title="CAS（线程安全）"></a>CAS（线程安全）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * CAS</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CAS</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicReference&lt;CAS&gt; INSTANCE = <span class="keyword">new</span> AtomicReference&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">CAS</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> CAS <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>( ; ; )&#123;</span><br><span class="line">            CAS instance = INSTANCE.get();</span><br><span class="line">            <span class="keyword">if</span>(instance != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> instance;</span><br><span class="line">            &#125;</span><br><span class="line">            INSTANCE.compareAndSet(<span class="keyword">null</span>, <span class="keyword">new</span> CAS());</span><br><span class="line">            <span class="keyword">return</span> INSTANCE.get();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>java并发库提供了很多原子类来支持并发访问的数据安全性；<code>AtomicInteger</code>、<code>AtomicBoolean</code>、<code>AtomicLong</code>、<code>AtomicReference</code>。</li>
<li>AtomicReference 可以封装引用一个V实例，支持并发访问如上的单例方式就是使用了这样的一个特点。</li>
<li>使用CAS的好处就是不需要使用传统的加锁方式保证线程安全，而是依赖于CAS的忙等算法，依赖于底层硬件的实现，来保证线程安全。相对于其他锁的实现没有线程的切换和阻塞也就没有了额外的开销，并且可以支持较大的并发性。</li>
<li>当然CAS也有一个缺点就是忙等，如果一直没有获取到将会处于死循环中。</li>
</ul>
<h2 id="枚举单例（线程安全）"><a href="#枚举单例（线程安全）" class="headerlink" title="枚举单例（线程安全）"></a>枚举单例（线程安全）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 枚举单例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">EnumSingle</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    INSTANCE;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;枚举单例&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        EnumSingle.INSTANCE.test();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>优点</strong>：实现简单，枚举本身就是单例模式。由JVM从根本上提供保障！避免通过反射和反序列化的漏洞！</li>
<li><strong>缺点</strong>：无延迟加载</li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://bugstack.cn/itstack-demo-design/2020/05/31/%E9%87%8D%E5%AD%A6-Java-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%AE%9E%E6%88%98%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F.html">重学 Java 设计模式：实战单例模式「7种单例模式案例，Effective Java 作者推荐枚举单例模式」 - bugstack虫洞栈</a></p>
<p><a href="https://bareth.blog.csdn.net/article/details/116643620">彻底玩转单例模式</a></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式——工厂模式</title>
    <url>/2021/09/26/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><ul>
<li>简单工厂模式</li>
<li>工厂方法模式</li>
<li>抽象工厂模式</li>
</ul>
<h2 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h2><p><strong>作用：在创建一个对象时不向客户暴露内部细节，并提供一个创建对象的通用接口。</strong></p>
<p>简单工厂把实例化的操作单独放到一个类中，这个类就成为简单工厂类，让简单工厂类来决定应该用哪个具体子类来实例化。</p>
<p>这样做能把客户类和具体子类的实现解耦，客户类不再需要知道有哪些子类以及应当实例化哪个子类。客户类往往有多个，如果不使用简单工厂，那么所有的客户类都要知道所有子类的细节。而且一旦子类发生改变，例如增加子类，那么所有的客户类都要进行修改。</p>
<h4 id="1、创建父类或父接口"><a href="#1、创建父类或父接口" class="headerlink" title="1、创建父类或父接口"></a>1、创建父类或父接口</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String productName;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getProductName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> productName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setProductName</span><span class="params">(String productName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.productName = productName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Product&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;productName=&#x27;&quot;</span> + productName + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2、多个子类继承或实现"><a href="#2、多个子类继承或实现" class="headerlink" title="2、多个子类继承或实现"></a>2、多个子类继承或实现</h4><h4 id="3、简单工厂实现"><a href="#3、简单工厂实现" class="headerlink" title="3、简单工厂实现"></a>3、简单工厂实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Product <span class="title">createProduct</span><span class="params">(ProductTypeEnum productType)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(ProductTypeEnum.product_ONE.equals(productType))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ProductOne();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(ProductTypeEnum.product_TWO.equals(productType))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ProductTwo();</span><br><span class="line">        &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Product();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4、客户端调用"><a href="#4、客户端调用" class="headerlink" title="4、客户端调用"></a>4、客户端调用</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FactoryClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Product product = SimpleFactory.createProduct(ProductTypeEnum.product_ONE);</span><br><span class="line">        System.out.println(product);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h2><p><strong>作用：定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法模式使一个类的实例化延迟到其子类。</strong></p>
<p>在简单工厂中，创建对象的是另一个类，而在工厂方法中，是由子类来创建对象。<strong>工厂类直接被抽象化，需要具体特定化的逻辑代码转移到实现抽象方法的子类中，这样我们就不要再去修改工厂类</strong>，即不用再去做什么 if else 的修改。</p>
<p>简单说就是为了提供代码结构的扩展性，屏蔽每一个功能类中的具体实现逻辑。让外部可以更加简单的只是知道调用即可，同时，这也是去掉众多<code>ifelse</code>的方式。当然这可能也有一些缺点，比如需要实现的类非常多，如何去维护，怎样减低开发成本。</p>
<h4 id="1、创建工厂方法类"><a href="#1、创建工厂方法类" class="headerlink" title="1、创建工厂方法类"></a>1、创建工厂方法类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">FactoryMethod</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Product <span class="title">createProduct</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">registerProduct</span><span class="params">(Product product)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">create</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Product product = createProduct();</span><br><span class="line">        registerProduct(product);</span><br><span class="line">        <span class="keyword">return</span> product;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2、实现工厂方法的子类"><a href="#2、实现工厂方法的子类" class="headerlink" title="2、实现工厂方法的子类"></a>2、实现工厂方法的子类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 不同类型的商品的工厂</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductFactory</span> <span class="keyword">extends</span> <span class="title">FactoryMethod</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">createProduct</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Product product = <span class="keyword">new</span> ProductOne();</span><br><span class="line">        System.out.println(<span class="string">&quot;创建商品 &quot;</span> + product.toString());</span><br><span class="line">        <span class="keyword">return</span> product;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerProduct</span><span class="params">(Product product)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;注册商品 &quot;</span> + product.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3、客户端调用"><a href="#3、客户端调用" class="headerlink" title="3、客户端调用"></a>3、客户端调用</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FactoryClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        FactoryMethod factoryMethod = <span class="keyword">new</span> ProductFactory();</span><br><span class="line">        Product product = factoryMethod.create();</span><br><span class="line">        System.out.println(product);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="何时使用工厂方法模式，而非简单工厂"><a href="#何时使用工厂方法模式，而非简单工厂" class="headerlink" title="何时使用工厂方法模式，而非简单工厂"></a>何时使用工厂方法模式，而非简单工厂</h2><blockquote>
<p><strong>当对象的创建逻辑比较复杂，不只是简单的 new 一下就可以</strong>，而是要组合其他类对象，做各种初始化操作的时候，我们推荐使用工厂方法模式，将复杂的创建逻辑拆分到多个工厂类中，让每个工厂类都不至于过于复杂。</p>
<p>而使用简单工厂模式，将所有的创建逻辑都放到一个工厂类中，会导致这个工厂类变得很复杂</p>
</blockquote>
<h2 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h2><p>工厂方法类中只有一个抽象方法，要想实现多种不同的类对象，只能去创建不同的具体工厂方法的子类来实列化，而抽象工厂则是让一个工厂负责创建多个不同类型的对象。</p>
<p><strong>抽象工厂模式创建的是对象家族，也就是很多对象而不是一个对象，并且这些对象是相关的</strong>，也就是说必须一起创建出来。而工厂方法模式只是用于创建一个对象，这和抽象工厂模式有很大不同。</p>
<h4 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractProductA</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractProductB</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductA1</span> <span class="keyword">extends</span> <span class="title">AbstractProductA</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductA2</span> <span class="keyword">extends</span> <span class="title">AbstractProductA</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductB1</span> <span class="keyword">extends</span> <span class="title">AbstractProductB</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductB2</span> <span class="keyword">extends</span> <span class="title">AbstractProductB</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> AbstractProductA <span class="title">createProductA</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> AbstractProductB <span class="title">createProductB</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteFactory1</span> <span class="keyword">extends</span> <span class="title">AbstractFactory</span> </span>&#123;</span><br><span class="line">    <span class="function">AbstractProductA <span class="title">createProductA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ProductA1();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">AbstractProductB <span class="title">createProductB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ProductB1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteFactory2</span> <span class="keyword">extends</span> <span class="title">AbstractFactory</span> </span>&#123;</span><br><span class="line">    <span class="function">AbstractProductA <span class="title">createProductA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ProductA2();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">AbstractProductB <span class="title">createProductB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ProductB2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AbstractFactory abstractFactory = <span class="keyword">new</span> ConcreteFactory1();</span><br><span class="line">        AbstractProductA productA = abstractFactory.createProductA();</span><br><span class="line">        AbstractProductB productB = abstractFactory.createProductB();</span><br><span class="line">        <span class="comment">// do something with productA and productB</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><p>1、良好的封装性、代码结构清晰。</p>
<p>如一个调用者想创建一个对象，只需要知道其名称即可，降低了模板间的耦合。</p>
<p>2、扩展性好。</p>
<p>如果想增加一个产品，只需扩展一个工厂类即可。</p>
<p>3、屏蔽产品类</p>
<p>调用者只关心产品的接口。</p>
<p>4、典型的解耦框架</p>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>每增加一个产品，就需要增加一个产品工厂的类，增加了系统的复杂度。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://mp.weixin.qq.com/s?__biz=MzAwNDA2OTM1Ng==&mid=2453151278&idx=1&sn=e2a702fea5a93b6300b90d9958ff9ec1&chksm=8cfd3cadbb8ab5bba091b70ff0b3ce759eab18b5e9e48464bd1c031eb1c56ed305c7e0de7f8b&scene=178&cur_album_id=1761987817540206592#rd">敖丙所在的电商公司都是怎么用工厂模式的 (qq.com)</a></p>
<p>[CS-Notes/设计模式 - 抽象工厂.md at master · CyC2018/CS-Notes (github.com)](<a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F">https://github.com/CyC2018/CS-Notes/blob/master/notes/设计模式</a> - 抽象工厂.md)</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式——模板方法模式</title>
    <url>/2021/09/27/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><ul>
<li><p>定义算法框架，并将一些步骤的实现延迟到子类。</p>
</li>
<li><p>通过模板方法，子类可以重新定义算法的某些步骤，而不用改变算法的结构。</p>
</li>
</ul>
<h2 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h2><p>1、使用模版方法模式的目的是避免编写重复代码，以便开发人员可以专注于核心业务逻辑的实现</p>
<p>2、解决接口与接口实现类之间继承矛盾问题</p>
<h2 id="类关系"><a href="#类关系" class="headerlink" title="类关系"></a>类关系</h2><ul>
<li>AbstractTemplate（抽象模版）：定义一系列抽象方法，或者实现的方法，又或者是钩子方法。即：定义流程</li>
<li>ConcreteTemplate（具体模版）：实现父类抽象方法，基于本身不同的模版业务逻辑，实现不同的业务逻辑代码。即：抽象方法实现相同，内部逻辑不同</li>
</ul>
<h2 id="1、定义模板"><a href="#1、定义模板" class="headerlink" title="1、定义模板"></a>1、定义模板</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 工作流模板</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">WorkFlow</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">doWorkFlow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        initial();</span><br><span class="line">        firstProcess();</span><br><span class="line">        secondProcess();</span><br><span class="line">        end();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">initial</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;初始化&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理一级业务逻辑</span></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">firstProcess</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理二级业务逻辑（默认无实现，子类视情况进行覆盖）</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">secondProcess</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 结束处理</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">end</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;结束处理&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>钩子方法</li>
</ul>
<p>在模板方法模式的抽象父类中，我们可以定义一个方法，它默认不做任何事，子类可以视情况覆盖它，该方法称为钩子方法。</p>
<h2 id="2、实现具体模板"><a href="#2、实现具体模板" class="headerlink" title="2、实现具体模板"></a>2、实现具体模板</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 工作流种类 A</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WorkFlowA</span> <span class="keyword">extends</span> <span class="title">WorkFlow</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">firstProcess</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;WorkFlowA 处理一级业务&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">secondProcess</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;WorkFlowA 处理二级业务&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 工作流种类 B</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WorkFlowB</span> <span class="keyword">extends</span> <span class="title">WorkFlow</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">firstProcess</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;WorkFlowB 处理一级业务&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3、测试"><a href="#3、测试" class="headerlink" title="3、测试"></a>3、测试</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TemplateClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        WorkFlow workFlowA = <span class="keyword">new</span> WorkFlowA();</span><br><span class="line">        WorkFlow workFlowB = <span class="keyword">new</span> WorkFlowB();</span><br><span class="line">        workFlowA.doWorkFlow();</span><br><span class="line">        workFlowB.doWorkFlow();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>1、多个子类有共有的方法，并且逻辑基本相同。</p>
<p>2、重要、复杂的算法，可以把核心算法设计为模板方法，周边的相关细节功能则由各个子类实现。</p>
<p>3、重构时，模板方法是一个经常使用的方法，把相同的代码抽取到父类中，然后通过构造函数约束其行为。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://mp.weixin.qq.com/s?__biz=MzAwNDA2OTM1Ng==&mid=2453152193&idx=1&sn=a0884e2c27c8031c8075464bf1047e95&chksm=8cfd0342bb8a8a54ba46609ab6e66a2d90059548f787c5c4ddc6a01bbcadf916d4e91e9fb92c&scene=178&cur_album_id=1761987817540206592#rd">模板方法  (qq.com)</a></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式——观察者模式</title>
    <url>/2021/09/27/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>定义对象之间的一对多依赖，当一个对象状态改变时，它的所有依赖都会收到通知并且自动更新状态。</p>
<p>主题（Subject）是被观察的对象，而其所有依赖者（Observer）称为观察者。</p>
<h2 id="类关系"><a href="#类关系" class="headerlink" title="类关系"></a>类关系</h2><p>主题（Subject）具有注册和移除观察者、并通知所有观察者的功能，主题是通过维护一张观察者列表来实现这些操作的。</p>
<p>观察者（Observer）的注册功能需要调用主题的 registerObserver() 方法。</p>
<h2 id="1、创建主题定义"><a href="#1、创建主题定义" class="headerlink" title="1、创建主题定义"></a>1、创建主题定义</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 订阅</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(EventListener eventListener)</span></span>;</span><br><span class="line">    <span class="comment">// 取消订阅</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unsubscribe</span><span class="params">(EventListener eventListener)</span></span>;</span><br><span class="line">    <span class="comment">// 通知观察者</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">notifyObserver</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2、定义具体主题"><a href="#2、定义具体主题" class="headerlink" title="2、定义具体主题"></a>2、定义具体主题</h2><p>创建主题的具体实现，并且构建一个容器来维护订阅关系，支持添加删除关系，以及通知订阅者。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteSubject</span> <span class="keyword">implements</span> <span class="title">Subject</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;EventListener&gt; observers = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;具体主题业务逻辑实现&quot;</span>);</span><br><span class="line">        notifyObserver();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(EventListener eventListener)</span> </span>&#123;</span><br><span class="line">        observers.add(eventListener);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unsubscribe</span><span class="params">(EventListener eventListener)</span> </span>&#123;</span><br><span class="line">        observers.remove(eventListener);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyObserver</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (EventListener eventListener : observers)&#123;</span><br><span class="line">            eventListener.doEvent();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3、定义观察者（事件监听者）"><a href="#3、定义观察者（事件监听者）" class="headerlink" title="3、定义观察者（事件监听者）"></a>3、定义观察者（事件监听者）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">EventListener</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 执行事件</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doEvent</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4、观察者实现"><a href="#4、观察者实现" class="headerlink" title="4、观察者实现"></a>4、观察者实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EventListenerImplA</span> <span class="keyword">implements</span> <span class="title">EventListener</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doEvent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;观察者 A 监听事件&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EventListenerImplB</span> <span class="keyword">implements</span> <span class="title">EventListener</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doEvent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;观察者 B 监听事件&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5、客户端测试"><a href="#5、客户端测试" class="headerlink" title="5、客户端测试"></a>5、客户端测试</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ConcreteSubject subject = <span class="keyword">new</span> ConcreteSubject();</span><br><span class="line">        subject.subscribe(<span class="keyword">new</span> EventListenerImplA());</span><br><span class="line">        subject.subscribe(<span class="keyword">new</span> EventListenerImplB());</span><br><span class="line">        subject.doSomething();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>一般在开发中会把主线流程开发完成后，再使用通知的方式处理辅助流程。他们可以是异步的，在MQ以及定时任务的处理下，保证最终一致性。</p>
<p><strong>观察者模式达到了解耦合的效果，减少了依赖关系，每个观察者根本不需要知道发布者处理了什么业务逻辑，也不用依赖发布者任何业务模型，只关心自己本身需要处理的逻辑就可以了。</strong></p>
<p>如果有新的业务添加进来，我们也只需要创建一个新的订阅者，并且维护到observers 容器中即可，也符合我们的开闭原则。</p>
<p>这里只是一种同步的实现方式，我们还可以扩展更多其他的异步实现方式，或者采用多线程等实现方式。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://mp.weixin.qq.com/s?__biz=MzAwNDA2OTM1Ng==&mid=2453152034&idx=1&sn=1e1db22c4a7cb2bfcc4a7ce141a9ef00&chksm=8cfd03a1bb8a8ab75c824b6866b1960485276f1dae410567d917bd0be71e4d071ab146e147cd&scene=178&cur_album_id=1761987817540206592#rd">观察者模式 (qq.com)</a></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
</search>
