<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>SpringBoot实现MySQL读写分离</title>
    <url>/2021/05/27/SpringBoot%E5%AE%9E%E7%8E%B0MySQL%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB/</url>
    <content><![CDATA[<p>在高并发下，需要对应用进行读写分离，配置多数据源，即写操作走主库，读操作则走从库，主从数据库负责各自的读和写，缓解了锁的争用，提高了读取性能。</p>
<p>实现读写分离有多种方式，如使用中间件MyCat、Sharding-JDBC等，这里我们使用<strong>Aop</strong>的方式在代码层面实现读写分离。</p>
<br>

<h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p>实现读写分离，首先要对Mysql做主从复制，即搭建一个主数据库，以及一个或多个从数据库。</p>
<p>具体实现主从复制，可参照<a href="https://blog.tojintao.cn/2021/05/27/%E5%9F%BA%E4%BA%8Edocker%E5%AE%9E%E7%8E%B0MySQL%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/">《基于docker实现MySQL主从复制》</a></p>
<p>使用Aop的方式，当调用业务层方法前，判断请求是否是只读操作，动态切换数据源，如果是只读操作，则切换从数据库的数据源，否则使用主数据库的数据源。</p>
<br>

<h2 id="系统架构"><a href="#系统架构" class="headerlink" title="系统架构"></a>系统架构</h2><p>:rocket: 项目仓库：<a href="https://github.com/KimTou/Open-LetFit">KimTou/Open-LetFit: LetFit小程序后台开源版 </a></p>
<p>这是我之前写的一个项目，具体代码可以在可以在上面我的GitHub仓库中找到，项目就是使用了本文章介绍的读写分离方式，感兴趣的同学可以作为参考。</p>
<p><img src="https://gitee.com/KIMTOU/img/raw/master/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84.png"></p>
<br>

<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h4 id="在application-yml配置MySQL"><a href="#在application-yml配置MySQL" class="headerlink" title="在application.yml配置MySQL"></a>在application.yml配置MySQL</h4><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">com.alibaba.druid.pool.DruidDataSource</span></span><br><span class="line">    <span class="comment">#主机</span></span><br><span class="line">    <span class="attr">master:</span></span><br><span class="line">      <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">      <span class="attr">password:</span> <span class="number">123456</span></span><br><span class="line">      <span class="attr">url:</span> <span class="string">jdbc:mysql://服务器ip:3306/letfit?useSSL=false&amp;useUnicode=true&amp;characterEncoding=utf8&amp;serverTimezone=GMT</span></span><br><span class="line">      <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">    <span class="comment">#从机</span></span><br><span class="line">    <span class="attr">slave:</span></span><br><span class="line">      <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">      <span class="attr">password:</span> <span class="number">123456</span></span><br><span class="line">      <span class="attr">url:</span> <span class="string">jdbc:mysql://服务器ip:3307/letfit?useSSL=false&amp;useUnicode=true&amp;characterEncoding=utf8&amp;serverTimezone=GMT</span></span><br><span class="line">      <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">    <span class="comment">#连接池</span></span><br><span class="line">    <span class="attr">druid:</span></span><br><span class="line">      <span class="attr">initialSize:</span> <span class="number">5</span></span><br><span class="line">      <span class="attr">minIdle:</span> <span class="number">5</span></span><br><span class="line">      <span class="attr">maxActive:</span> <span class="number">20</span></span><br><span class="line">      <span class="attr">maxWait:</span> <span class="number">60000</span></span><br><span class="line">      <span class="attr">timeBetweenEvictionRunsMillis:</span> <span class="number">60000</span></span><br><span class="line">      <span class="attr">minEvictableIdleTimeMillis:</span> <span class="number">300000</span></span><br><span class="line">      <span class="attr">validationQuery:</span> <span class="string">SELECT</span> <span class="number">1</span> <span class="string">FROM</span> <span class="string">DUAL</span></span><br><span class="line">      <span class="attr">testWhileIdle:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">testOnBorrow:</span> <span class="literal">false</span></span><br><span class="line">      <span class="attr">testOnReturn:</span> <span class="literal">false</span></span><br><span class="line">      <span class="attr">poolPreparedStatements:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">filters:</span> <span class="string">stat,wall</span></span><br><span class="line">      <span class="attr">maxPoolPreparedStatementPerConnectionSize:</span> <span class="number">20</span></span><br><span class="line">      <span class="attr">useGlobalDataSourceStat:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">connectionProperties:</span> <span class="string">druid.stat.mergeSql=true;druid.stat.slowSqlMillis=500</span></span><br></pre></td></tr></table></figure>

<br>

<h4 id="创建-ReadOnly-注解"><a href="#创建-ReadOnly-注解" class="headerlink" title="创建 ReadOnly 注解"></a>创建 <code>ReadOnly</code> 注解</h4><p>在业务层的方法上使用该注解，使用 <code>ReadOnly</code> 注解的方法只处理读操作，会切换到从机的数据源</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.letfit.aop.annotation;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 只读注解</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.METHOD, ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> ReadOnly &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<h4 id="创建枚举类"><a href="#创建枚举类" class="headerlink" title="创建枚举类"></a>创建枚举类</h4><p>定义两个枚举类型 <code>MASTER</code>、<code>slave</code>分别代表数据库类型</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.letfit.common;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 数据库类型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">DBTypeEnum</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 主数据库</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    MASTER,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从数据库</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    SLAVE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<h4 id="编写动态切换数据源的工具类"><a href="#编写动态切换数据源的工具类" class="headerlink" title="编写动态切换数据源的工具类"></a>编写动态切换数据源的工具类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.letfit.util;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 动态切换数据源工具类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicDbUtil</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用来存储代表数据源的对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;DBTypeEnum&gt; CONTEXT_HAND = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 切换当前线程要使用的数据源</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> dbTypeEnum</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(DBTypeEnum dbTypeEnum)</span></span>&#123;</span><br><span class="line">        CONTEXT_HAND.set(dbTypeEnum);</span><br><span class="line">        log.info(<span class="string">&quot;切换数据源:&#123;&#125;&quot;</span>, dbTypeEnum);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 切换到主数据库</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">master</span><span class="params">()</span></span>&#123;</span><br><span class="line">        set(DBTypeEnum.MASTER);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 切换到从数据库</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">slave</span><span class="params">()</span></span>&#123;</span><br><span class="line">        set(DBTypeEnum.SLAVE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 移除当前线程使用的数据源</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span></span>&#123;</span><br><span class="line">        CONTEXT_HAND.remove();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取当前线程使用的枚举类</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DBTypeEnum <span class="title">get</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> CONTEXT_HAND.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<h4 id="编写-AbstractRoutingDataSource的实现类"><a href="#编写-AbstractRoutingDataSource的实现类" class="headerlink" title="编写 AbstractRoutingDataSource的实现类"></a>编写 <code>AbstractRoutingDataSource</code>的实现类</h4><blockquote>
<p>Spring boot提供了AbstractRoutingDataSource 根据用户定义的规则选择当前的数据源，这样我们可以在执行查询之前，设置使用的数据源。实现可动态路由的数据源，在每次数据库查询操作前执行。它的抽象方法 determineCurrentLookupKey() 决定使用哪个数据源。</p>
</blockquote>
<p>AbstractRoutingDataSource 的部分源码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractRoutingDataSource</span> <span class="keyword">extends</span> <span class="title">AbstractDataSource</span> <span class="keyword">implements</span> <span class="title">InitializingBean</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 用来存储多个数据源</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;Object, Object&gt; targetDataSources;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 默认数据源</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">private</span> Object defaultTargetDataSource;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;Object, DataSource&gt; resolvedDataSources;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">private</span> DataSource resolvedDefaultDataSource;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AbstractRoutingDataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 设置多数据源，最终使用哪个数据源由determineTargetDataSource()返回决定</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTargetDataSources</span><span class="params">(Map&lt;Object, Object&gt; targetDataSources)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.targetDataSources = targetDataSources;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 设置默认数据源</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDefaultTargetDataSource</span><span class="params">(Object defaultTargetDataSource)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.defaultTargetDataSource = defaultTargetDataSource;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 决定使用的数据源，选择的策略需要我们自己去定义</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> DataSource <span class="title">determineTargetDataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Assert.notNull(<span class="keyword">this</span>.resolvedDataSources, <span class="string">&quot;DataSource router not initialized&quot;</span>);</span><br><span class="line">        <span class="comment">//调用determineCurrentLookupKey()获取数据源的key</span></span><br><span class="line">        Object lookupKey = <span class="keyword">this</span>.determineCurrentLookupKey();</span><br><span class="line">        <span class="comment">//根据key获取对应数据源</span></span><br><span class="line">        DataSource dataSource = (DataSource)<span class="keyword">this</span>.resolvedDataSources.get(lookupKey);</span><br><span class="line">        <span class="keyword">if</span> (dataSource == <span class="keyword">null</span> &amp;&amp; (<span class="keyword">this</span>.lenientFallback || lookupKey == <span class="keyword">null</span>)) &#123;</span><br><span class="line">            dataSource = <span class="keyword">this</span>.resolvedDefaultDataSource;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (dataSource == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Cannot determine target DataSource for lookup key [&quot;</span> + lookupKey + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> dataSource;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 抽象方法，需要我们自己去实现</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> Object <span class="title">determineCurrentLookupKey</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编写 <code>DynamicDataSource</code>继承 <code>AbstractRoutingDataSource</code>    </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.letfit.common;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicDataSource</span> <span class="keyword">extends</span> <span class="title">AbstractRoutingDataSource</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回当前线程正在使用代表数据库的枚举对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">determineCurrentLookupKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> DynamicDbUtil.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>流程步骤：</p>
<p>1、重写数据源选择策略determineCurrentLookupKey()。</p>
<p>2、数据源配置类将数据源存放在AbstractRoutingDataSource的 targetDataSources和defaultTargetDataSource中，然后通过afterPropertiesSet()方法将数据源分别进行复制到resolvedDataSources和resolvedDefaultDataSource中。</p>
<p>3、进行数据库连接时，调用AbstractRoutingDataSource的getConnection()的方法，此时会先调用determineTargetDataSource()方法返回DataSource再进行getConnection()。</p>
<br>

<h4 id="编写多数据源配置类"><a href="#编写多数据源配置类" class="headerlink" title="编写多数据源配置类"></a>编写多数据源配置类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.letfit.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.druid.spring.boot.autoconfigure.DruidDataSourceBuilder;</span><br><span class="line"><span class="keyword">import</span> com.letfit.common.DBTypeEnum;</span><br><span class="line"><span class="keyword">import</span> com.letfit.common.DynamicDataSource;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Qualifier;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.context.properties.ConfigurationProperties;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Primary;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.sql.DataSource;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DataSourceConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 主数据库数据源，存入Spring容器</span></span><br><span class="line"><span class="comment">     * 注解<span class="doctag">@Primary</span>表示主数据源</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ConfigurationProperties(prefix = &quot;spring.datasource.master&quot;)</span></span><br><span class="line">    <span class="meta">@Primary</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">masterDataSource</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> DruidDataSourceBuilder.create().build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从数据库数据源，存入Spring容器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ConfigurationProperties(prefix = &quot;spring.datasource.slave&quot;)</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">slaveDataSource</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> DruidDataSourceBuilder.create().build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 决定最终数据源</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> masterDataSource</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> slaveDataSource</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">targetDataSource</span><span class="params">(<span class="meta">@Qualifier(&quot;masterDataSource&quot;)</span> DataSource masterDataSource, <span class="meta">@Qualifier(&quot;slaveDataSource&quot;)</span> DataSource slaveDataSource)</span></span>&#123;</span><br><span class="line">        <span class="comment">//存放主从数据源</span></span><br><span class="line">        Map&lt;Object,Object&gt; targetDataSource = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">2</span>);</span><br><span class="line">        <span class="comment">//主数据源</span></span><br><span class="line">        targetDataSource.put(DBTypeEnum.MASTER, masterDataSource);</span><br><span class="line">        <span class="comment">//从数据源</span></span><br><span class="line">        targetDataSource.put(DBTypeEnum.SLAVE, slaveDataSource);</span><br><span class="line">        <span class="comment">//实现动态切换</span></span><br><span class="line">        DynamicDataSource dynamicDataSource = <span class="keyword">new</span> DynamicDataSource();</span><br><span class="line">        <span class="comment">//绑定所有数据源</span></span><br><span class="line">        dynamicDataSource.setTargetDataSources(targetDataSource);</span><br><span class="line">        <span class="comment">//设置默认数据源</span></span><br><span class="line">        dynamicDataSource.setDefaultTargetDataSource(masterDataSource);</span><br><span class="line">        <span class="keyword">return</span> dynamicDataSource;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<h4 id="配置Mybatis"><a href="#配置Mybatis" class="headerlink" title="配置Mybatis"></a>配置Mybatis</h4><p>当我们只有一个数据源时，SpringBoot会默认配置Mybatis，现在我们有多个数据源，就需要手动配置Mybatis的SqlSessionFactory</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.letfit.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.session.SqlSessionFactory;</span><br><span class="line"><span class="keyword">import</span> org.mybatis.spring.SqlSessionFactoryBean;</span><br><span class="line"><span class="keyword">import</span> org.mybatis.spring.SqlSessionTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Qualifier;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.io.support.PathMatchingResourcePatternResolver;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.datasource.DataSourceTransactionManager;</span><br><span class="line"><span class="keyword">import</span> org.springframework.transaction.PlatformTransactionManager;</span><br><span class="line"><span class="keyword">import</span> org.springframework.transaction.annotation.EnableTransactionManagement;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.Resource;</span><br><span class="line"><span class="keyword">import</span> javax.sql.DataSource;</span><br><span class="line"><span class="keyword">import</span> java.util.Objects;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 多数据源需要手动配置SqlSessionFactory</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableTransactionManagement</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MybatisConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource(name = &quot;targetDataSource&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> DataSource dataSource;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 配置SqlSessionFactory</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SqlSessionFactory <span class="title">sqlSessionFactory</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        SqlSessionFactoryBean factoryBean = <span class="keyword">new</span> SqlSessionFactoryBean();</span><br><span class="line">        factoryBean.setDataSource(dataSource);</span><br><span class="line">        <span class="comment">//配置映射文件路径</span></span><br><span class="line">        factoryBean.setMapperLocations(<span class="keyword">new</span> PathMatchingResourcePatternResolver().getResources(<span class="string">&quot;classpath:mapper/*.xml&quot;</span>));</span><br><span class="line">        <span class="comment">//配置别名</span></span><br><span class="line">        factoryBean.setTypeAliasesPackage(<span class="string">&quot;com.letfit.pojo&quot;</span>);</span><br><span class="line">        <span class="comment">//设置驼峰命名</span></span><br><span class="line">        Objects.requireNonNull(factoryBean.getObject()).getConfiguration().setMapUnderscoreToCamelCase(<span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">return</span> factoryBean.getObject();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 配置事务管理</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> PlatformTransactionManager <span class="title">transactionManager</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DataSourceTransactionManager(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SqlSessionTemplate <span class="title">sqlSessionTemplate</span><span class="params">(<span class="meta">@Qualifier(&quot;sqlSessionFactory&quot;)</span> SqlSessionFactory sqlSessionFactory)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SqlSessionTemplate(sqlSessionFactory);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<h4 id="配置Aop"><a href="#配置Aop" class="headerlink" title="配置Aop"></a>配置Aop</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.letfit.aop;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DataSourceAop</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Pointcut(&quot;@annotation(com.letfit.aop.annotation.ReadOnly)&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readPointcut</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 配置前置通知，切换数据源为从数据库</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Before(&quot;readPointcut()&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readAdvise</span><span class="params">()</span></span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;切换数据源为从数据库&quot;</span>);</span><br><span class="line">        DynamicDbUtil.slave();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<h4 id="业务层方法上使用-ReadOnly-注解"><a href="#业务层方法上使用-ReadOnly-注解" class="headerlink" title="业务层方法上使用 ReadOnly 注解"></a>业务层方法上使用 <code>ReadOnly</code> 注解</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据标题关键字模糊查询资源</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> title</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@ReadOnly</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> ResultInfo&lt;List&lt;Source&gt;&gt; searchSource(String title) &#123;</span><br><span class="line">    <span class="keyword">if</span>(!ValiDateUtil.isLegalString(title))&#123;</span><br><span class="line">        <span class="keyword">return</span> ResultInfo.error(CodeEnum.PARAM_NOT_IDEAL, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;Source&gt; sourceList = sourceMapper.searchSource(title);</span><br><span class="line">    <span class="keyword">return</span> ResultInfo.success(CodeEnum.SUCCESS, sourceList);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><img src="https://gitee.com/KIMTOU/img/raw/master/20210528134946.png" alt="从数据源"></p>
<ul>
<li>至此，读写分离的工作就完成了！</li>
</ul>
]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>SpingBoot</tag>
        <tag>MySQL</tag>
        <tag>环境配置</tag>
      </tags>
  </entry>
  <entry>
    <title>写在开头</title>
    <url>/2021/04/29/%E5%86%99%E5%9C%A8%E5%BC%80%E5%A4%B4/</url>
    <content><![CDATA[<h4 id="关于我"><a href="#关于我" class="headerlink" title="关于我"></a>关于我</h4><p>本人目前是软件工程专业的一名在读本科生，主要方向是java后台开发。平时也喜欢打篮球与听音乐，欢迎小伙伴与我交流，我的个人邮箱：<a href="mailto:&#x37;&#x35;&#x32;&#x31;&#54;&#x30;&#x36;&#x35;&#53;&#x40;&#113;&#113;&#x2e;&#x63;&#111;&#109;">&#x37;&#x35;&#x32;&#x31;&#54;&#x30;&#x36;&#x35;&#53;&#x40;&#113;&#113;&#x2e;&#x63;&#111;&#109;</a></p>
]]></content>
      <categories>
        <category>感想</category>
      </categories>
      <tags>
        <tag>感想</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指 Offer 06.从尾到头打印链表</title>
    <url>/2021/05/24/%E5%89%91%E6%8C%87-Offer-06-%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><strong>输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）</strong></p>
<p>示例 1：</p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">输入：head = <span class="comment">[1,3,2]</span></span><br><span class="line">输出：<span class="comment">[2,3,1]</span></span><br></pre></td></tr></table></figure>


<p>限制：</p>
<p><code>0 &lt;= 链表长度 &lt;= 10000</code></p>
<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><h4 id="方式一：递归法"><a href="#方式一：递归法" class="headerlink" title="方式一：递归法"></a>方式一：递归法</h4><p>解题思路：递归到链表尾端，在回溯时存入数组。</p>
<p>算法实现：</p>
<ul>
<li>变量：先创建一个result数组，用size变量记录当前数组的下标索引，node为当前链表结点。</li>
<li>递归结束条件：当链表结点为null，node==null。</li>
<li>结果：result即为逆序排列链表数值后的数组，根据size对数组做截断并返回即可。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10000</span>];</span><br><span class="line">    <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] reversePrint(ListNode head) &#123;</span><br><span class="line">        recurGet(head);</span><br><span class="line">        <span class="keyword">return</span> Arrays.copyOfRange(result,<span class="number">0</span>,size);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recurGet</span><span class="params">(ListNode node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        recurGet(node.next);</span><br><span class="line">        result[size++] = node.val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>复杂度分析：</p>
<ul>
<li>时间复杂度O(N)：遍历整个链表</li>
<li>空间复杂度：本解法创建了一个大小为链表长度最大值的数组，结果对其做截断处理，故空间大小即为链表长度最大值；也可以使用集合代替数组，则空间复杂度为O(N)</li>
</ul>
<h4 id="方法二：栈"><a href="#方法二：栈" class="headerlink" title="方法二：栈"></a>方法二：栈</h4><p>解题思路：由于栈具有先进后出的特点，故可用来将链表倒置。</p>
<p>算法实现：创建一个栈，顺序遍历链表便依次将结点值push入栈。最后根据栈的大小创建数组result，遍历栈赋值给数组。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] reversePrint(ListNode head) &#123;</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack();</span><br><span class="line">        <span class="keyword">while</span>(head != <span class="keyword">null</span>)&#123;</span><br><span class="line">            stack.push(head.val);</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[stack.size()];</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">            result[i++] = stack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>复杂度分析：</p>
<ul>
<li>时间复杂度O(N): 先遍历链表给栈赋值（入栈），再遍历栈给数组赋值（出栈）</li>
<li>空间复杂度O(N): 栈与数组的大小均与链表长度有关</li>
</ul>
<h4 id="方法三：使用两个数组模拟栈"><a href="#方法三：使用两个数组模拟栈" class="headerlink" title="方法三：使用两个数组模拟栈"></a>方法三：使用两个数组模拟栈</h4><p>解题思路：遍历链表给第1个数组赋值，再将第1个数组逆序赋值给第2个数组</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] reversePrint(ListNode head) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] node = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10000</span>];</span><br><span class="line">        <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(head!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            node[size++] = head.val;</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[size--];</span><br><span class="line">        <span class="keyword">while</span>(size&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            result[i++] = node[size--];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>基于docker实现MySQL主从复制</title>
    <url>/2021/05/27/%E5%9F%BA%E4%BA%8Edocker%E5%AE%9E%E7%8E%B0MySQL%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/</url>
    <content><![CDATA[<h2 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h2><h4 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h4><p>主从复制是MySQL提供的一种高可用高性能的解决方案。</p>
<p>工作原理分为以下3个步骤：</p>
<p>1、主库（master）把数据更改记录到<strong>二进制日志（binlog）</strong>中。</p>
<p>2、从库（slave）的<strong>I/O线程</strong>把主库的二进制日志读取保存到自己的<strong>中继日志（relay log）</strong>中。</p>
<p>3、从库的<strong>SQL线程</strong>执行中继日志，重做中继日志中的日志，即再执行一遍SQL，更新自己的数据库，以达到数据的一致性。</p>
<p><img src="https://gitee.com/KIMTOU/img/raw/master/20210528000926.png" alt="主从复制"></p>
<p>注意要点：</p>
<p>主从复制不是完全实时地进行同步，而是<strong>异步实时</strong>。从库同步主库数据的过程是串行化的，也就是说主库上并行的操作，在从库上会串行执行。由于从库从主库拷贝日志以及串行执行 SQL 的特点，会有<strong>主从同步时延</strong>，在高并发的情况下，该问题就越明显。</p>
<br>

<h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><p>使用主从复制能够预防MySQ的单点故障，对数据进行备份。</p>
<p>在高并发下，需要对应用进行读写分离，配置多数据源，即写操作走主库，读操作则走从库，以减少锁的争用，此时也需要进行主从复制。</p>
<br>

<h4 id="部署数据库实例"><a href="#部署数据库实例" class="headerlink" title="部署数据库实例"></a>部署数据库实例</h4><p>1、拉取镜像</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker pull mysql:5.7</span><br></pre></td></tr></table></figure>

<p>2、运行容器</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 主库（端口3306）</span></span><br><span class="line">docker run -d -p 3306:3306 -e MYSQL_ROOT_PASSWORD=123456 --name master_mysql mysql:5.7</span><br><span class="line"><span class="meta">#</span><span class="bash"> 从库（端口3307）</span></span><br><span class="line">docker run -d -p 3307:3306 -e MYSQL_ROOT_PASSWORD=123456 --name slave_mysql mysql:5.7</span><br></pre></td></tr></table></figure>

<p>3、查看状态</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker ps	#查看是否运行成功</span><br></pre></td></tr></table></figure>

<p>4、使用Navicat等数据库管理工具进行连接</p>
<br>

<h4 id="主从复制配置"><a href="#主从复制配置" class="headerlink" title="主从复制配置"></a>主从复制配置</h4><p><strong>一、配置主库</strong></p>
<ul>
<li>进入容器修改配置文件</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker exec -it master_mysql /bin/bash</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">由于容器内没有vim工具，需进行安装</span></span><br><span class="line">apt-get update</span><br><span class="line">apt-get install vim</span><br><span class="line"></span><br><span class="line">vim /etc/mysql/my.cnf</span><br></pre></td></tr></table></figure>

<ul>
<li>在 my.cnf 配置文件中添加如下代码</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">server-id=10</span><br><span class="line">log-bin=mysql-bin</span><br><span class="line">innodb_flush_log_at_trx_commit=1</span><br><span class="line">sync_binlog=1</span><br></pre></td></tr></table></figure>

<img src="https://gitee.com/KIMTOU/img/raw/master/20210528000934.PNG" alt="mycnf" style="zoom: 67%;" />



<ul>
<li>进入<strong>主库</strong>为<strong>从库</strong>创建一个用户用来复制数据，从库通过这个用户连接至主库</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 登录mysql</span></span><br><span class="line">mysql -u root -p</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 创建用户</span></span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> CREATE user <span class="string">&#x27;slave&#x27;</span>@<span class="string">&#x27;%&#x27;</span> identified by <span class="string">&#x27;slave&#x27;</span>;</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 赋予权限</span></span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> GRANT REPLICATION SLAVE, REPLICATION CLIENT ON *.* TO <span class="string">&#x27;slave&#x27;</span>@<span class="string">&#x27;%&#x27;</span>;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>查看主库状态</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> show master status;</span></span><br><span class="line">+------------------+----------+--------------+------------------+-------------------+</span><br><span class="line">| File             | Position | Binlog_Do_DB | Binlog_Ignore_DB | Executed_Gtid_Set |</span><br><span class="line">+------------------+----------+--------------+------------------+-------------------+</span><br><span class="line">| mysql-bin.000001 |     617  |              |                  |                   |</span><br><span class="line">+------------------+----------+--------------+------------------+-------------------+</span><br></pre></td></tr></table></figure>

<ul>
<li>重启生效</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker restart master_mysql</span><br></pre></td></tr></table></figure>



<p><strong>二、从库配置</strong></p>
<ul>
<li>同样的进入容器修改配置文件</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker exec -it slave_mysql /bin/bash</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">由于容器内没有vim工具，需进行安装</span></span><br><span class="line">apt-get update</span><br><span class="line">apt-get install vim</span><br><span class="line"></span><br><span class="line">vim /etc/mysql/my.cnf</span><br></pre></td></tr></table></figure>

<ul>
<li>在 my.cnf 配置文件中添加如下代码</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">server_id=11</span><br><span class="line">log-bin=mysql-slave-bin</span><br><span class="line">relay_log=edu-mysql-relay-bin</span><br></pre></td></tr></table></figure>

<ul>
<li>重启生效</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker restart slave_mysql</span><br></pre></td></tr></table></figure>



<p><strong>三、绑定主库</strong></p>
<ul>
<li>docker查看主mysql容器的ip</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker inspect --format=&#x27;&#123;&#123;.NetworkSettings.IPAddress&#125;&#125;&#x27; master_mysql</span><br></pre></td></tr></table></figure>

<ul>
<li>进入从库</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker exec -it slave_mysql /bin/bash</span><br><span class="line">mysql -u root -p</span><br></pre></td></tr></table></figure>

<ul>
<li>绑定主库</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> change master to master_host=<span class="string">&#x27;172.17.0.2&#x27;</span>, master_user=<span class="string">&#x27;slave&#x27;</span>, master_password=<span class="string">&#x27;slave&#x27;</span>, master_port=3306, master_log_file=<span class="string">&#x27;mysql-bin.000001&#x27;</span>, master_log_pos=617, master_connect_retry=30;</span></span><br></pre></td></tr></table></figure>

<p>这里的<strong>master_host</strong>为刚刚查到的<strong>主mysql容器的ip</strong>，是容器独立的ip </p>
<ul>
<li>查看从库的状态</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">show slave status \G;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 发现IO线程和SQL线程运行状态都为No，默认是没有开启，需要手动开启</span></span><br><span class="line">Slave_IO_Running: No</span><br><span class="line">Slave_SQL_Running: No</span><br></pre></td></tr></table></figure>

<ul>
<li>开启主从复制</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">start slave;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指 Offer 31.栈的压入、弹出序列</title>
    <url>/2021/09/12/%E5%89%91%E6%8C%87-Offer-31-%E6%A0%88%E7%9A%84%E5%8E%8B%E5%85%A5%E3%80%81%E5%BC%B9%E5%87%BA%E5%BA%8F%E5%88%97/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><strong>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如，序列 {1,2,3,4,5} 是某栈的压栈序列，序列 {4,5,3,2,1} 是该压栈序列对应的一个弹出序列，但 {4,3,5,1,2} 就不可能是该压栈序列的弹出序列。</strong></p>
<p>示例 1：</p>
<figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line">输入：pushed = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>], popped = [<span class="number">4</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">输出：<span class="literal">true</span></span><br><span class="line">解释：我们可以按以下顺序执行：</span><br><span class="line">push<span class="function"><span class="params">(<span class="number">1</span>)</span>, <span class="title">push</span><span class="params">(<span class="number">2</span>)</span>, <span class="title">push</span><span class="params">(<span class="number">3</span>)</span>, <span class="title">push</span><span class="params">(<span class="number">4</span>)</span>, <span class="title">pop</span><span class="params">()</span> -&gt;</span> <span class="number">4</span>,</span><br><span class="line">push<span class="function"><span class="params">(<span class="number">5</span>)</span>, <span class="title">pop</span><span class="params">()</span> -&gt;</span> <span class="number">5</span>, pop<span class="function"><span class="params">()</span> -&gt;</span> <span class="number">3</span>, pop<span class="function"><span class="params">()</span> -&gt;</span> <span class="number">2</span>, pop<span class="function"><span class="params">()</span> -&gt;</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>示例 2：</p>
<figure class="highlight nix"><table><tr><td class="code"><pre><span class="line">输入：<span class="attr">pushed</span> = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>], <span class="attr">popped</span> = [<span class="number">4</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">输出：<span class="literal">false</span></span><br><span class="line">解释：<span class="number">1</span> 不能在 <span class="number">2</span> 之前弹出。</span><br></pre></td></tr></table></figure>


<p>提示：</p>
<ol>
<li>0 &lt;= pushed.length == popped.length &lt;= 1000</li>
<li>0 &lt;= pushed[i], popped[i] &lt; 1000</li>
<li>pushed 是 popped 的排列。</li>
</ol>
<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><h3 id="利用数组模拟栈"><a href="#利用数组模拟栈" class="headerlink" title="利用数组模拟栈"></a>利用数组模拟栈</h3><h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>既然题目给我们的压入、弹出序列是数组，那么我们创建一个数组来模拟一个栈，作为中间的一个辅助栈，其长度最大不会超过pushed压入序列的长度。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] stack = <span class="keyword">new</span> <span class="keyword">int</span>[pushed.length];</span><br></pre></td></tr></table></figure>

<p><strong>算法实现：</strong></p>
<p>1、遍历压入序列<code>pushed</code>的元素，并将其压入辅助栈<code>stack</code>。若遍历完压入序列<code>pushed</code>，则进行步骤三。</p>
<p>2、辅助栈每压入一个元素，就去循环判断自己的栈顶元素与<code>popped</code>序列的栈顶元素是否相同。相同则一起弹出该元素并指针下移，继续判断下一栈顶元素是否相同；若不相同，则回到步骤一。</p>
<p>3、检查辅助栈是否为空，若辅助栈不为空，则popped序列不是弹出序列。</p>
<p><strong>关于循环条件的说明：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (stackIndex &gt;= <span class="number">0</span> &amp;&amp; popIndex &lt; popped.length &amp;&amp;</span><br><span class="line">                                 stack[stackIndex] == popped[popIndex])</span><br></pre></td></tr></table></figure>

<p>由于题目说明指出压入序列与弹出序列长度相同（<code>0 &lt;= pushed.length == popped.length &lt;= 1000</code>），且stack数组在当前循环中的长度小于等于pushed压入序列，故可知stack数组在当前循环中的长度必然小于等于poped弹出序列长度，因此我们便可把循环条件简化为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (stackIndex &gt;= <span class="number">0</span> &amp;&amp; stack[stackIndex] == popped[popIndex])</span><br></pre></td></tr></table></figure>

<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">validateStackSequences</span><span class="params">(<span class="keyword">int</span>[] pushed, <span class="keyword">int</span>[] popped)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pushIndex = <span class="number">0</span>, popIndex = <span class="number">0</span>, stackIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] stack = <span class="keyword">new</span> <span class="keyword">int</span>[pushed.length];</span><br><span class="line">        <span class="keyword">while</span> (pushIndex &lt; pushed.length)&#123;</span><br><span class="line">            stack[stackIndex] = pushed[pushIndex++];</span><br><span class="line">            <span class="keyword">while</span> (stackIndex &gt;= <span class="number">0</span> &amp;&amp; stack[stackIndex] == popped[popIndex])&#123;</span><br><span class="line">                stackIndex--;</span><br><span class="line">                popIndex++;</span><br><span class="line">            &#125;</span><br><span class="line">            stackIndex++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stackIndex == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度O(N)：N为<code>pushed</code>压入序列的元素个数，每个元素最多入栈、出栈一次，即最多2N次出入栈操作</li>
<li>空间复杂度O(N)：创建模拟栈stack，最多同时存储N个元素</li>
</ul>
<h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">validateStackSequences</span><span class="params">(<span class="keyword">int</span>[] pushed, <span class="keyword">int</span>[] popped)</span> </span>&#123;</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : pushed)&#123;</span><br><span class="line">            stack.push(num);</span><br><span class="line">            <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; stack.peek() == popped[i])&#123;</span><br><span class="line">                stack.pop();</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<ul>
<li>题目链接：<a href="https://leetcode-cn.com/problems/zhan-de-ya-ru-dan-chu-xu-lie-lcof/">剑指 Offer 31. 栈的压入、弹出序列 - 力扣（LeetCode） (leetcode-cn.com)</a></li>
<li>题解链接：<a href="https://leetcode-cn.com/problems/zhan-de-ya-ru-dan-chu-xu-lie-lcof/solution/zhi-xing-yong-shi-0-ms-li-yong-shu-zu-mo-1vwk/">执行用时: 0 ms 利用数组模拟栈（剑指31.栈的压入、弹出序列） - 栈的压入、弹出序列 - 力扣（LeetCode） (leetcode-cn.com)</a></li>
</ul>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>RocketMQ底层设计与原理</title>
    <url>/2021/09/13/RocketMQ%E5%BA%95%E5%B1%82%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h2 id="RocketMQ的消息模型"><a href="#RocketMQ的消息模型" class="headerlink" title="RocketMQ的消息模型"></a>RocketMQ的消息模型</h2><h4 id="消息模型-Message-Model"><a href="#消息模型-Message-Model" class="headerlink" title="消息模型 Message Model"></a>消息模型 Message Model</h4><p>RocketMQ主要由 Producer、Broker、Consumer 三部分组成，其中Producer 负责生产消息，Consumer 负责消费消息，Broker 负责存储消息。Broker 在实际部署过程中对应一台服务器，<strong>每个 Broker 可以存储多个Topic的消息，每个Topic的消息也可以分片存储于不同的 Broker。</strong>Message Queue 用于存储消息的物理地址，每个Topic中的消息地址存储于多个 Message Queue 中。ConsumerGroup 由多个Consumer 实例构成。</p>
<h4 id="消息-Message"><a href="#消息-Message" class="headerlink" title="消息 Message"></a>消息 Message</h4><p><strong>消息系统所传输信息的物理载体，生产和消费数据的最小单位</strong>，每条消息必须属于一个主题。RocketMQ中每个消息拥有唯一的Message ID，且可以携带具有业务标识的Key。系统提供了通过Message ID和Key查询消息的功能。</p>
<h4 id="主题-Topic"><a href="#主题-Topic" class="headerlink" title="主题 Topic"></a>主题 Topic</h4><p><strong>表示一类消息的集合</strong>，每个主题包含若干条消息，每条消息只能属于一个主题，是RocketMQ进行消息订阅的基本单位。</p>
<blockquote>
<p><strong>Topic</strong> 与生产者和消费者的关系非常松散，一个 Topic 可以有0个、1个、多个生产者向其发送消息，一个生产者也可以同时向不同的 Topic 发送消息。</p>
<p>一个 Topic 也可以被 0个、1个、多个消费者订阅。</p>
</blockquote>
<h4 id="标签-Tag"><a href="#标签-Tag" class="headerlink" title="标签 Tag"></a>标签 Tag</h4><p><strong>为消息设置的标志，用于同一主题下区分不同类型的消息</strong>。来自同一业务单元的消息，可以根据不同业务目的在同一主题下设置不同标签。标签能够有效地保持代码的清晰度和连贯性，并优化RocketMQ提供的查询系统。消费者可以根据Tag实现对不同子主题的不同消费逻辑，实现更好的扩展性。</p>
<h4 id="分组-Group"><a href="#分组-Group" class="headerlink" title="分组 Group"></a>分组 Group</h4><p>分为ProducerGroup，ConsumerGroup，代表某一类的生产者和消费者，一个组可以订阅多个Topic。</p>
<p><strong>ProducerGroup</strong>代表同一类Producer的集合，这类Producer发送同一类消息且发送逻辑一致。如果发送的是事务消息且原始生产者在发送之后崩溃，则Broker服务器会联系同一生产者组的其他生产者实例以提交或回溯消费。</p>
<p><strong>ConsumerGroup</strong>代表同一类Consumer的集合，这类Consumer通常消费同一类消息且消费逻辑一致。消费者组使得在消息消费方面，实现负载均衡和容错的目标变得非常容易。要注意的是，消费者组的消费者实例必须订阅完全相同的Topic。RocketMQ 支持两种消息模式：集群消费（Clustering）和广播消费（Broadcasting）。</p>
<h4 id="队列-Queue"><a href="#队列-Queue" class="headerlink" title="队列 Queue"></a>队列 Queue</h4><p>在<strong>Kafka</strong>中叫Partition，每个Queue内部是有序的，在<strong>RocketMQ</strong>中分为读和写两种队列，一般来说读写队列数量一致，如果不一致就会出现很多问题。</p>
<h4 id="消费位移-Offset"><a href="#消费位移-Offset" class="headerlink" title="消费位移 Offset"></a>消费位移 Offset</h4><p>在RocketMQ 中，所有消息队列都是持久化，长度无限的数据结构，所谓长度无限是指队列中的每个存储单元都是定长，访问其中的存储单元使用Offset 来访问，Offset 为 java long 类型，64 位，理论上在 100年内不会溢出，所以认为是长度无限。也可以认为 Message Queue 是一个长度无限的数组，Offset 就是下标。</p>
<p><img src="https://gitee.com/KIMTOU/img/raw/master/20210913210810.png" alt="消息模型"></p>
<p><strong>一个主题存在多个队列</strong>，生产者每次生产消息后向指定主题中的某个队列发送消息。在集群消费模式下，一个消费者集群的多个消费者共同消费一个<code>Topic</code>的多个队列，<strong>一个队列只会被一个消费者消费</strong>，如果某个消费者挂掉，分组内其它消费者会接替挂掉的消费者继续消费。一般来讲要控制<strong>消费者组中的消费者个数和主题中队列个数相同</strong> ，当然也可以消费者个数小于队列个数，只不过不太建议。</p>
<p><strong>同时每个消费者组在每个队列上维护一个消费位移offset</strong></p>
<blockquote>
<p>在发布订阅模式中一般会涉及到多个消费者组，而<strong>每个消费者组在每个队列中的消费位置都是不同的</strong>。如果此时有多个消费者组，那么消息被一个消费者组消费完之后是不会删除的（因为一个Topic可以被多个消费者订阅，那么其它消费者组也需要呀），它仅仅是为每个消费者组维护一个 <strong>消费位移(offset)</strong> ，每次消费者组消费完会返回一个成功的响应，然后队列再把维护的消费位移加一，这样就不会出现刚刚消费过的消息再一次被消费了。</p>
</blockquote>
<br>

<h2 id="为什么一个主题中需要维护多个队列"><a href="#为什么一个主题中需要维护多个队列" class="headerlink" title="为什么一个主题中需要维护多个队列"></a>为什么一个主题中需要维护多个队列</h2><ul>
<li><strong>提高并发能力</strong></li>
</ul>
<p>可以从生产者、消费者两个方面来解释。倘如一个主题Topic只有一个队列，这样生产者只能向一个队列发送消息，并且由于一个队列只能对应消费者组中的一个消费者（因为需要维护消费位移），这样该消费者组中的其他消费者便失去用武之地。</p>
<blockquote>
<p><code>RocketMQ</code> 通过<strong>使用在一个 <code>Topic</code> 中配置多个队列并且每个队列维护每个消费者组的消费位置</strong> 实现了 <strong>主题模式/发布订阅模式</strong></p>
</blockquote>
<br>

<h2 id="如何解决消息重复问题"><a href="#如何解决消息重复问题" class="headerlink" title="如何解决消息重复问题"></a>如何解决消息重复问题</h2><p><strong>首先分析引起重复消费的原因：</strong></p>
<p><strong>1、ACK （网络因素）</strong></p>
<p>正常情况下在consumer真正消费完消息后应该发送ack，通知broker该消息已正常消费。<strong>当ack因为网络原因无法发送到broker，broker会认为此条消息没有被消费</strong>，此后会开启消息重投机制把消息再次投递到consumer。</p>
<p><strong>2、消费模式</strong></p>
<p>在CLUSTERING集群消费模式下，消息在broker中会保证相同group的consumer消费一次，但是针对不同group的consumer会推送多次。</p>
<h4 id="消息去重"><a href="#消息去重" class="headerlink" title="消息去重"></a>消息去重</h4><p><strong>去重原则：使用业务端逻辑保持幂等性</strong></p>
<p><strong>幂等性</strong>：就是用户对于同一操作发起的一次请求或者多次请求的结果是一致的，不会因为多次点击而产生了副作用，数据库的结果都是唯一的，不可变的。</p>
<p>只要保持幂等性，不管来多少条重复消息，最后处理的结果都一样。</p>
<p>RocketMQ无法避免消息重复（Exactly-Once），所以如果业务对消费重复非常敏感，务必要在业务层面进行去重处理。可以借助关系数据库进行去重。首先需要确定消息的唯一键，可以是msgId，也可以是消息内容中的唯一标识字段，例如订单Id等。在消费之前判断唯一键是否在关系数据库中存在。如果不存在则插入，并消费，否则跳过。（实际过程要考虑原子性问题，判断是否存在可以尝试插入，如果报主键冲突，则插入失败，直接跳过）</p>
<p>msgId一定是全局唯一标识符，但是实际使用中，可能会存在相同的消息有两个不同msgId的情况（消费者主动重发、因客户端重投机制导致的重复等），这种情况就需要使业务字段进行重复消费。</p>
<br>

<h2 id="如何保证消息的顺序消费"><a href="#如何保证消息的顺序消费" class="headerlink" title="如何保证消息的顺序消费"></a>如何保证消息的顺序消费</h2><p>首先Topic内的queue队列满足FIFO先进先出原则，本身就是顺序的，但多个queue同时消费并无法保证消息有序。那么此时我们只要保证将一类消息（如一个订单的创建、支付、完成）固定发送至同一queue队列即可。</p>
<h4 id="那么如何保证消息发送至同一queue"><a href="#那么如何保证消息发送至同一queue" class="headerlink" title="那么如何保证消息发送至同一queue"></a>那么如何保证消息发送至同一queue</h4><p><strong>RocketMQ提供了MessageQueueSelector接口，可以重写接口的select方法，定义自己的选择策略。</strong></p>
<p><strong>比如使用Hash取模法</strong>，让同一个订单发送到同一个队列中，再使用同步发送，只有同个订单的创建消息发送成功，再发送支付消息，这样我们保证了发送有序。</p>
<ul>
<li>Producer端</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="comment">// 加个时间前缀</span></span><br><span class="line">    String body = dateStr + <span class="string">&quot; Hello RocketMQ &quot;</span> + orderList.get(i);</span><br><span class="line">    Message msg = <span class="keyword">new</span> Message(<span class="string">&quot;TopicTest&quot;</span>, tags[i % tags.length], <span class="string">&quot;KEY&quot;</span> + i, body.getBytes());</span><br><span class="line"></span><br><span class="line">    SendResult sendResult = producer.send(msg, <span class="keyword">new</span> MessageQueueSelector() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> MessageQueue <span class="title">select</span><span class="params">(List&lt;MessageQueue&gt; mqs, Message msg, Object arg)</span> </span>&#123;</span><br><span class="line">            Long id = (Long) arg;  <span class="comment">//根据订单id选择发送queue</span></span><br><span class="line">            <span class="keyword">long</span> index = id % mqs.size();</span><br><span class="line">            <span class="keyword">return</span> mqs.get((<span class="keyword">int</span>) index);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, orderList.get(i).getOrderId());<span class="comment">//订单id</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Consume端</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">consumer.registerMessageListener(<span class="keyword">new</span> MessageListenerOrderly() &#123;</span><br><span class="line"></span><br><span class="line">    Random random = <span class="keyword">new</span> Random();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ConsumeOrderlyStatus <span class="title">consumeMessage</span><span class="params">(List&lt;MessageExt&gt; msgs, ConsumeOrderlyContext context)</span> </span>&#123;</span><br><span class="line">        context.setAutoCommit(<span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">for</span> (MessageExt msg : msgs) &#123;</span><br><span class="line">            <span class="comment">// 可以看到每个queue有唯一的consume线程来消费, 订单对每个queue(分区)有序</span></span><br><span class="line">            System.out.println(<span class="string">&quot;consumeThread=&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;queueId=&quot;</span> + msg.getQueueId() + <span class="string">&quot;, content:&quot;</span> + <span class="keyword">new</span> String(msg.getBody()));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//模拟业务逻辑处理中...</span></span><br><span class="line">            TimeUnit.SECONDS.sleep(random.nextInt(<span class="number">10</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ConsumeOrderlyStatus.SUCCESS;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<br>

<h2 id="RocketMQ如何保证消息不丢失"><a href="#RocketMQ如何保证消息不丢失" class="headerlink" title="RocketMQ如何保证消息不丢失"></a>RocketMQ如何保证消息不丢失</h2><p>首先在如下三个部分都可能会出现丢失消息的情况：</p>
<ul>
<li>Producer端</li>
<li>Broker端</li>
<li>Consumer端</li>
</ul>
<h4 id="Producer端如何保证消息不丢失"><a href="#Producer端如何保证消息不丢失" class="headerlink" title="Producer端如何保证消息不丢失"></a>Producer端如何保证消息不丢失</h4><ul>
<li>采取send()同步发消息，发送结果是同步感知的。</li>
<li>发送失败后可以重试，设置重试次数。默认2次。</li>
</ul>
<blockquote>
<p>producer.setRetryTimesWhenSendFailed(10);</p>
</blockquote>
<ul>
<li>集群部署，比如发送失败了的原因可能是当前Broker宕机了，重试的时候会发送到其他Broker上。</li>
</ul>
<h4 id="Broker端如何保证消息不丢失"><a href="#Broker端如何保证消息不丢失" class="headerlink" title="Broker端如何保证消息不丢失"></a>Broker端如何保证消息不丢失</h4><ul>
<li>修改刷盘策略为同步刷盘。默认情况下是异步刷盘的。</li>
</ul>
<blockquote>
<p>flushDiskType = SYNC_FLUSH</p>
</blockquote>
<ul>
<li>集群部署，主从模式，高可用。</li>
</ul>
<h4 id="Consumer端如何保证消息不丢失"><a href="#Consumer端如何保证消息不丢失" class="headerlink" title="Consumer端如何保证消息不丢失"></a>Consumer端如何保证消息不丢失</h4><ul>
<li>完全消费正常后在进行手动ack确认。</li>
</ul>
<br>

<h2 id="消息刷盘机制"><a href="#消息刷盘机制" class="headerlink" title="消息刷盘机制"></a>消息刷盘机制</h2><blockquote>
<p><strong>Broker</strong> 在消息的存取时直接操作的是内存（内存映射文件），这可以提供系统的吞吐量，但是无法避免机器掉电时数据丢失，所以需要持久化到磁盘中。</p>
<p><strong>刷盘的最终实现都是使用NIO中的 MappedByteBuffer.force() 将映射区的数据写入到磁盘</strong></p>
</blockquote>
<p><strong>同步刷盘</strong>：在Broker把消息写到<strong>CommitLog</strong>映射区后，便进行持久化。只有在消息真正持久化至磁盘后RocketMQ的Broker端才会真正返回给Producer端一个成功的ACK响应。同步刷盘对MQ消息可靠性更好，但是性能上会有较大影响。</p>
<p><strong>异步刷盘</strong>：能够充分利用OS的PageCache的优势，只要消息写入PageCache即可将成功的ACK返回给Producer端。<strong>消息刷盘采用后台异步线程提交的方式进行，降低了读写延迟</strong>，提高了MQ的性能和吞吐量。</p>
<br>

<h2 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h2><blockquote>
<p>常见的分布式事务实现有 2PC(两阶段提交）、TCC 和事务消息(half 半消息机制)。每一种实现都有其特定的使用场景，但是也有各自的问题，<strong>都不是完美的解决方案</strong>。</p>
</blockquote>
<p> <code>RocketMQ</code> 使用 <strong>事务消息（half半消息）加上事务消息回查机制</strong> 来解决分布式事务问题的</p>
<h4 id="Half-Message-半消息"><a href="#Half-Message-半消息" class="headerlink" title="Half Message 半消息"></a>Half Message 半消息</h4><p><strong>是指暂不能被Consumer消费的消息</strong>。Producer 已经把消息成功发送到了 Broker 端，但此消息被标记为<code>暂不能投递</code>状态，处于该种状态下的消息称为半消息。需要 Producer对消息的<code>二次确认</code>后，Consumer才能去消费它。当broker收到此类消息后，会存储到RMQ_SYS_TRANS_HALF_TOPIC的消息消费队列中</p>
<h4 id="事务消息回查"><a href="#事务消息回查" class="headerlink" title="事务消息回查"></a>事务消息回查</h4><p>由于网络波动，生产者应用重启等原因。导致 Producer 端一直没有收到对 Half Message(半消息) 进行二次确认。<strong>这时Broker会开启一个定时任务，从Topic为RMQ_SYS_TRANS_HALF_TOPIC中拉取消息进行消费</strong>，主动向Producer消息发送者确认事务执行状态（提交、回滚、未知），根据事务状态来决定是提交或回滚消息。如果是未知，Broker会定时去回调在重新检查，如果超过回查次数（超时），默认回滚消息。</p>
<p><img src="https://gitee.com/KIMTOU/img/raw/master/20210921155621.png"></p>
<h4 id="事务消息流程"><a href="#事务消息流程" class="headerlink" title="事务消息流程"></a>事务消息流程</h4><p>分为两个流程：正常事务消息的发送及提交、事务消息的补偿流程。</p>
<p>1、事务消息发送及提交：</p>
<p>(1) 发送消息（half半消息）。</p>
<p>(2) 服务端响应消息写入结果。</p>
<p>(3) 根据发送结果执行本地事务（如果写入失败，此时half消息对业务不可见，本地逻辑不执行）。</p>
<p>(4) 根据本地事务状态执行Commit或者Rollback（Commit操作生成消息索引，消息对消费者可见）</p>
<p>2、补偿流程（回查）：</p>
<p>(1) 对没有Commit/Rollback的事务消息（pending状态的消息），从服务端发起一次“回查”</p>
<p>(2) Producer收到回查消息，检查回查消息对应的本地事务的状态</p>
<p>(3) 根据本地事务状态，重新Commit或者Rollback</p>
<p>其中，补偿阶段用于解决消息Commit或者Rollback发生超时或者失败的情况。</p>
<h4 id="事务消息在一阶段对用户不可见"><a href="#事务消息在一阶段对用户不可见" class="headerlink" title="事务消息在一阶段对用户不可见"></a>事务消息在一阶段对用户不可见</h4><p>事务消息相对普通消息最大的特点就是一阶段发送的消息对用户是不可见的。RocketMQ事务消息的做法是：<strong>如果消息是half消息，将备份原消息的主题与消息消费队列，然后改变主题为RMQ_SYS_TRANS_HALF_TOPIC。由于消费组未订阅该主题，故消费端无法消费half类型的消息</strong>，然后Broker会开启一个定时任务，从Topic为RMQ_SYS_TRANS_HALF_TOPIC中拉取消息进行消费，根据生产者组获取一个服务提供者<strong>发送回查事务状态请求</strong>，根据事务状态来决定是提交或回滚消息。若Commit，则恢复原消息的主题与队列，重新发送到Broker，消费端感知后消费。</p>
<hr>
<br>

<blockquote>
<p>参考资料</p>
</blockquote>
<p><a href="https://github.com/apache/rocketmq/blob/master/docs/cn">https://github.com/apache/rocketmq/blob/master/docs/cn</a></p>
<p><a href="https://blog.csdn.net/qq_35190492/article/details/103341634?ops_request_misc=%7B%22request_id%22:%22162972269016780271584378%22,%22scm%22:%2220140713.130102334.pc_blog.%22%7D&request_id=162972269016780271584378&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_v2~rank_v29-1-103341634.pc_v2_rank_blog_default&utm_term=rocket&spm=1018.2226.3001.4450">看完保送阿里的RocketMQ知识点（超详细）_敖丙-CSDN博客</a></p>
<p><a href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/system-design/distributed-system/message-queue/RocketMQ.md">JavaGuide/RocketMQ.md at master · Snailclimb/JavaGuide (github.com)</a></p>
<p><a href="https://mp.weixin.qq.com/s/vxHzNs23-P4BvYvyME6_nQ">RocketMQ在面试中那些常见问题及答案 (qq.com)</a></p>
]]></content>
      <categories>
        <category>消息队列</category>
      </categories>
      <tags>
        <tag>消息队列</tag>
      </tags>
  </entry>
  <entry>
    <title>RocketMQ实战与最佳实践</title>
    <url>/2021/09/21/RocketMQ%E5%AE%9E%E6%88%98%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/</url>
    <content><![CDATA[<h2 id="实战应用"><a href="#实战应用" class="headerlink" title="实战应用"></a>实战应用</h2><p>maven依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.rocketmq<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>rocketmq-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.9.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h3 id="普通消息"><a href="#普通消息" class="headerlink" title="普通消息"></a>普通消息</h3><h4 id="消息发送"><a href="#消息发送" class="headerlink" title="消息发送"></a>消息发送</h4><h5 id="1、Producer端发送同步消息"><a href="#1、Producer端发送同步消息" class="headerlink" title="1、Producer端发送同步消息"></a><strong>1、Producer端发送同步消息</strong></h5><p>这种可靠性同步地发送方式使用的比较广泛，比如：重要的消息通知，短信通知。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">syncProducer</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    <span class="comment">// 实例化消息生产者Producer</span></span><br><span class="line">    DefaultMQProducer producer = <span class="keyword">new</span> DefaultMQProducer(<span class="string">&quot;Group_A&quot;</span>);</span><br><span class="line">    <span class="comment">// 设置NameServer的地址</span></span><br><span class="line">    producer.setNamesrvAddr(<span class="string">&quot;localhost:9876&quot;</span>);</span><br><span class="line">    <span class="comment">//启动Producer实例</span></span><br><span class="line">    producer.start();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// 创建消息，并指定Topic，Tag和消息体</span></span><br><span class="line">        Message message = <span class="keyword">new</span> Message(<span class="string">&quot;TopicTest&quot;</span>, <span class="string">&quot;TagA&quot;</span>,</span><br><span class="line">                (<span class="string">&quot;Hello RocketMQ &quot;</span> + i).getBytes(RemotingHelper.DEFAULT_CHARSET));</span><br><span class="line">        <span class="comment">// 发送消息到一个Broker</span></span><br><span class="line">        SendResult sendResult = producer.send(message);</span><br><span class="line">        System.out.println(sendResult);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 不再发送消息，关闭Producer实例</span></span><br><span class="line">    producer.shutdown();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2、发送异步消息"><a href="#2、发送异步消息" class="headerlink" title="2、发送异步消息"></a><strong>2、发送异步消息</strong></h5><p>异步消息通常用在对响应时间敏感的业务场景，即发送端不能容忍长时间地等待Broker的响应。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">asyncProducer</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    DefaultMQProducer producer = <span class="keyword">new</span> DefaultMQProducer(<span class="string">&quot;Group_A&quot;</span>);</span><br><span class="line">    producer.setNamesrvAddr(<span class="string">&quot;localhost:9876&quot;</span>);</span><br><span class="line">    producer.start();</span><br><span class="line">    <span class="comment">// 重试次数</span></span><br><span class="line">    producer.setRetryTimesWhenSendAsyncFailed(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 根据消息数量实例化倒计时计算器</span></span><br><span class="line">    <span class="keyword">final</span> CountDownLatch2 countDownLatch2 = <span class="keyword">new</span> CountDownLatch2(messageCount);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; messageCount; i++)&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> index = i;</span><br><span class="line">        Message message = <span class="keyword">new</span> Message(<span class="string">&quot;TopicTest&quot;</span>, <span class="string">&quot;TagB&quot;</span>,</span><br><span class="line">                <span class="string">&quot;OrderID909&quot;</span>, <span class="string">&quot;Hello World&quot;</span>.getBytes(RemotingHelper.DEFAULT_CHARSET));</span><br><span class="line">        <span class="comment">// SendCallBack接受异步返回结果的回调</span></span><br><span class="line">        producer.send(message, <span class="keyword">new</span> SendCallback() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">(SendResult sendResult)</span> </span>&#123;</span><br><span class="line">                System.out.printf(<span class="string">&quot;%-10d OK %s %n&quot;</span>, index, sendResult.getMsgId());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onException</span><span class="params">(Throwable throwable)</span> </span>&#123;</span><br><span class="line">                System.out.printf(<span class="string">&quot;%-10d Exception %s %n&quot;</span>, index, throwable);</span><br><span class="line">                throwable.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 等待5s</span></span><br><span class="line">    countDownLatch2.await(<span class="number">5</span>, TimeUnit.SECONDS);</span><br><span class="line">    producer.shutdown();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3、发送单向消息"><a href="#3、发送单向消息" class="headerlink" title="3、发送单向消息"></a>3、发送单向消息</h5><p>这种方式主要用在不特别关心发送结果的场景，例如日志发送。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">onewayProducer</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    DefaultMQProducer producer = <span class="keyword">new</span> DefaultMQProducer(<span class="string">&quot;Group_A&quot;</span>);</span><br><span class="line">    producer.setNamesrvAddr(<span class="string">&quot;localhost:9876&quot;</span>);</span><br><span class="line">    producer.start();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; messageCount; i++) &#123;</span><br><span class="line">        Message message = <span class="keyword">new</span> Message(<span class="string">&quot;TopicTest&quot;</span>, <span class="string">&quot;TagC&quot;</span>,</span><br><span class="line">                (<span class="string">&quot;Hello RocketMQ &quot;</span> + i).getBytes(RemotingHelper.DEFAULT_CHARSET));</span><br><span class="line">        <span class="comment">// 发送单向消息，没有返回结果</span></span><br><span class="line">        producer.sendOneway(message);</span><br><span class="line">    &#125;</span><br><span class="line">    producer.shutdown();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="消费消息"><a href="#消费消息" class="headerlink" title="消费消息"></a>消费消息</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">consumer</span><span class="params">()</span> <span class="keyword">throws</span> MQClientException </span>&#123;</span><br><span class="line">    <span class="comment">// 实例化消费者</span></span><br><span class="line">    DefaultMQPushConsumer consumer = <span class="keyword">new</span> DefaultMQPushConsumer(<span class="string">&quot;Consumer_GroupA&quot;</span>);</span><br><span class="line">    <span class="comment">//设置NameServer地址</span></span><br><span class="line">    consumer.setNamesrvAddr(<span class="string">&quot;localhost:9876&quot;</span>);</span><br><span class="line">    <span class="comment">// 订阅一个或者多个Topic，以及Tag来过滤需要消费的消息</span></span><br><span class="line">    consumer.subscribe(<span class="string">&quot;TopicTest&quot;</span>, <span class="string">&quot;*&quot;</span>);</span><br><span class="line">    <span class="comment">// 注册回调实现类来处理从broker拉取回来的消息</span></span><br><span class="line">    consumer.registerMessageListener(<span class="keyword">new</span> MessageListenerConcurrently() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> ConsumeConcurrentlyStatus <span class="title">consumeMessage</span><span class="params">(List&lt;MessageExt&gt; msgList, ConsumeConcurrentlyContext context)</span> </span>&#123;</span><br><span class="line">            System.out.printf(<span class="string">&quot;%s Receive New Messages: %s %n&quot;</span>, Thread.currentThread().getName(), msgList);</span><br><span class="line">            <span class="comment">// 标记该消息已经被成功消费</span></span><br><span class="line">            <span class="keyword">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">//启动消费者实例</span></span><br><span class="line">    consumer.start();</span><br><span class="line">    System.out.println(<span class="string">&quot;Consumer Started&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="发送延时消息"><a href="#发送延时消息" class="headerlink" title="发送延时消息"></a>发送延时消息</h4><p>只需要给消息设置 <code>DelayTimeLevel</code> 延时等级即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; totalMessagesToSend; i++) &#123;</span><br><span class="line">    Message message = <span class="keyword">new</span> Message(<span class="string">&quot;TestTopic&quot;</span>, (<span class="string">&quot;Hello scheduled message &quot;</span> + i).getBytes());</span><br><span class="line">    <span class="comment">// 设置延时等级3,这个消息将在10s之后发送(现在只支持固定的几个时间,详看delayTimeLevel)</span></span><br><span class="line">    message.setDelayTimeLevel(<span class="number">3</span>);</span><br><span class="line">    <span class="comment">// 发送消息</span></span><br><span class="line">    producer.send(message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="顺序消息"><a href="#顺序消息" class="headerlink" title="顺序消息"></a>顺序消息</h3><p>消息有序指的是可以按照消息的发送顺序来消费(FIFO)。RocketMQ可以严格的保证消息有序，可以分为分区有序或者全局有序。</p>
<p>顺序消费的原理解析，在默认的情况下消息发送会采取Round Robin轮询方式把消息发送到不同的queue(分区队列)；而消费消息的时候从多个queue上拉取消息，这种情况发送和消费是不能保证顺序。但是如果<strong>控制发送的顺序消息只依次发送到同一个queue中，消费的时候只从这个queue上依次拉取</strong>，则就保证了顺序。当发送和消费参与的queue只有一个，则是全局有序；如果多个queue参与，则为分区有序，即相对每个queue，消息都是有序的。</p>
<blockquote>
<p>在局部有序中：<strong>一个MessageQueue只能由一个消费者消费，且只能单线程消费。但是这个消费者可以开启多线程，同时消费多个MessageQueue。</strong></p>
</blockquote>
<h4 id="顺序消息生产"><a href="#顺序消息生产" class="headerlink" title="顺序消息生产"></a>顺序消息生产</h4><p>下面用订单进行分区有序的示例。一个订单的顺序流程是：创建、付款、推送、完成。</p>
<p>生产消息时，订单号相同的消息会被先后发送到同一个队列 <code>MessageQueue</code> 中；消费时，同一个OrderId获取到的肯定是同一个队列。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 顺序消息生产</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">orderProducer</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    DefaultMQProducer producer = <span class="keyword">new</span> DefaultMQProducer(<span class="string">&quot;ProducerA&quot;</span>);</span><br><span class="line">    producer.setNamesrvAddr(<span class="string">&quot;localhost:9876&quot;</span>);</span><br><span class="line">    producer.start();</span><br><span class="line"></span><br><span class="line">    String[] tags = <span class="keyword">new</span> String[]&#123;<span class="string">&quot;TagA&quot;</span>, <span class="string">&quot;TagC&quot;</span>, <span class="string">&quot;TagD&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 订单列表</span></span><br><span class="line">    List&lt;OrderStep&gt; orderList = <span class="keyword">new</span> Producer().buildOrders();</span><br><span class="line"></span><br><span class="line">    Date date = <span class="keyword">new</span> Date();</span><br><span class="line">    SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">    String dateStr = sdf.format(date);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// 加个时间前缀</span></span><br><span class="line">        String body = dateStr + <span class="string">&quot; Hello RocketMQ &quot;</span> + orderList.get(i);</span><br><span class="line">        Message msg = <span class="keyword">new</span> Message(<span class="string">&quot;TopicTest&quot;</span>, tags[i % tags.length], <span class="string">&quot;KEY&quot;</span> + i, body.getBytes());</span><br><span class="line"></span><br><span class="line">        SendResult sendResult = producer.send(msg, <span class="keyword">new</span> MessageQueueSelector() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> MessageQueue <span class="title">select</span><span class="params">(List&lt;MessageQueue&gt; mqs, Message msg, Object arg)</span> </span>&#123;</span><br><span class="line">                Long id = (Long) arg;  <span class="comment">//根据订单id选择发送queue</span></span><br><span class="line">                <span class="keyword">long</span> index = id % mqs.size();	<span class="comment">//取模</span></span><br><span class="line">                <span class="keyword">return</span> mqs.get((<span class="keyword">int</span>) index);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, orderList.get(i).getOrderId());<span class="comment">//订单id</span></span><br><span class="line"></span><br><span class="line">        System.out.println(String.format(<span class="string">&quot;SendResult status:%s, queueId:%d, body:%s&quot;</span>,</span><br><span class="line">                sendResult.getSendStatus(),</span><br><span class="line">                sendResult.getMessageQueue().getQueueId(),</span><br><span class="line">                body));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    producer.shutdown();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="顺序消息消费"><a href="#顺序消息消费" class="headerlink" title="顺序消息消费"></a>顺序消息消费</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 顺序消息消费</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">orderConsumer</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    DefaultMQPushConsumer consumer = <span class="keyword">new</span> DefaultMQPushConsumer(<span class="string">&quot;ConsumerA&quot;</span>);</span><br><span class="line">    consumer.setNamesrvAddr(<span class="string">&quot;localhost:9876&quot;</span>);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置Consumer第一次启动是从队列头部开始消费还是队列尾部开始消费&lt;br&gt;</span></span><br><span class="line"><span class="comment">     * 如果非第一次启动，那么按照上次消费的位置继续消费</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET);</span><br><span class="line"></span><br><span class="line">    consumer.subscribe(<span class="string">&quot;TopicTest&quot;</span>, <span class="string">&quot;TagA || TagC || TagD&quot;</span>);</span><br><span class="line"></span><br><span class="line">    consumer.registerMessageListener(<span class="keyword">new</span> MessageListenerOrderly() &#123;</span><br><span class="line"></span><br><span class="line">        Random random = <span class="keyword">new</span> Random();</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> ConsumeOrderlyStatus <span class="title">consumeMessage</span><span class="params">(List&lt;MessageExt&gt; msgs, ConsumeOrderlyContext context)</span> </span>&#123;</span><br><span class="line">            context.setAutoCommit(<span class="keyword">true</span>);</span><br><span class="line">            <span class="keyword">for</span> (MessageExt msg : msgs) &#123;</span><br><span class="line">                <span class="comment">// 可以看到每个queue有唯一的consume线程来消费, 订单对每个queue(分区)有序</span></span><br><span class="line">                System.out.println(<span class="string">&quot;consumeThread=&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;queueId=&quot;</span> + msg.getQueueId() + <span class="string">&quot;, content:&quot;</span> + <span class="keyword">new</span> String(msg.getBody()));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//模拟业务逻辑处理中...</span></span><br><span class="line">                TimeUnit.SECONDS.sleep(random.nextInt(<span class="number">10</span>));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> ConsumeOrderlyStatus.SUCCESS;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    consumer.start();</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;Consumer Started.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>重点：每个queue有唯一的consume线程来消费, 订单对每个queue(分区)有序</strong></li>
</ul>
<p>从 <code>consumer.registerMessageListener(new MessageListenerOrderly() </code> 代码可以知道，顺序消息使用 <code>MessageListenerOrderly</code> 来告诉消费者进行顺序消费消息，并且只能单线程去消费同一个queue。而普通消息使用 <code>MessageListenerConcurrently</code> 进行并发消费消息。</p>
<h3 id="事务消息"><a href="#事务消息" class="headerlink" title="事务消息"></a>事务消息</h3><p>事务消息共有三种状态，提交状态、回滚状态、中间状态：</p>
<ul>
<li>TransactionStatus.CommitTransaction: 提交事务，它允许消费者消费此消息。</li>
<li>TransactionStatus.RollbackTransaction: 回滚事务，它代表该消息将被删除，不允许被消费。</li>
<li>TransactionStatus.Unknown: 中间状态，它代表需要检查消息队列来确定状态。</li>
</ul>
<h4 id="创建事务型生产者"><a href="#创建事务型生产者" class="headerlink" title="创建事务型生产者"></a>创建事务型生产者</h4><p>使用 <code>TransactionMQProducer</code>类创建生产者，并指定唯一的 <code>ProducerGroup</code>，就可以设置自定义线程池来处理这些检查请求。执行本地事务后、需要根据执行结果对消息队列进行回复。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">transactionProducer</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    TransactionListener transactionListener = <span class="keyword">new</span> TransactionListenerImpl();</span><br><span class="line">    TransactionMQProducer producer = <span class="keyword">new</span> TransactionMQProducer(<span class="string">&quot;TransactionProducer&quot;</span>);</span><br><span class="line">    ExecutorService executorService = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">2</span>, <span class="number">5</span>, <span class="number">100</span>, TimeUnit.SECONDS, <span class="keyword">new</span> ArrayBlockingQueue&lt;Runnable&gt;(<span class="number">2000</span>), <span class="keyword">new</span> ThreadFactory() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(Runnable runnable)</span> </span>&#123;</span><br><span class="line">            Thread thread = <span class="keyword">new</span> Thread(runnable);</span><br><span class="line">            thread.setName(<span class="string">&quot;client-transaction-msg-check-thread&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> thread;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    producer.setExecutorService(executorService);</span><br><span class="line">    producer.setTransactionListener(transactionListener);</span><br><span class="line">    producer.start();</span><br><span class="line">    String[] tags = <span class="keyword">new</span> String[] &#123;<span class="string">&quot;TagA&quot;</span>, <span class="string">&quot;TagB&quot;</span>, <span class="string">&quot;TagC&quot;</span>, <span class="string">&quot;TagD&quot;</span>, <span class="string">&quot;TagE&quot;</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Message message = <span class="keyword">new</span> Message(<span class="string">&quot;MyTopic&quot;</span>, tags[i % tags.length], <span class="string">&quot;KEY&quot;</span> + i,</span><br><span class="line">                    (<span class="string">&quot;Hello RocketMQ &quot;</span> + i).getBytes(RemotingHelper.DEFAULT_CHARSET));</span><br><span class="line">            TransactionSendResult sendResult = producer.sendMessageInTransaction(message, <span class="keyword">null</span>);</span><br><span class="line">            System.out.println(sendResult);</span><br><span class="line">            Thread.sleep(<span class="number">10</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (MQClientException | UnsupportedEncodingException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    producer.shutdown();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="实现事务的监听接口"><a href="#实现事务的监听接口" class="headerlink" title="实现事务的监听接口"></a>实现事务的监听接口</h4><p>当发送半消息成功时，我们使用 <code>executeLocalTransaction</code> 方法来执行本地事务。它返回前一节中提到的三个事务状态之一。<code>checkLocalTransaction</code> 方法用于检查本地事务状态，并回应消息队列的检查请求。它也是返回前一节中提到的三个事务状态之一。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransactionListenerImpl</span> <span class="keyword">implements</span> <span class="title">TransactionListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> AtomicInteger transactionIndex = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ConcurrentHashMap&lt;String, Integer&gt; localTrans = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 执行本地事务</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> LocalTransactionState <span class="title">executeLocalTransaction</span><span class="params">(Message msg, Object arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> value = transactionIndex.getAndIncrement();</span><br><span class="line">        <span class="keyword">int</span> status = value % <span class="number">3</span>;</span><br><span class="line">        localTrans.put(msg.getTransactionId(), status);</span><br><span class="line">        <span class="comment">//返回未知，让Broker回查事务状态</span></span><br><span class="line">        <span class="keyword">return</span> LocalTransactionState.UNKNOW;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 检查本地事务状态</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> LocalTransactionState <span class="title">checkLocalTransaction</span><span class="params">(MessageExt msg)</span> </span>&#123;</span><br><span class="line">        Integer status = localTrans.get(msg.getTransactionId());</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">null</span> != status)&#123;</span><br><span class="line">            <span class="keyword">switch</span> (status)&#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">return</span> LocalTransactionState.UNKNOW;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                    <span class="keyword">return</span> LocalTransactionState.COMMIT_MESSAGE;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                    <span class="keyword">return</span> LocalTransactionState.ROLLBACK_MESSAGE;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> LocalTransactionState.COMMIT_MESSAGE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="事务消息流程"><a href="#事务消息流程" class="headerlink" title="事务消息流程"></a>事务消息流程</h4><p><img src="https://gitee.com/KIMTOU/img/raw/master/20210921155621.png"></p>
<p>分为两个流程：正常事务消息的发送及提交、事务消息的补偿流程。</p>
<p>1、事务消息发送及提交：</p>
<p>(1) 发送消息（half半消息）。</p>
<p>(2) 服务端响应消息写入结果。</p>
<p>(3) 根据发送结果执行本地事务（如果写入失败，此时half消息对业务不可见，本地逻辑不执行）。</p>
<p>(4) 根据本地事务状态执行Commit或者Rollback（Commit操作生成消息索引，消息对消费者可见）</p>
<p>2、补偿流程（回查）：</p>
<p>(1) 对没有Commit/Rollback的事务消息（pending状态的消息），从服务端发起一次“回查”</p>
<p>(2) Producer收到回查消息，检查回查消息对应的本地事务的状态</p>
<p>(3) 根据本地事务状态，重新Commit或者Rollback</p>
<p>其中，补偿阶段用于解决消息Commit或者Rollback发生超时或者失败的情况。</p>
<h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h2><h4 id="Tags的使用"><a href="#Tags的使用" class="headerlink" title="Tags的使用"></a>Tags的使用</h4><p>一个应用尽可能用一个Topic，而消息子类型则可以用tags来标识。tags可以由应用自由设置，只有生产者在发送消息设置了tags，消费方在订阅消息时才可以利用tags通过broker做消息过滤：message.setTags(“TagA”)。</p>
<h4 id="Keys的使用"><a href="#Keys的使用" class="headerlink" title="Keys的使用"></a>Keys的使用</h4><p>每个消息在业务层面的唯一标识码要设置到keys字段，方便将来定位消息丢失问题。服务器会为每个消息创建索引（哈希索引），应用可以通过topic、key来查询这条消息内容，以及消息被谁消费。由于是哈希索引，请务必保证key尽可能唯一，这样可以避免潜在的哈希冲突。</p>
<h4 id="事务消息-1"><a href="#事务消息-1" class="headerlink" title="事务消息"></a>事务消息</h4><p>执行本地事务 <code>executeLocalTransaction</code> 时，如果业务执行失败，可明确告知回滚，直接返回 <code>Rollback</code>；如果业务成功，不建议直接返回 <code>Commit</code> ，而是建议返回 <code>UNKNOW</code>。</p>
<p>然后在进行事务回查 <code>checkLocalTransaction</code> 时如果能明确事务成功，才返回 <code>Commit</code>。如果不能明确本地事务成功，返回 <code>UNKNOW</code>，服务端默认回查15次。</p>
<h4 id="消息发送失败处理方式"><a href="#消息发送失败处理方式" class="headerlink" title="消息发送失败处理方式"></a>消息发送失败处理方式</h4><p>Producer的send方法本身支持内部重试，重试逻辑如下：</p>
<ul>
<li>至多重试2次。</li>
<li>如果同步模式发送失败，则轮转到下一个Broker，如果异步模式发送失败，则只会在当前Broker进行重试。这个方法的总耗时时间不超过sendMsgTimeout设置的值，默认10s。</li>
<li>如果本身向broker发送消息产生超时异常，就不会再重试。</li>
</ul>
<p>以上策略也是在一定程度上保证了消息可以发送成功。如果业务对消息可靠性要求比较高，建议应用增加相应的重试逻辑：比如调用send同步方法发送失败时，则尝试将消息存储到db，然后由后台线程定时重试，确保消息一定到达Broker。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://github.com/apache/rocketmq/tree/master/docs/cn">rocketmq/docs/cn at master · apache/rocketmq (github.com)</a></p>
]]></content>
      <categories>
        <category>消息队列</category>
      </categories>
      <tags>
        <tag>消息队列</tag>
      </tags>
  </entry>
  <entry>
    <title>初识RocketMQ——基本概念以及安装启动</title>
    <url>/2021/09/12/%E5%88%9D%E8%AF%86RocketMQ%E2%80%94%E2%80%94%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E4%BB%A5%E5%8F%8A%E5%AE%89%E8%A3%85%E5%90%AF%E5%8A%A8/</url>
    <content><![CDATA[<p><strong>RocketMQ</strong> 是一个 <strong>队列模型</strong> 的消息中间件，具有<strong>高性能、高可靠、高实时、分布式</strong> 的特点。</p>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="核心组成"><a href="#核心组成" class="headerlink" title="核心组成"></a>核心组成</h3><p>RocketMQ的四大核心组成部分：<strong>NameServer</strong>、<strong>Broker</strong>、<strong>Producer</strong>以及<strong>Consumer</strong></p>
<hr>
<h4 id="名字服务-NameServer"><a href="#名字服务-NameServer" class="headerlink" title="名字服务 NameServer"></a>名字服务 NameServer</h4><p><strong>作为注册中心，主要负责对于源数据的管理，提供Broker管理以及路由信息管理。</strong></p>
<p>名称服务充当路由消息的提供者。生产者或消费者能够通过名字服务查找各主题相应的Broker IP列表。多个Namesrv实例组成集群，<strong>每个NameServer节点相互独立，没有信息交换。</strong></p>
<p><strong>每个 Broker 在启动的时候会将信息注册到 NameServer ，Producer 在发送消息前会根据 Topic 到 NameServer 获取到 Broker 的路由信息，Consumer 也会定时获取 Topic 的路由信息。</strong></p>
<hr>
<h4 id="代理服务器-Broker"><a href="#代理服务器-Broker" class="headerlink" title="代理服务器 Broker"></a>代理服务器 Broker</h4><p><strong>消息中转角色，负责存储消息、转发消息。</strong>代理服务器在RocketMQ系统中负责接收从生产者发送来的消息并存储、同时为消费者的拉取请求作准备。代理服务器也存储消息相关的元数据，包括消费者组、消费进度偏移和主题和队列消息等。</p>
<hr>
<h4 id="消息生产者-Producer"><a href="#消息生产者-Producer" class="headerlink" title="消息生产者 Producer"></a>消息生产者 Producer</h4><p><strong>负责生产消息</strong>，一般由业务系统负责生产消息。一个消息生产者会把业务应用系统里产生的消息发送到broker服务器。RocketMQ提供多种发送方式，同步发送、异步发送、顺序发送、单向发送。同步和异步方式均需要Broker返回确认信息，单向发送不需要。</p>
<hr>
<h4 id="消息消费者-Consumer"><a href="#消息消费者-Consumer" class="headerlink" title="消息消费者 Consumer"></a>消息消费者 Consumer</h4><p><strong>负责消费消息</strong>，一般是后台系统负责异步消费。一个消息消费者会从Broker服务器拉取消息、并将其提供给应用程序。从用户应用的角度而言提供了两种消费形式：拉取式消费、推动式消费。</p>
<hr>
<h3 id="消息领域模型"><a href="#消息领域模型" class="headerlink" title="消息领域模型"></a>消息领域模型</h3><h4 id="消息模型-Message-Model"><a href="#消息模型-Message-Model" class="headerlink" title="消息模型 Message Model"></a>消息模型 Message Model</h4><p>RocketMQ主要由 Producer、Broker、Consumer 三部分组成，其中Producer 负责生产消息，Consumer 负责消费消息，Broker 负责存储消息。Broker 在实际部署过程中对应一台服务器，<strong>每个 Broker 可以存储多个Topic的消息，每个Topic的消息也可以分片存储于不同的 Broker。</strong>Message Queue 用于存储消息的物理地址，每个Topic中的消息地址存储于多个 Message Queue 中。ConsumerGroup 由多个Consumer 实例构成。</p>
<h4 id="消息-Message"><a href="#消息-Message" class="headerlink" title="消息 Message"></a>消息 Message</h4><p><strong>消息系统所传输信息的物理载体，生产和消费数据的最小单位</strong>，每条消息必须属于一个主题。RocketMQ中每个消息拥有唯一的Message ID，且可以携带具有业务标识的Key。系统提供了通过Message ID和Key查询消息的功能。</p>
<h4 id="主题-Topic"><a href="#主题-Topic" class="headerlink" title="主题 Topic"></a>主题 Topic</h4><p><strong>表示一类消息的集合</strong>，每个主题包含若干条消息，每条消息只能属于一个主题，是RocketMQ进行消息订阅的基本单位。</p>
<blockquote>
<p><strong>Topic</strong> 与生产者和消费者的关系非常松散，一个 Topic 可以有0个、1个、多个生产者向其发送消息，一个生产者也可以同时向不同的 Topic 发送消息。</p>
<p>一个 Topic 也可以被 0个、1个、多个消费者订阅。</p>
</blockquote>
<h4 id="标签-Tag"><a href="#标签-Tag" class="headerlink" title="标签 Tag"></a>标签 Tag</h4><p><strong>为消息设置的标志，用于同一主题下区分不同类型的消息</strong>。来自同一业务单元的消息，可以根据不同业务目的在同一主题下设置不同标签。标签能够有效地保持代码的清晰度和连贯性，并优化RocketMQ提供的查询系统。消费者可以根据Tag实现对不同子主题的不同消费逻辑，实现更好的扩展性。</p>
<h4 id="分组-Group"><a href="#分组-Group" class="headerlink" title="分组 Group"></a>分组 Group</h4><p>分为ProducerGroup，ConsumerGroup，代表某一类的生产者和消费者，一个组可以订阅多个Topic。</p>
<p><strong>ProducerGroup</strong>代表同一类Producer的集合，这类Producer发送同一类消息且发送逻辑一致。如果发送的是事务消息且原始生产者在发送之后崩溃，则Broker服务器会联系同一生产者组的其他生产者实例以提交或回溯消费。</p>
<p><strong>ConsumerGroup</strong>代表同一类Consumer的集合，这类Consumer通常消费同一类消息且消费逻辑一致。消费者组使得在消息消费方面，实现负载均衡和容错的目标变得非常容易。要注意的是，消费者组的消费者实例必须订阅完全相同的Topic。RocketMQ 支持两种消息模式：集群消费（Clustering）和广播消费（Broadcasting）。</p>
<h3 id="消费模式"><a href="#消费模式" class="headerlink" title="消费模式"></a>消费模式</h3><h4 id="集群消费-Clustering"><a href="#集群消费-Clustering" class="headerlink" title="集群消费 Clustering"></a>集群消费 Clustering</h4><p>集群消费模式下,相同Consumer Group的每个Consumer实例平均分摊消息。</p>
<h4 id="广播消费-Broadcasting"><a href="#广播消费-Broadcasting" class="headerlink" title="广播消费 Broadcasting"></a>广播消费 Broadcasting</h4><p>广播消费模式下，相同Consumer Group的每个Consumer实例都接收全量的消息。</p>
<h3 id="消费类型"><a href="#消费类型" class="headerlink" title="消费类型"></a>消费类型</h3><h4 id="拉取式消费-Pull-Consumer"><a href="#拉取式消费-Pull-Consumer" class="headerlink" title="拉取式消费 Pull Consumer"></a>拉取式消费 Pull Consumer</h4><p>Consumer消费的一种类型，应用通常主动调用Consumer的拉消息方法从Broker服务器拉消息、主动权由应用控制。一旦获取了批量消息，应用就会启动消费过程。</p>
<h4 id="推动式消费-Push-Consumer"><a href="#推动式消费-Push-Consumer" class="headerlink" title="推动式消费 Push Consumer"></a>推动式消费 Push Consumer</h4><p>Consumer消费的一种类型，该模式下Broker收到数据后会主动推送给消费端，该消费模式一般实时性较高。</p>
<hr>
<h2 id="架构设计"><a href="#架构设计" class="headerlink" title="架构设计"></a>架构设计</h2><img src="https://gitee.com/KIMTOU/img/raw/master/20210912214133.png" style="zoom:150%;" />



<p><strong>RocketMQ架构上主要分为四部分</strong>，如上图所示:</p>
<ul>
<li><strong>Producer：消息发布的角色</strong>，支持分布式集群方式部署。Producer通过MQ的负载均衡模块选择相应的Broker集群队列进行消息投递，投递的过程支持快速失败并且低延迟。</li>
<li><strong>Consumer：消息消费的角色</strong>，支持分布式集群方式部署。支持以push推，pull拉两种模式对消息进行消费。同时也支持集群方式和广播方式的消费，它提供实时消息订阅机制，可以满足大多数用户的需求。</li>
<li><strong>NameServer：NameServer是一个非常简单的Topic路由注册中心</strong>，其角色类似Dubbo中的zookeeper，支持Broker的动态注册与发现。<strong>主要包括两个功能：Broker管理</strong>，NameServer接受Broker集群的注册信息并且保存下来作为路由信息的基本数据。然后提供心跳检测机制，检查Broker是否还存活；<strong>路由信息管理</strong>，每个NameServer将保存关于Broker集群的整个路由信息和用于客户端查询的队列信息。然后Producer和Conumser通过NameServer就可以知道整个Broker集群的路由信息，从而进行消息的投递和消费。NameServer通常也是集群的方式部署，各实例间相互不进行信息通讯。Broker是向每一台NameServer注册自己的路由信息，所以每一个NameServer实例上面都保存一份完整的路由信息。当某个NameServer因某种原因下线了，Broker仍然可以向其它NameServer同步其路由信息，Producer,Consumer仍然可以动态感知Broker的路由的信息。</li>
<li><strong>BrokerServer：Broker主要负责消息的存储、投递和查询以及服务高可用保证</strong></li>
</ul>
<h4 id="RocketMQ-网络部署特点"><a href="#RocketMQ-网络部署特点" class="headerlink" title="RocketMQ 网络部署特点"></a>RocketMQ 网络部署特点</h4><ul>
<li>NameServer是一个几乎无状态节点，可集群部署，节点之间无任何信息同步。</li>
<li>Broker部署相对复杂，Broker分为Master与Slave，一个Master可以对应多个Slave，但是一个Slave只能对应一个Master，Master与Slave 的对应关系通过指定相同的BrokerName，不同的BrokerId 来定义，BrokerId为0表示Master，非0表示Slave。Master也可以部署多个。每个Broker与NameServer集群中的所有节点建立长连接，定时注册Topic信息到所有NameServer。 注意：当前RocketMQ版本在部署架构上支持一Master多Slave，但只有BrokerId=1的从服务器才会参与消息的读负载。</li>
<li>Producer与NameServer集群中的其中一个节点（随机选择）建立长连接，定期从NameServer获取Topic路由信息，并向提供Topic 服务的Master建立长连接，且定时向Master发送心跳。Producer完全无状态，可集群部署。</li>
<li>Consumer与NameServer集群中的其中一个节点（随机选择）建立长连接，定期从NameServer获取Topic路由信息，并向提供Topic服务的Master、Slave建立长连接，且定时向Master、Slave发送心跳。Consumer既可以从Master订阅消息，也可以从Slave订阅消息，消费者在向Master拉取消息时，Master服务器会根据拉取偏移量与最大偏移量的距离（判断是否读老消息，产生读I/O），以及从服务器是否可读等因素建议下一次是从Master还是Slave拉取。</li>
</ul>
<h4 id="集群工作流程"><a href="#集群工作流程" class="headerlink" title="集群工作流程"></a>集群工作流程</h4><ul>
<li>启动NameServer，NameServer起来后监听端口，等待Broker、Producer、Consumer连上来，相当于一个路由控制中心。</li>
<li>Broker启动，跟所有的NameServer保持长连接，定时发送心跳包。心跳包中包含当前Broker信息(IP+端口等)以及存储所有Topic信息。注册成功后，NameServer集群中就有Topic跟Broker的映射关系。</li>
<li>收发消息前，先创建Topic，创建Topic时需要指定该Topic要存储在哪些Broker上，也可以在发送消息时自动创建Topic。</li>
<li>Producer发送消息，启动时先跟NameServer集群中的其中一台建立长连接，并从NameServer中获取当前发送的Topic存在哪些Broker上，轮询从队列列表中选择一个队列，然后与队列所在的Broker建立长连接从而向Broker发消息。</li>
<li>Consumer跟Producer类似，跟其中一台NameServer建立长连接，获取当前订阅Topic存在哪些Broker上，然后直接跟Broker建立连接通道，开始消费消息。</li>
</ul>
<hr>
<h2 id="安装启动（Linux）"><a href="#安装启动（Linux）" class="headerlink" title="安装启动（Linux）"></a>安装启动（Linux）</h2><h4 id="1、下载压缩包"><a href="#1、下载压缩包" class="headerlink" title="1、下载压缩包"></a>1、下载压缩包</h4><p>镜像下载地址：<a href="https://mirrors.bfsu.edu.cn/apache/rocketmq/4.9.1/rocketmq-all-4.9.1-source-release.zip"><strong>https://mirrors.bfsu.edu.cn/apache/rocketmq/4.9.1/rocketmq-all-4.9.1-source-release.zip</strong></a></p>
<h4 id="2、将压缩包上传至Linux"><a href="#2、将压缩包上传至Linux" class="headerlink" title="2、将压缩包上传至Linux"></a>2、将压缩包上传至Linux</h4><ul>
<li>解压</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">unzip rocketmq-all-4.9.1-source-release.zip</span><br></pre></td></tr></table></figure>

<h4 id="3、修改配置文件"><a href="#3、修改配置文件" class="headerlink" title="3、修改配置文件"></a>3、修改配置文件</h4><p>启动顺序为先启动NameServer，再启动Broker。但是启动之前需要先检查自己服务器内存情况，因为默认参数需要的JVM内存较大，因此需要修改这两个的配置文件（<code>runserver.sh</code>、<code>runbroker.sh</code>）。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 进入对应目录</span></span><br><span class="line">cd /home/rocketmq/rocketmq-all-4.9.1-bin-release/bin</span><br><span class="line"><span class="meta">#</span><span class="bash"> 修改NameServer配置文件</span></span><br><span class="line">vim runserver.sh</span><br></pre></td></tr></table></figure>

<ul>
<li>查找JVM配置：</li>
</ul>
<p><img src="https://gitee.com/KIMTOU/img/raw/master/20210912214128.PNG"></p>
<ul>
<li>将其修改成：</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">JAVA_OPT=&quot;$&#123;JAVA_OPT&#125; -server -Xms256m -Xmx256m -Xmn128m -XX:MetaspaceSize=128m -XX:MaxMetaspaceSize=320m&quot;</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 修改Broker配置文件</span></span><br><span class="line">vim runbroker.sh</span><br></pre></td></tr></table></figure>

<ul>
<li>查找JVM配置：</li>
</ul>
<p><img src="https://gitee.com/KIMTOU/img/raw/master/20210912214122.PNG"></p>
<p>将其修改成：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">JAVA_OPT=&quot;$&#123;JAVA_OPT&#125; -server -Xms256m -Xmx256m&quot;</span><br></pre></td></tr></table></figure>

<h4 id="4、启动"><a href="#4、启动" class="headerlink" title="4、启动"></a>4、启动</h4><ul>
<li>进入bin目录</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@CJT-Linux bin]# pwd</span><br><span class="line">/home/rocketmq/rocketmq-all-4.9.1-bin-release/bin</span><br></pre></td></tr></table></figure>

<ul>
<li>启动NameServer</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nohup sh mqnamesrv &amp;</span><br></pre></td></tr></table></figure>

<ul>
<li>检查是否启动成功</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tail -f ~/logs/rocketmqlogs/namesrv.log</span><br><span class="line"><span class="meta">#</span><span class="bash"> 出现 The Name Server boot success...代表启动成功</span></span><br></pre></td></tr></table></figure>

<ul>
<li>启动Broker</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nohup sh mqbroker -n localhost:9876 &amp;</span><br></pre></td></tr></table></figure>

<ul>
<li>检查是否启动成功</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tail -f ~/logs/rocketmqlogs/broker.log </span><br></pre></td></tr></table></figure>

<h4 id="5、测试"><a href="#5、测试" class="headerlink" title="5、测试"></a>5、测试</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 配置NameServer地址</span></span><br><span class="line">export NAMESRV_ADDR=localhost:9876</span><br><span class="line"><span class="meta">#</span><span class="bash"> 生产数据</span></span><br><span class="line">sh tools.sh org.apache.rocketmq.example.quickstart.Producer</span><br><span class="line"><span class="meta">#</span><span class="bash"> 消费数据</span></span><br><span class="line">sh tools.sh org.apache.rocketmq.example.quickstart.Consumer</span><br></pre></td></tr></table></figure>



<h4 id="Window环境下安装启动"><a href="#Window环境下安装启动" class="headerlink" title="Window环境下安装启动"></a>Window环境下安装启动</h4><p>1、下载压缩包并解压</p>
<p>2、配置系统环境</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">ROCKETMQ_HOME</span>=<span class="string">&quot;D:\rocketmq&quot;</span></span><br><span class="line"><span class="attr">NAMESRV_ADDR</span>=<span class="string">&quot;localhost:9876&quot;</span></span><br></pre></td></tr></table></figure>

<p>3、在bin目录下启动<code>mqnamesrv.cmd</code>，再启动<code>mqbroker.cmd</code></p>
<hr>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>中文官方文档：<a href="https://github.com/apache/rocketmq/blob/master/docs/cn">https://github.com/apache/rocketmq/blob/master/docs/cn</a></p>
<p><a href="https://blog.csdn.net/qq_35190492/article/details/103341634?ops_request_misc=%7B%22request_id%22:%22162972269016780271584378%22,%22scm%22:%2220140713.130102334.pc_blog.%22%7D&request_id=162972269016780271584378&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_v2~rank_v29-1-103341634.pc_v2_rank_blog_default&utm_term=rocket&spm=1018.2226.3001.4450">看完保送阿里的RocketMQ知识点（超详细）_敖丙-CSDN博客</a></p>
<p><a href="http://rocketmq.apache.org/docs/quick-start/">Quick Start - Apache RocketMQ</a></p>
]]></content>
      <categories>
        <category>消息队列</category>
      </categories>
      <tags>
        <tag>消息队列</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式——单例模式</title>
    <url>/2021/09/26/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<ul>
<li><strong>作用：单例模式主要解决的是，防止一个全局使用的类频繁的创建和消费，从而提升提升整体的代码的性能。</strong></li>
</ul>
<ul>
<li><strong>特点：单例模式有一个特点就是不允许外部直接创建，因此在默认的构造函数上添加了私有属性 <code>private</code>。</strong></li>
</ul>
<h2 id="懒汉式（线程不安全）"><a href="#懒汉式（线程不安全）" class="headerlink" title="懒汉式（线程不安全）"></a>懒汉式（线程不安全）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 懒汉式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Lazy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Lazy instance;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 私有构造方法，防止被实例化</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Lazy</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Lazy <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Lazy();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>优点</strong>：延迟加载，真正用的时候才实例化对象，提高了资源的利用率</p>
<p><strong>缺点</strong>：存在并发访问的问题（可能进行了多次new操作）</p>
<h2 id="懒汉式（线程安全）"><a href="#懒汉式（线程安全）" class="headerlink" title="懒汉式（线程安全）"></a>懒汉式（线程安全）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 懒汉式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Lazy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Lazy instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Lazy</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> Lazy <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Lazy();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>拥有上面懒汉式的优点，同时也克服了其缺点，使用<code>synchronized</code>关键字同步加锁，保证了线程安全，但所有的访问都需要加锁，造成了资源的浪费。</p>
<h2 id="饿汉式（线程安全）"><a href="#饿汉式（线程安全）" class="headerlink" title="饿汉式（线程安全）"></a>饿汉式（线程安全）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 饿汉式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hungry</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Hungry hungry = <span class="keyword">new</span> Hungry();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 私有构造方法，防止被实例化</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Hungry</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Hungry <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> hungry;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>优点</strong>：static变量会在类装载时初始化，不存在并发访问问题，可以省略synchronized关键字</p>
<p><strong>缺点</strong>：类初始化时就创建了对象，如果只是加载本类，而不是要调用 getInstance()，甚至永远没有调用，则会造成资源浪费</p>
<h2 id="双重校验锁（线程安全）"><a href="#双重校验锁（线程安全）" class="headerlink" title="双重校验锁（线程安全）"></a>双重校验锁（线程安全）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 双重校验锁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DoubleLock</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> DoubleLock instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">DoubleLock</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DoubleLock <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance != <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> instance;</span><br><span class="line">        <span class="keyword">synchronized</span> (DoubleLock.class)&#123;</span><br><span class="line">            <span class="keyword">if</span>(instance == <span class="keyword">null</span>)</span><br><span class="line">                instance = <span class="keyword">new</span> DoubleLock();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>双重锁的方式是方法级锁的优化，减少了部分获取实例的耗时。</li>
<li>同时这种方式也满足了懒加载。</li>
</ul>
<p><strong>为什么使用<code>volatile</code> ？</strong></p>
<blockquote>
<p>采⽤ volatile 关键字修饰也是很有必要的， singleton = new Singleton(); 这段代码其实是分为三步执⾏： </p>
<ol>
<li><p>为 singleton 分配内存空间 </p>
</li>
<li><p>初始化 singleton </p>
</li>
<li><p>将 singleton 指向分配的内存地址 </p>
<p>但是由于 JVM 具有指令重排的特性，执⾏顺序有可能变成 1-3-2。指令重排在单线程环境下不会出 现问题，但是在多线程环境下会导致⼀个线程获得还没有初始化的实例。例如，线程 T1 执⾏了 1 和 3，此时 T2 调⽤ getInstance() 后发现 singleton 不为空，因此返回 singleton ，但此时 singleton 还未被初始化。 使⽤ volatile 可以禁⽌ JVM 的指令重排，保证在多线程环境下也能正常运⾏。</p>
</li>
</ol>
</blockquote>
<h2 id="静态内部类（线程安全）"><a href="#静态内部类（线程安全）" class="headerlink" title="静态内部类（线程安全）"></a>静态内部类（线程安全）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 静态内部类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerClass</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">inner</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> InnerClass instance = <span class="keyword">new</span> InnerClass();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">InnerClass</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> InnerClass <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> inner.instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>既保证了线程安全又保证了懒加载，同时不会因为加锁的方式耗费性能。</li>
</ul>
<ul>
<li>这主要是因为JVM虚拟机可以保证多线程并发访问的正确性，也就是一个类的构造方法在多线程环境下可以被正确的加载。</li>
</ul>
<h2 id="CAS（线程安全）"><a href="#CAS（线程安全）" class="headerlink" title="CAS（线程安全）"></a>CAS（线程安全）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * CAS</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CAS</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicReference&lt;CAS&gt; INSTANCE = <span class="keyword">new</span> AtomicReference&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">CAS</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> CAS <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>( ; ; )&#123;</span><br><span class="line">            CAS instance = INSTANCE.get();</span><br><span class="line">            <span class="keyword">if</span>(instance != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> instance;</span><br><span class="line">            &#125;</span><br><span class="line">            INSTANCE.compareAndSet(<span class="keyword">null</span>, <span class="keyword">new</span> CAS());</span><br><span class="line">            <span class="keyword">return</span> INSTANCE.get();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>java并发库提供了很多原子类来支持并发访问的数据安全性；<code>AtomicInteger</code>、<code>AtomicBoolean</code>、<code>AtomicLong</code>、<code>AtomicReference</code>。</li>
<li>AtomicReference 可以封装引用一个V实例，支持并发访问如上的单例方式就是使用了这样的一个特点。</li>
<li>使用CAS的好处就是不需要使用传统的加锁方式保证线程安全，而是依赖于CAS的忙等算法，依赖于底层硬件的实现，来保证线程安全。相对于其他锁的实现没有线程的切换和阻塞也就没有了额外的开销，并且可以支持较大的并发性。</li>
<li>当然CAS也有一个缺点就是忙等，如果一直没有获取到将会处于死循环中。</li>
</ul>
<h2 id="枚举单例（线程安全）"><a href="#枚举单例（线程安全）" class="headerlink" title="枚举单例（线程安全）"></a>枚举单例（线程安全）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 枚举单例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">EnumSingle</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    INSTANCE;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;枚举单例&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        EnumSingle.INSTANCE.test();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>优点</strong>：实现简单，枚举本身就是单例模式。由JVM从根本上提供保障！避免通过反射和反序列化的漏洞！</li>
<li><strong>缺点</strong>：无延迟加载</li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://bugstack.cn/itstack-demo-design/2020/05/31/%E9%87%8D%E5%AD%A6-Java-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%AE%9E%E6%88%98%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F.html">重学 Java 设计模式：实战单例模式「7种单例模式案例，Effective Java 作者推荐枚举单例模式」 - bugstack虫洞栈</a></p>
<p><a href="https://bareth.blog.csdn.net/article/details/116643620">彻底玩转单例模式</a></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式——工厂模式</title>
    <url>/2021/09/26/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><ul>
<li>简单工厂模式</li>
<li>工厂方法模式</li>
<li>抽象工厂模式</li>
</ul>
<h2 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h2><p><strong>作用：在创建一个对象时不向客户暴露内部细节，并提供一个创建对象的通用接口。</strong></p>
<p>简单工厂把实例化的操作单独放到一个类中，这个类就成为简单工厂类，让简单工厂类来决定应该用哪个具体子类来实例化。</p>
<p>这样做能把客户类和具体子类的实现解耦，客户类不再需要知道有哪些子类以及应当实例化哪个子类。客户类往往有多个，如果不使用简单工厂，那么所有的客户类都要知道所有子类的细节。而且一旦子类发生改变，例如增加子类，那么所有的客户类都要进行修改。</p>
<h4 id="1、创建父类或父接口"><a href="#1、创建父类或父接口" class="headerlink" title="1、创建父类或父接口"></a>1、创建父类或父接口</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String productName;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getProductName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> productName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setProductName</span><span class="params">(String productName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.productName = productName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Product&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;productName=&#x27;&quot;</span> + productName + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2、多个子类继承或实现"><a href="#2、多个子类继承或实现" class="headerlink" title="2、多个子类继承或实现"></a>2、多个子类继承或实现</h4><h4 id="3、简单工厂实现"><a href="#3、简单工厂实现" class="headerlink" title="3、简单工厂实现"></a>3、简单工厂实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Product <span class="title">createProduct</span><span class="params">(ProductTypeEnum productType)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(ProductTypeEnum.product_ONE.equals(productType))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ProductOne();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(ProductTypeEnum.product_TWO.equals(productType))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ProductTwo();</span><br><span class="line">        &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Product();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4、客户端调用"><a href="#4、客户端调用" class="headerlink" title="4、客户端调用"></a>4、客户端调用</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FactoryClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Product product = SimpleFactory.createProduct(ProductTypeEnum.product_ONE);</span><br><span class="line">        System.out.println(product);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h2><p><strong>作用：定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法模式使一个类的实例化延迟到其子类。</strong></p>
<p>在简单工厂中，创建对象的是另一个类，而在工厂方法中，是由子类来创建对象。<strong>工厂类直接被抽象化，需要具体特定化的逻辑代码转移到实现抽象方法的子类中，这样我们就不要再去修改工厂类</strong>，即不用再去做什么 if else 的修改。</p>
<p>简单说就是为了提供代码结构的扩展性，屏蔽每一个功能类中的具体实现逻辑。让外部可以更加简单的只是知道调用即可，同时，这也是去掉众多<code>ifelse</code>的方式。当然这可能也有一些缺点，比如需要实现的类非常多，如何去维护，怎样减低开发成本。</p>
<h4 id="1、创建工厂方法类"><a href="#1、创建工厂方法类" class="headerlink" title="1、创建工厂方法类"></a>1、创建工厂方法类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">FactoryMethod</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Product <span class="title">createProduct</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">registerProduct</span><span class="params">(Product product)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">create</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Product product = createProduct();</span><br><span class="line">        registerProduct(product);</span><br><span class="line">        <span class="keyword">return</span> product;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2、实现工厂方法的子类"><a href="#2、实现工厂方法的子类" class="headerlink" title="2、实现工厂方法的子类"></a>2、实现工厂方法的子类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 不同类型的商品的工厂</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductFactory</span> <span class="keyword">extends</span> <span class="title">FactoryMethod</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">createProduct</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Product product = <span class="keyword">new</span> ProductOne();</span><br><span class="line">        System.out.println(<span class="string">&quot;创建商品 &quot;</span> + product.toString());</span><br><span class="line">        <span class="keyword">return</span> product;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerProduct</span><span class="params">(Product product)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;注册商品 &quot;</span> + product.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3、客户端调用"><a href="#3、客户端调用" class="headerlink" title="3、客户端调用"></a>3、客户端调用</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FactoryClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        FactoryMethod factoryMethod = <span class="keyword">new</span> ProductFactory();</span><br><span class="line">        Product product = factoryMethod.create();</span><br><span class="line">        System.out.println(product);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="何时使用工厂方法模式，而非简单工厂"><a href="#何时使用工厂方法模式，而非简单工厂" class="headerlink" title="何时使用工厂方法模式，而非简单工厂"></a>何时使用工厂方法模式，而非简单工厂</h2><blockquote>
<p><strong>当对象的创建逻辑比较复杂，不只是简单的 new 一下就可以</strong>，而是要组合其他类对象，做各种初始化操作的时候，我们推荐使用工厂方法模式，将复杂的创建逻辑拆分到多个工厂类中，让每个工厂类都不至于过于复杂。</p>
<p>而使用简单工厂模式，将所有的创建逻辑都放到一个工厂类中，会导致这个工厂类变得很复杂</p>
</blockquote>
<h2 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h2><p>工厂方法类中只有一个抽象方法，要想实现多种不同的类对象，只能去创建不同的具体工厂方法的子类来实列化，而抽象工厂则是让一个工厂负责创建多个不同类型的对象。</p>
<p><strong>抽象工厂模式创建的是对象家族，也就是很多对象而不是一个对象，并且这些对象是相关的</strong>，也就是说必须一起创建出来。而工厂方法模式只是用于创建一个对象，这和抽象工厂模式有很大不同。</p>
<h4 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractProductA</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractProductB</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductA1</span> <span class="keyword">extends</span> <span class="title">AbstractProductA</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductA2</span> <span class="keyword">extends</span> <span class="title">AbstractProductA</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductB1</span> <span class="keyword">extends</span> <span class="title">AbstractProductB</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductB2</span> <span class="keyword">extends</span> <span class="title">AbstractProductB</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> AbstractProductA <span class="title">createProductA</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> AbstractProductB <span class="title">createProductB</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteFactory1</span> <span class="keyword">extends</span> <span class="title">AbstractFactory</span> </span>&#123;</span><br><span class="line">    <span class="function">AbstractProductA <span class="title">createProductA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ProductA1();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">AbstractProductB <span class="title">createProductB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ProductB1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteFactory2</span> <span class="keyword">extends</span> <span class="title">AbstractFactory</span> </span>&#123;</span><br><span class="line">    <span class="function">AbstractProductA <span class="title">createProductA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ProductA2();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">AbstractProductB <span class="title">createProductB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ProductB2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AbstractFactory abstractFactory = <span class="keyword">new</span> ConcreteFactory1();</span><br><span class="line">        AbstractProductA productA = abstractFactory.createProductA();</span><br><span class="line">        AbstractProductB productB = abstractFactory.createProductB();</span><br><span class="line">        <span class="comment">// do something with productA and productB</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><p>1、良好的封装性、代码结构清晰。</p>
<p>如一个调用者想创建一个对象，只需要知道其名称即可，降低了模板间的耦合。</p>
<p>2、扩展性好。</p>
<p>如果想增加一个产品，只需扩展一个工厂类即可。</p>
<p>3、屏蔽产品类</p>
<p>调用者只关心产品的接口。</p>
<p>4、典型的解耦框架</p>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>每增加一个产品，就需要增加一个产品工厂的类，增加了系统的复杂度。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://mp.weixin.qq.com/s?__biz=MzAwNDA2OTM1Ng==&mid=2453151278&idx=1&sn=e2a702fea5a93b6300b90d9958ff9ec1&chksm=8cfd3cadbb8ab5bba091b70ff0b3ce759eab18b5e9e48464bd1c031eb1c56ed305c7e0de7f8b&scene=178&cur_album_id=1761987817540206592#rd">敖丙所在的电商公司都是怎么用工厂模式的 (qq.com)</a></p>
<p>[CS-Notes/设计模式 - 抽象工厂.md at master · CyC2018/CS-Notes (github.com)](<a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F">https://github.com/CyC2018/CS-Notes/blob/master/notes/设计模式</a> - 抽象工厂.md)</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式——模板方法模式</title>
    <url>/2021/09/27/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><ul>
<li><p>定义算法框架，并将一些步骤的实现延迟到子类。</p>
</li>
<li><p>通过模板方法，子类可以重新定义算法的某些步骤，而不用改变算法的结构。</p>
</li>
</ul>
<h2 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h2><p>1、使用模版方法模式的目的是避免编写重复代码，以便开发人员可以专注于核心业务逻辑的实现</p>
<p>2、解决接口与接口实现类之间继承矛盾问题</p>
<h2 id="类关系"><a href="#类关系" class="headerlink" title="类关系"></a>类关系</h2><ul>
<li>AbstractTemplate（抽象模版）：定义一系列抽象方法，或者实现的方法，又或者是钩子方法。即：定义流程</li>
<li>ConcreteTemplate（具体模版）：实现父类抽象方法，基于本身不同的模版业务逻辑，实现不同的业务逻辑代码。即：抽象方法实现相同，内部逻辑不同</li>
</ul>
<h2 id="1、定义模板"><a href="#1、定义模板" class="headerlink" title="1、定义模板"></a>1、定义模板</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 工作流模板</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">WorkFlow</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">doWorkFlow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        initial();</span><br><span class="line">        firstProcess();</span><br><span class="line">        secondProcess();</span><br><span class="line">        end();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">initial</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;初始化&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理一级业务逻辑</span></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">firstProcess</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理二级业务逻辑（默认无实现，子类视情况进行覆盖）</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">secondProcess</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 结束处理</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">end</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;结束处理&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>钩子方法</li>
</ul>
<p>在模板方法模式的抽象父类中，我们可以定义一个方法，它默认不做任何事，子类可以视情况覆盖它，该方法称为钩子方法。</p>
<h2 id="2、实现具体模板"><a href="#2、实现具体模板" class="headerlink" title="2、实现具体模板"></a>2、实现具体模板</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 工作流种类 A</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WorkFlowA</span> <span class="keyword">extends</span> <span class="title">WorkFlow</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">firstProcess</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;WorkFlowA 处理一级业务&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">secondProcess</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;WorkFlowA 处理二级业务&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 工作流种类 B</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WorkFlowB</span> <span class="keyword">extends</span> <span class="title">WorkFlow</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">firstProcess</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;WorkFlowB 处理一级业务&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3、测试"><a href="#3、测试" class="headerlink" title="3、测试"></a>3、测试</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TemplateClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        WorkFlow workFlowA = <span class="keyword">new</span> WorkFlowA();</span><br><span class="line">        WorkFlow workFlowB = <span class="keyword">new</span> WorkFlowB();</span><br><span class="line">        workFlowA.doWorkFlow();</span><br><span class="line">        workFlowB.doWorkFlow();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>1、多个子类有共有的方法，并且逻辑基本相同。</p>
<p>2、重要、复杂的算法，可以把核心算法设计为模板方法，周边的相关细节功能则由各个子类实现。</p>
<p>3、重构时，模板方法是一个经常使用的方法，把相同的代码抽取到父类中，然后通过构造函数约束其行为。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://mp.weixin.qq.com/s?__biz=MzAwNDA2OTM1Ng==&mid=2453152193&idx=1&sn=a0884e2c27c8031c8075464bf1047e95&chksm=8cfd0342bb8a8a54ba46609ab6e66a2d90059548f787c5c4ddc6a01bbcadf916d4e91e9fb92c&scene=178&cur_album_id=1761987817540206592#rd">模板方法  (qq.com)</a></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式——观察者模式</title>
    <url>/2021/09/27/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>定义对象之间的一对多依赖，当一个对象状态改变时，它的所有依赖都会收到通知并且自动更新状态。</p>
<p>主题（Subject）是被观察的对象，而其所有依赖者（Observer）称为观察者。</p>
<h2 id="类关系"><a href="#类关系" class="headerlink" title="类关系"></a>类关系</h2><p>主题（Subject）具有注册和移除观察者、并通知所有观察者的功能，主题是通过维护一张观察者列表来实现这些操作的。</p>
<p>观察者（Observer）的注册功能需要调用主题的 registerObserver() 方法。</p>
<h2 id="1、创建主题定义"><a href="#1、创建主题定义" class="headerlink" title="1、创建主题定义"></a>1、创建主题定义</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 订阅</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(EventListener eventListener)</span></span>;</span><br><span class="line">    <span class="comment">// 取消订阅</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unsubscribe</span><span class="params">(EventListener eventListener)</span></span>;</span><br><span class="line">    <span class="comment">// 通知观察者</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">notifyObserver</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2、定义具体主题"><a href="#2、定义具体主题" class="headerlink" title="2、定义具体主题"></a>2、定义具体主题</h2><p>创建主题的具体实现，并且构建一个容器来维护订阅关系，支持添加删除关系，以及通知订阅者。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteSubject</span> <span class="keyword">implements</span> <span class="title">Subject</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;EventListener&gt; observers = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;具体主题业务逻辑实现&quot;</span>);</span><br><span class="line">        notifyObserver();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(EventListener eventListener)</span> </span>&#123;</span><br><span class="line">        observers.add(eventListener);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unsubscribe</span><span class="params">(EventListener eventListener)</span> </span>&#123;</span><br><span class="line">        observers.remove(eventListener);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyObserver</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (EventListener eventListener : observers)&#123;</span><br><span class="line">            eventListener.doEvent();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3、定义观察者（事件监听者）"><a href="#3、定义观察者（事件监听者）" class="headerlink" title="3、定义观察者（事件监听者）"></a>3、定义观察者（事件监听者）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">EventListener</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 执行事件</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doEvent</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4、观察者实现"><a href="#4、观察者实现" class="headerlink" title="4、观察者实现"></a>4、观察者实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EventListenerImplA</span> <span class="keyword">implements</span> <span class="title">EventListener</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doEvent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;观察者 A 监听事件&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EventListenerImplB</span> <span class="keyword">implements</span> <span class="title">EventListener</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doEvent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;观察者 B 监听事件&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5、客户端测试"><a href="#5、客户端测试" class="headerlink" title="5、客户端测试"></a>5、客户端测试</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ConcreteSubject subject = <span class="keyword">new</span> ConcreteSubject();</span><br><span class="line">        subject.subscribe(<span class="keyword">new</span> EventListenerImplA());</span><br><span class="line">        subject.subscribe(<span class="keyword">new</span> EventListenerImplB());</span><br><span class="line">        subject.doSomething();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>一般在开发中会把主线流程开发完成后，再使用通知的方式处理辅助流程。他们可以是异步的，在MQ以及定时任务的处理下，保证最终一致性。</p>
<p><strong>观察者模式达到了解耦合的效果，减少了依赖关系，每个观察者根本不需要知道发布者处理了什么业务逻辑，也不用依赖发布者任何业务模型，只关心自己本身需要处理的逻辑就可以了。</strong></p>
<p>如果有新的业务添加进来，我们也只需要创建一个新的订阅者，并且维护到observers 容器中即可，也符合我们的开闭原则。</p>
<p>这里只是一种同步的实现方式，我们还可以扩展更多其他的异步实现方式，或者采用多线程等实现方式。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://mp.weixin.qq.com/s?__biz=MzAwNDA2OTM1Ng==&mid=2453152034&idx=1&sn=1e1db22c4a7cb2bfcc4a7ce141a9ef00&chksm=8cfd03a1bb8a8ab75c824b6866b1960485276f1dae410567d917bd0be71e4d071ab146e147cd&scene=178&cur_album_id=1761987817540206592#rd">观察者模式 (qq.com)</a></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>ElasticSearch、Kibana安装教程</title>
    <url>/2021/10/07/ElasticSearch%E3%80%81Kibana%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="初始ElasticSearch"><a href="#初始ElasticSearch" class="headerlink" title="初始ElasticSearch"></a>初始ElasticSearch</h2><h4 id="关于ES"><a href="#关于ES" class="headerlink" title="关于ES"></a>关于ES</h4><img src="https://gitee.com/KIMTOU/img/raw/master/20211007214537.svg" style="zoom:200%;" />

<p>Elasticsearch是一个基于Lucene的搜索引擎。适用于所有类型的数据，包括文本、数字、地理空间、结构化和非结构化数据。是一个分布式、RESTful 风格的搜索和数据分析引擎。</p>
<h4 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h4><p>下载网址：<a href="https://www.elastic.co/cn/elasticsearch/">https://www.elastic.co/cn/elasticsearch</a></p>
<p><img src="https://gitee.com/KIMTOU/img/raw/master/20211007214603.PNG"></p>
<h4 id="了解目录"><a href="#了解目录" class="headerlink" title="了解目录"></a>了解目录</h4><ul>
<li><p><code>bin</code>：启动文件</p>
</li>
<li><p><code>config</code>：配置文件</p>
</li>
<li><p><code>log4j2</code>：日志配置文件</p>
<ul>
<li><code>jvm.options</code>：java虚拟机相关配置</li>
<li><code>elasticsearch.yml</code>：elasticsearch的配置文件（默认端口：9200）</li>
</ul>
</li>
<li><p><code>lib</code>：相关jar包</p>
</li>
<li><p><code>logs</code>：日志</p>
</li>
<li><p><code>modules</code>：功能模块</p>
</li>
<li><p><code>plugins</code>：插件（比如 ik 分词器）</p>
</li>
</ul>
<h4 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h4><p>启动 <code>elasticsearch.bat</code>，并访问 <code>localhost:9200</code></p>
<p><strong>解决跨域：</strong></p>
<ul>
<li>打开 elasticsearch.yml（添加以下代码）</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">http.cors.enabled:</span> <span class="literal">true</span>				<span class="string">//开启跨域支持</span></span><br><span class="line"><span class="attr">http.cors.allow-origin:</span> <span class="string">&quot;*&quot;</span>			<span class="string">//允许所有访问</span></span><br></pre></td></tr></table></figure>



<h4 id="可视化插件-ES-head"><a href="#可视化插件-ES-head" class="headerlink" title="可视化插件 ES-head"></a>可视化插件 ES-head</h4><p>下载地址：<a href="https://github.com/mobz/elasticsearch-head">https://github.com/mobz/elasticsearch-head</a></p>
<p><img src="https://gitee.com/KIMTOU/img/raw/master/20211007214606.PNG"></p>
<ul>
<li><strong>下载相关依赖：</strong></li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">D:\Environment\ElasticSearch\elasticsearch-head-master&gt;cnpm install</span><br><span class="line"></span><br><span class="line">......</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>启动：</strong></li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">D:\Environment\ElasticSearch\elasticsearch-head-master&gt;npm run start</span><br></pre></td></tr></table></figure>

<ul>
<li>**访问 <code>localhost:9100</code>**，若点击页面没有反应，因为我们是使用9100端口连接9200端口，因为跨端口而出现的问题。解决跨域问题的方法参考文章前面。</li>
</ul>
<h2 id="初始Kibana"><a href="#初始Kibana" class="headerlink" title="初始Kibana"></a>初始Kibana</h2><h4 id="下载安装"><a href="#下载安装" class="headerlink" title="下载安装"></a>下载安装</h4><p>下载地址：<a href="https://www.elastic.co/cn/kibana/%EF%BC%88%E6%B3%A8%E6%84%8F%E8%A6%81%E4%B8%8Ees%E7%89%88%E6%9C%AC%E4%B8%80%E8%87%B4%EF%BC%89">https://www.elastic.co/cn/kibana/（注意要与es版本一致）</a></p>
<h4 id="启动-1"><a href="#启动-1" class="headerlink" title="启动"></a>启动</h4><p>打开 <code>kibana.bat</code></p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="regexp">//</span>启动失败可以尝试修改es的jvm选项，提升运行内存到<span class="number">2</span>g</span><br></pre></td></tr></table></figure>

<h4 id="访问测试"><a href="#访问测试" class="headerlink" title="访问测试"></a>访问测试</h4><p>访问：<code>localhost:5601</code>，之后所有操作都在 Dev Tools 进行</p>
<p><img src="https://gitee.com/KIMTOU/img/raw/master/20211007214608.PNG"></p>
<h4 id="汉化"><a href="#汉化" class="headerlink" title="汉化"></a>汉化</h4><p>打开 <code>kibana.yml</code>，修改为：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Specifies locale to be used for all localizable strings, dates and number formats.</span></span><br><span class="line"><span class="comment"># Supported languages are the following: English - en , by default , Chinese - zh-CN .</span></span><br><span class="line"><span class="comment">#i18n.locale: &quot;en&quot;</span></span><br><span class="line"><span class="attr">i18n.locale:</span> <span class="string">&quot;zh-CN&quot;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight taggerscript"><table><tr><td class="code"><pre><span class="line">汉化yml在</span><br><span class="line">D:<span class="symbol">\E</span>nvironment<span class="symbol">\E</span>lasticSearch<span class="symbol">\k</span>ibana-7.6.1-windows-x86_64<span class="symbol">\x</span>-pack<span class="symbol">\p</span>lugins<span class="symbol">\t</span>ranslations<span class="symbol">\t</span>ranslations</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>搜索引擎ElasticSearch</category>
      </categories>
      <tags>
        <tag>ElasticSearch</tag>
      </tags>
  </entry>
  <entry>
    <title>ElasticSearch入门实战</title>
    <url>/2021/10/07/ElasticSearch%E5%85%A5%E9%97%A8%E5%AE%9E%E6%88%98/</url>
    <content><![CDATA[<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h4 id="文档-Document"><a href="#文档-Document" class="headerlink" title="文档 Document"></a>文档 Document</h4><p><strong>Elasticsearch 是面向文档的，这意味着索引或搜索的最小数据单元是文档</strong>。</p>
<p>文档类似于关系数据库中的一行。不同之处在于索引中的每个文档可以具有不同的结构（字段），但是对于通用字段应该具有相同的数据类型。 MySQL =&gt; Databases =&gt;Tables =&gt; Columns / Rows， ElasticSearch =&gt; Indices =&gt; Types =&gt;具有属性的文档。</p>
<h4 id="类型-type"><a href="#类型-type" class="headerlink" title="类型 type"></a>类型 type</h4><p><strong>类型是文档的逻辑容器，类似于表格是行的容器</strong>。最好将不同结构的文档放入不同的类型中。</p>
<h4 id="索引-index"><a href="#索引-index" class="headerlink" title="索引 index"></a>索引 index</h4><p>索引是大量的文档集合。 每个索引存储在磁盘上的同组文件中，它有一个定义多种类型的映射，索引存储了所有映射类型的字段。</p>
<h4 id="分片-shard"><a href="#分片-shard" class="headerlink" title="分片 shard"></a>分片 shard</h4><p>由于Elasticsearch是一个分布式搜索引擎，因此索引通常会拆分为分布在多个节点上的称为分片的元素。</p>
<h2 id="IK分词器"><a href="#IK分词器" class="headerlink" title="IK分词器"></a>IK分词器</h2><h4 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h4><p>下载地址：<a href="https://github.com/medcl/elasticsearch-analysis-ik/releases">https://github.com/medcl/elasticsearch-analysis-ik/releases</a></p>
<h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p>将ik分词器的文件放入es目录下的plugins中的 ik 目录（ik目录由自己创建）。</p>
<h4 id="两种分词算法"><a href="#两种分词算法" class="headerlink" title="两种分词算法"></a>两种分词算法</h4><ul>
<li><strong>ik_smart：最粗粒度的拆分（最少切分）</strong></li>
</ul>
<figure class="highlight ada"><table><tr><td class="code"><pre><span class="line">GET _analyze</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;analyzer&quot;</span>: <span class="string">&quot;ik_smart&quot;</span>,</span><br><span class="line">  <span class="string">&quot;text&quot;</span>: <span class="string">&quot;一起滑雪吧&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;tokens&quot;</span> : [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">&quot;token&quot;</span> : &quot;一起&quot;,</span><br><span class="line">      <span class="string">&quot;start_offset&quot;</span> : 0,</span><br><span class="line">      <span class="string">&quot;end_offset&quot;</span> : 2,</span><br><span class="line">      <span class="string">&quot;type&quot;</span> : &quot;<span class="type">CN_WORD</span><span class="string">&quot;,</span></span><br><span class="line"><span class="string">      &quot;</span>position<span class="string">&quot; : 0</span></span><br><span class="line"><span class="string">    &#125;,</span></span><br><span class="line"><span class="string">    &#123;</span></span><br><span class="line"><span class="string">      &quot;</span>token<span class="string">&quot; : &quot;</span>滑雪<span class="string">&quot;,</span></span><br><span class="line"><span class="string">      &quot;</span>start_offset<span class="string">&quot; : 2,</span></span><br><span class="line"><span class="string">      &quot;</span>end_offset<span class="string">&quot; : 4,</span></span><br><span class="line"><span class="string">      &quot;</span><span class="keyword">type</span><span class="string">&quot; : &quot;</span>CN_WORD<span class="string">&quot;,</span></span><br><span class="line"><span class="string">      &quot;</span>position<span class="string">&quot; : 1</span></span><br><span class="line"><span class="string">    &#125;,</span></span><br><span class="line"><span class="string">    &#123;</span></span><br><span class="line"><span class="string">      &quot;</span>token<span class="string">&quot; : &quot;</span>吧<span class="string">&quot;,</span></span><br><span class="line"><span class="string">      &quot;</span>start_offset<span class="string">&quot; : 4,</span></span><br><span class="line"><span class="string">      &quot;</span>end_offset<span class="string">&quot; : 5,</span></span><br><span class="line"><span class="string">      &quot;</span><span class="keyword">type</span><span class="string">&quot; : &quot;</span>CN_CHAR<span class="string">&quot;,</span></span><br><span class="line"><span class="string">      &quot;</span>position<span class="string">&quot; : 2</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">  ]</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>ik_max_word：最细粒度划分（穷尽词库的可能）</strong></li>
</ul>
<figure class="highlight ada"><table><tr><td class="code"><pre><span class="line">GET _analyze</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;analyzer&quot;</span>: <span class="string">&quot;ik_max_word&quot;</span>,</span><br><span class="line">  <span class="string">&quot;text&quot;</span>: <span class="string">&quot;一起滑雪吧&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;tokens&quot;</span> : [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">&quot;token&quot;</span> : &quot;一起&quot;,</span><br><span class="line">      <span class="string">&quot;start_offset&quot;</span> : 0,</span><br><span class="line">      <span class="string">&quot;end_offset&quot;</span> : 2,</span><br><span class="line">      <span class="string">&quot;type&quot;</span> : &quot;<span class="type">CN_WORD</span><span class="string">&quot;,</span></span><br><span class="line"><span class="string">      &quot;</span>position<span class="string">&quot; : 0</span></span><br><span class="line"><span class="string">    &#125;,</span></span><br><span class="line"><span class="string">    &#123;</span></span><br><span class="line"><span class="string">      &quot;</span>token<span class="string">&quot; : &quot;</span>一<span class="string">&quot;,</span></span><br><span class="line"><span class="string">      &quot;</span>start_offset<span class="string">&quot; : 0,</span></span><br><span class="line"><span class="string">      &quot;</span>end_offset<span class="string">&quot; : 1,</span></span><br><span class="line"><span class="string">      &quot;</span><span class="keyword">type</span><span class="string">&quot; : &quot;</span>TYPE_CNUM<span class="string">&quot;,</span></span><br><span class="line"><span class="string">      &quot;</span>position<span class="string">&quot; : 1</span></span><br><span class="line"><span class="string">    &#125;,</span></span><br><span class="line"><span class="string">    &#123;</span></span><br><span class="line"><span class="string">      &quot;</span>token<span class="string">&quot; : &quot;</span>起<span class="string">&quot;,</span></span><br><span class="line"><span class="string">      &quot;</span>start_offset<span class="string">&quot; : 1,</span></span><br><span class="line"><span class="string">      &quot;</span>end_offset<span class="string">&quot; : 2,</span></span><br><span class="line"><span class="string">      &quot;</span><span class="keyword">type</span><span class="string">&quot; : &quot;</span>COUNT<span class="string">&quot;,</span></span><br><span class="line"><span class="string">      &quot;</span>position<span class="string">&quot; : 2</span></span><br><span class="line"><span class="string">    &#125;,</span></span><br><span class="line"><span class="string">    &#123;</span></span><br><span class="line"><span class="string">      &quot;</span>token<span class="string">&quot; : &quot;</span>滑雪<span class="string">&quot;,</span></span><br><span class="line"><span class="string">      &quot;</span>start_offset<span class="string">&quot; : 2,</span></span><br><span class="line"><span class="string">      &quot;</span>end_offset<span class="string">&quot; : 4,</span></span><br><span class="line"><span class="string">      &quot;</span><span class="keyword">type</span><span class="string">&quot; : &quot;</span>CN_WORD<span class="string">&quot;,</span></span><br><span class="line"><span class="string">      &quot;</span>position<span class="string">&quot; : 3</span></span><br><span class="line"><span class="string">    &#125;,</span></span><br><span class="line"><span class="string">    &#123;</span></span><br><span class="line"><span class="string">      &quot;</span>token<span class="string">&quot; : &quot;</span>吧<span class="string">&quot;,</span></span><br><span class="line"><span class="string">      &quot;</span>start_offset<span class="string">&quot; : 4,</span></span><br><span class="line"><span class="string">      &quot;</span>end_offset<span class="string">&quot; : 5,</span></span><br><span class="line"><span class="string">      &quot;</span><span class="keyword">type</span><span class="string">&quot; : &quot;</span>CN_CHAR<span class="string">&quot;,</span></span><br><span class="line"><span class="string">      &quot;</span>position<span class="string">&quot; : 4</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">  ]</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>



<h4 id="扩展词典"><a href="#扩展词典" class="headerlink" title="扩展词典"></a>扩展词典</h4><p>有些词未存在词典中，需要我们自己去扩展</p>
<figure class="highlight ada"><table><tr><td class="code"><pre><span class="line">GET _analyze</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;analyzer&quot;</span>: <span class="string">&quot;ik_smart&quot;</span>,</span><br><span class="line">  <span class="string">&quot;text&quot;</span>: <span class="string">&quot;计算机组成原理&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;tokens&quot;</span> : [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">&quot;token&quot;</span> : &quot;计算机&quot;,</span><br><span class="line">      <span class="string">&quot;start_offset&quot;</span> : 0,</span><br><span class="line">      <span class="string">&quot;end_offset&quot;</span> : 3,</span><br><span class="line">      <span class="string">&quot;type&quot;</span> : &quot;<span class="type">CN_WORD</span><span class="string">&quot;,</span></span><br><span class="line"><span class="string">      &quot;</span>position<span class="string">&quot; : 0</span></span><br><span class="line"><span class="string">    &#125;,</span></span><br><span class="line"><span class="string">    &#123;</span></span><br><span class="line"><span class="string">      &quot;</span>token<span class="string">&quot; : &quot;</span>组成<span class="string">&quot;,</span></span><br><span class="line"><span class="string">      &quot;</span>start_offset<span class="string">&quot; : 3,</span></span><br><span class="line"><span class="string">      &quot;</span>end_offset<span class="string">&quot; : 5,</span></span><br><span class="line"><span class="string">      &quot;</span><span class="keyword">type</span><span class="string">&quot; : &quot;</span>CN_WORD<span class="string">&quot;,</span></span><br><span class="line"><span class="string">      &quot;</span>position<span class="string">&quot; : 1</span></span><br><span class="line"><span class="string">    &#125;,</span></span><br><span class="line"><span class="string">    &#123;</span></span><br><span class="line"><span class="string">      &quot;</span>token<span class="string">&quot; : &quot;</span>原理<span class="string">&quot;,</span></span><br><span class="line"><span class="string">      &quot;</span>start_offset<span class="string">&quot; : 5,</span></span><br><span class="line"><span class="string">      &quot;</span>end_offset<span class="string">&quot; : 7,</span></span><br><span class="line"><span class="string">      &quot;</span><span class="keyword">type</span><span class="string">&quot; : &quot;</span>CN_WORD<span class="string">&quot;,</span></span><br><span class="line"><span class="string">      &quot;</span>position<span class="string">&quot; : 2</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">  ]</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure>

<p>“计算机组成原理” 作为一个学科，本应是一个完整的词，不过词典中没有，需要我们手动添加进词典。</p>
<p><strong>解决：</strong></p>
<ul>
<li>打开ik下config目录下的 <strong>IKAnalyzer.cfg.xml</strong></li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">properties</span> <span class="meta-keyword">SYSTEM</span> <span class="meta-string">&quot;http://java.sun.com/dtd/properties.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">comment</span>&gt;</span>IK Analyzer 扩展配置<span class="tag">&lt;/<span class="name">comment</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!--用户可以在这里配置自己的扩展字典 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;ext_dict&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line">	 <span class="comment">&lt;!--用户可以在这里配置自己的扩展停止词字典--&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;ext_stopwords&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!--用户可以在这里配置远程扩展字典 --&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- &lt;entry key=&quot;remote_ext_dict&quot;&gt;words_location&lt;/entry&gt; --&gt;</span></span><br><span class="line">	<span class="comment">&lt;!--用户可以在这里配置远程扩展停止词字典--&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- &lt;entry key=&quot;remote_ext_stopwords&quot;&gt;words_location&lt;/entry&gt; --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>创建自己的词典：<ul>
<li>新建dic文件（mydic.dic），将 “计算机组成原理” 添加进去</li>
<li><strong>注意：使用UTF-8保存</strong></li>
</ul>
</li>
<li>配置IKAnalyzer.cfg.xml</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--用户可以在这里配置自己的扩展字典 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;ext_dict&quot;</span>&gt;</span>mydic.dic<span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line"> <span class="comment">&lt;!--用户可以在这里配置自己的扩展停止词字典--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;ext_stopwords&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>重启es</li>
</ul>
<h2 id="Restful风格操作"><a href="#Restful风格操作" class="headerlink" title="Restful风格操作"></a>Restful风格操作</h2><h4 id="索引操作"><a href="#索引操作" class="headerlink" title="索引操作"></a>索引操作</h4><ol>
<li><h5 id="创建一个索引"><a href="#创建一个索引" class="headerlink" title="创建一个索引"></a><strong>创建一个索引</strong></h5></li>
</ol>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">PUT <span class="regexp">/索引名/</span>类型名/文档id			(类型名未来不用)</span><br><span class="line">&#123;请求体&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>测试</li>
</ul>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">PUT <span class="regexp">/test1/</span>type1/<span class="number">1</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;name&quot;</span>: <span class="string">&quot;SpringBoot&quot;</span>,</span><br><span class="line">  <span class="string">&quot;age&quot;</span>: <span class="number">123</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>创建规则（即手动加规则，否则将自动生成规则）</li>
</ul>
<figure class="highlight dts"><table><tr><td class="code"><pre><span class="line">PUT /test2</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;mappings&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;properties&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;name&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;type&quot;</span>: <span class="string">&quot;text&quot;</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="string">&quot;age&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;type&quot;</span>: <span class="string">&quot;long&quot;</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="string">&quot;birthday&quot;</span> :&#123;</span><br><span class="line">        <span class="string">&quot;type&quot;</span>: <span class="string">&quot;date&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>查看具体信息</li>
</ul>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line"><span class="builtin-name">GET</span> test2</span><br></pre></td></tr></table></figure>

<ul>
<li>查看默认信息</li>
</ul>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">PUT <span class="regexp">/test3/</span>_doc/<span class="number">1</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;name&quot;</span>: <span class="string">&quot;柠檬茶&quot;</span>,</span><br><span class="line">  <span class="string">&quot;age&quot;</span>: <span class="number">12</span>,</span><br><span class="line">  <span class="string">&quot;birthday&quot;</span>: <span class="string">&quot;2020-11-11&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">GET test3</span><br></pre></td></tr></table></figure>

<ul>
<li>拓展</li>
</ul>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line"><span class="builtin-name">GET</span> _cat/indices?v				查看各索引信息</span><br></pre></td></tr></table></figure>



<ol start="3">
<li><h5 id="修改"><a href="#修改" class="headerlink" title="修改"></a><strong>修改</strong></h5></li>
</ol>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">POST <span class="regexp">/test3/</span>_doc<span class="regexp">/1/</span>_update</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;doc&quot;</span>:&#123;</span><br><span class="line">    <span class="string">&quot;name&quot;</span>: <span class="string">&quot;法外狂徒张三&quot;</span>				<span class="regexp">//</span>将柠檬茶修改</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ol start="4">
<li><h5 id="删除"><a href="#删除" class="headerlink" title="删除"></a><strong>删除</strong></h5></li>
</ol>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="regexp">/test3/</span>_doc/<span class="number">1</span>			删除文档</span><br><span class="line"><span class="keyword">DELETE</span> /test3					删除索引</span><br></pre></td></tr></table></figure>



<h4 id="文档操作"><a href="#文档操作" class="headerlink" title="文档操作"></a>文档操作</h4><ol>
<li><h5 id="添加数据"><a href="#添加数据" class="headerlink" title="添加数据"></a>添加数据</h5></li>
</ol>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT /mine/user/1</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;Kim&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;age&quot;</span>: <span class="number">20</span>,</span><br><span class="line">  <span class="attr">&quot;hobbit&quot;</span>: [<span class="string">&quot;篮球&quot;</span>,<span class="string">&quot;技术&quot;</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PUT /mine/user/3</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;李四&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;age&quot;</span>: <span class="number">33</span>,</span><br><span class="line">  <span class="attr">&quot;hobbit&quot;</span>: [<span class="string">&quot;战斗&quot;</span>,<span class="string">&quot;飞行&quot;</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><h5 id="获取数据-GET"><a href="#获取数据-GET" class="headerlink" title="获取数据 GET"></a>获取数据 GET</h5></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">GET mine/user/<span class="number">3</span></span><br></pre></td></tr></table></figure>

<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;_index&quot;</span> : <span class="string">&quot;mine&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;_type&quot;</span> : <span class="string">&quot;user&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;_id&quot;</span> : <span class="string">&quot;3&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;_version&quot;</span> : <span class="number">1</span>,</span><br><span class="line">  <span class="attr">&quot;_seq_no&quot;</span> : <span class="number">2</span>,</span><br><span class="line">  <span class="attr">&quot;_primary_term&quot;</span> : <span class="number">1</span>,</span><br><span class="line">  <span class="attr">&quot;found&quot;</span> : <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">&quot;_source&quot;</span> : &#123;</span><br><span class="line">    <span class="attr">&quot;name&quot;</span> : <span class="string">&quot;李四&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;age&quot;</span> : <span class="number">33</span>,</span><br><span class="line">    <span class="attr">&quot;hobbit&quot;</span> : [</span><br><span class="line">      <span class="string">&quot;战斗&quot;</span>,</span><br><span class="line">      <span class="string">&quot;飞行&quot;</span></span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><h5 id="更新数据-PUT-POST（推荐）"><a href="#更新数据-PUT-POST（推荐）" class="headerlink" title="更新数据 PUT / POST（推荐）"></a>更新数据 PUT / POST（推荐）</h5></li>
</ol>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT /mine/user/3</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;李四233&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;age&quot;</span>: <span class="number">33</span>,</span><br><span class="line">  <span class="attr">&quot;hobbit&quot;</span>: [<span class="string">&quot;战斗&quot;</span>,<span class="string">&quot;飞行&quot;</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">POST /mine/user/3/_update					若少掉/_update，则跟PUT一样</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;doc&quot;</span>:&#123;</span><br><span class="line">    <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;我是Kim，不是李四&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>区别：PUT需要完整信息，否则会置空</li>
</ul>
<ol start="4">
<li><h5 id="简单查询"><a href="#简单查询" class="headerlink" title="简单查询"></a>简单查询</h5></li>
</ol>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">GET mine<span class="regexp">/user/</span><span class="number">3</span></span><br></pre></td></tr></table></figure>

<ol start="5">
<li><h5 id="简单条件查询"><a href="#简单条件查询" class="headerlink" title="简单条件查询"></a>简单条件查询</h5></li>
</ol>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line"><span class="builtin-name">GET</span> mine/user/_search?<span class="attribute">q</span>=name:Kim</span><br></pre></td></tr></table></figure>



<h5 id="复杂查询"><a href="#复杂查询" class="headerlink" title="复杂查询"></a>复杂查询</h5><ol>
<li><h5 id="精准匹配"><a href="#精准匹配" class="headerlink" title="精准匹配"></a>精准匹配</h5></li>
</ol>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET mine/user/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;query&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;match&quot;</span>: &#123;		</span><br><span class="line">      <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;Kim&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>查询结果</li>
</ul>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;took&quot;</span> : <span class="number">2</span>,</span><br><span class="line">  <span class="attr">&quot;timed_out&quot;</span> : <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">&quot;_shards&quot;</span> : &#123;</span><br><span class="line">    <span class="attr">&quot;total&quot;</span> : <span class="number">1</span>,</span><br><span class="line">    <span class="attr">&quot;successful&quot;</span> : <span class="number">1</span>,</span><br><span class="line">    <span class="attr">&quot;skipped&quot;</span> : <span class="number">0</span>,</span><br><span class="line">    <span class="attr">&quot;failed&quot;</span> : <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;hits&quot;</span> : &#123;						<span class="comment">//命中</span></span><br><span class="line">    <span class="attr">&quot;total&quot;</span> : &#123;</span><br><span class="line">      <span class="attr">&quot;value&quot;</span> : <span class="number">2</span>,</span><br><span class="line">      <span class="attr">&quot;relation&quot;</span> : <span class="string">&quot;eq&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;max_score&quot;</span> : <span class="number">0.93710405</span>,		<span class="comment">//最大权重</span></span><br><span class="line">    <span class="attr">&quot;hits&quot;</span> : [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">&quot;_index&quot;</span> : <span class="string">&quot;mine&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;_type&quot;</span> : <span class="string">&quot;user&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;_id&quot;</span> : <span class="string">&quot;1&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;_score&quot;</span> : <span class="number">0.93710405</span>,</span><br><span class="line">        <span class="attr">&quot;_source&quot;</span> : &#123;				<span class="comment">//未指定source，默认全部</span></span><br><span class="line">          <span class="attr">&quot;name&quot;</span> : <span class="string">&quot;Kim&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;age&quot;</span> : <span class="number">20</span>,</span><br><span class="line">          <span class="attr">&quot;hobbit&quot;</span> : [</span><br><span class="line">            <span class="string">&quot;篮球&quot;</span>,</span><br><span class="line">            <span class="string">&quot;技术&quot;</span></span><br><span class="line">          ]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">&quot;_index&quot;</span> : <span class="string">&quot;mine&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;_type&quot;</span> : <span class="string">&quot;user&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;_id&quot;</span> : <span class="string">&quot;3&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;_score&quot;</span> : <span class="number">0.42466223</span>,</span><br><span class="line">        <span class="attr">&quot;_source&quot;</span> : &#123;</span><br><span class="line">          <span class="attr">&quot;name&quot;</span> : <span class="string">&quot;我是Kim，不是李四&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;age&quot;</span> : <span class="number">33</span>,</span><br><span class="line">          <span class="attr">&quot;hobbit&quot;</span> : [</span><br><span class="line">            <span class="string">&quot;战斗&quot;</span>,</span><br><span class="line">            <span class="string">&quot;飞行&quot;</span></span><br><span class="line">          ]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><h5 id="过滤结果"><a href="#过滤结果" class="headerlink" title="过滤结果"></a>过滤结果</h5></li>
</ol>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET mine/user/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;query&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;match&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;Kim&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;_source&quot;</span>: [<span class="string">&quot;name&quot;</span>,<span class="string">&quot;age&quot;</span>]					<span class="comment">//输出字段</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><h5 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h5></li>
</ol>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET mine/user/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;query&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;match&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;Kim&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;sort&quot;</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;age&quot;</span>: &#123;						<span class="comment">//通过age字段来排序</span></span><br><span class="line">        <span class="attr">&quot;order&quot;</span>: <span class="string">&quot;desc&quot;</span>				<span class="comment">//desc为降序；升序为asc</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><h5 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a><strong>分页查询</strong></h5></li>
</ol>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET mine/user/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;query&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;match&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;Kim&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;sort&quot;</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;age&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;order&quot;</span>: <span class="string">&quot;asc&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">&quot;from&quot;</span>: <span class="number">0</span>,					<span class="comment">//从第几条数据开始</span></span><br><span class="line">  <span class="attr">&quot;size&quot;</span>: <span class="number">1</span>						<span class="comment">//返回多少条数据（单页面数据大小）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li><h5 id="布尔值查询"><a href="#布尔值查询" class="headerlink" title="布尔值查询"></a>布尔值查询</h5></li>
</ol>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET mine/user/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;query&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;bool&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;must&quot;</span>: [							<span class="comment">//must相当于and</span></span><br><span class="line">        &#123;								<span class="comment">//使用should则相当于or，即多条件中符合其中一个就行</span></span><br><span class="line">          <span class="attr">&quot;match&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;Kim&quot;</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,								<span class="comment">//多条件精确查询</span></span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">&quot;match&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;age&quot;</span>: <span class="number">20</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET mine/user/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;query&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;bool&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;must_not&quot;</span>: [						<span class="comment">//must_not：除去字段相匹配的数据</span></span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">&quot;match&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;Kim&quot;</span>		</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET mine/user/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;query&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;bool&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;must&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">&quot;match&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;Kim&quot;</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ],</span><br><span class="line">      <span class="attr">&quot;filter&quot;</span>: &#123;					<span class="comment">//过滤</span></span><br><span class="line">        <span class="attr">&quot;range&quot;</span>: &#123;					<span class="comment">//范围过滤</span></span><br><span class="line">          <span class="attr">&quot;age&quot;</span>: &#123;					<span class="comment">//通过age字段进行过滤</span></span><br><span class="line">            <span class="attr">&quot;gt&quot;</span>: <span class="number">10</span>,				<span class="comment">//大于10</span></span><br><span class="line">            <span class="attr">&quot;lte&quot;</span>: <span class="number">20</span>				<span class="comment">//小于等于20</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="6">
<li><h5 id="匹配多个条件"><a href="#匹配多个条件" class="headerlink" title="匹配多个条件"></a>匹配多个条件</h5></li>
</ol>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET mine/user/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;query&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;match&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;hobbit&quot;</span>: <span class="string">&quot;技术 音&quot;</span>					<span class="comment">//多个条件使用空格隔开</span></span><br><span class="line">    &#125;									  <span class="comment">//只要满足其中一个结果就可以查出</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="两种类型text与keyword"><a href="#两种类型text与keyword" class="headerlink" title="两种类型text与keyword"></a>两种类型text与keyword</h5><ul>
<li>创建信息<strong>（name用text，desc用keyword）</strong></li>
</ul>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT testdb</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;mappings&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;properties&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;name&quot;</span>:&#123;</span><br><span class="line">        <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;text&quot;</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">&quot;desc&quot;</span>:&#123;</span><br><span class="line">        <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;keyword&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PUT /testdb/_doc/1</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;狂神说java name&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;desc&quot;</span>: <span class="string">&quot;狂神说java desc&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PUT /testdb/_doc/2</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;狂神说java name&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;desc&quot;</span>: <span class="string">&quot;狂神说java desc2&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>测试</li>
</ul>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET _analyze</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;analyzer&quot;</span>: <span class="string">&quot;keyword&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;text&quot;</span>: <span class="string">&quot;狂神说java name&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">===============测试结果====================</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;tokens&quot;</span> : [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;token&quot;</span> : <span class="string">&quot;狂神说java name&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;start_offset&quot;</span> : <span class="number">0</span>,</span><br><span class="line">      <span class="attr">&quot;end_offset&quot;</span> : <span class="number">12</span>,</span><br><span class="line">      <span class="attr">&quot;type&quot;</span> : <span class="string">&quot;word&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;position&quot;</span> : <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET _analyze</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;analyzer&quot;</span>: <span class="string">&quot;standard&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;text&quot;</span>: <span class="string">&quot;狂神说java name&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">===============测试结果====================</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;tokens&quot;</span> : [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;token&quot;</span> : <span class="string">&quot;狂&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;start_offset&quot;</span> : <span class="number">0</span>,</span><br><span class="line">      <span class="attr">&quot;end_offset&quot;</span> : <span class="number">1</span>,</span><br><span class="line">      <span class="attr">&quot;type&quot;</span> : <span class="string">&quot;&lt;IDEOGRAPHIC&gt;&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;position&quot;</span> : <span class="number">0</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;token&quot;</span> : <span class="string">&quot;神&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;start_offset&quot;</span> : <span class="number">1</span>,</span><br><span class="line">      <span class="attr">&quot;end_offset&quot;</span> : <span class="number">2</span>,</span><br><span class="line">      <span class="attr">&quot;type&quot;</span> : <span class="string">&quot;&lt;IDEOGRAPHIC&gt;&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;position&quot;</span> : <span class="number">1</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;token&quot;</span> : <span class="string">&quot;说&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;start_offset&quot;</span> : <span class="number">2</span>,</span><br><span class="line">      <span class="attr">&quot;end_offset&quot;</span> : <span class="number">3</span>,</span><br><span class="line">      <span class="attr">&quot;type&quot;</span> : <span class="string">&quot;&lt;IDEOGRAPHIC&gt;&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;position&quot;</span> : <span class="number">2</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;token&quot;</span> : <span class="string">&quot;java&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;start_offset&quot;</span> : <span class="number">3</span>,</span><br><span class="line">      <span class="attr">&quot;end_offset&quot;</span> : <span class="number">7</span>,</span><br><span class="line">      <span class="attr">&quot;type&quot;</span> : <span class="string">&quot;&lt;ALPHANUM&gt;&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;position&quot;</span> : <span class="number">3</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;token&quot;</span> : <span class="string">&quot;name&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;start_offset&quot;</span> : <span class="number">8</span>,</span><br><span class="line">      <span class="attr">&quot;end_offset&quot;</span> : <span class="number">12</span>,</span><br><span class="line">      <span class="attr">&quot;type&quot;</span> : <span class="string">&quot;&lt;ALPHANUM&gt;&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;position&quot;</span> : <span class="number">4</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>总结：keyword不会被分析，而默认的standard则会被拆分</strong></li>
</ul>
<ol start="7">
<li><h5 id="精确查询"><a href="#精确查询" class="headerlink" title="精确查询"></a>精确查询</h5></li>
</ol>
<p>term查询将按照存储在倒排索引中的确切字词进行操作</p>
<ul>
<li><p><strong>term是代表完全匹配，即不进行分词器分析关键字，文档中必须包含整个搜索的词汇</strong></p>
</li>
<li><p>match和term的区别是，match查询的时候，elasticsearch会使用分词器，而term查询不会使用分词器</p>
<p><strong>match查询相当于模糊匹配，只包含关键字其中一部分关键词就行</strong></p>
</li>
</ul>
<ul>
<li>测试1</li>
</ul>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET testdb/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;query&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;term&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;name&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;value&quot;</span>: <span class="string">&quot;狂&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">===============测试结果====================</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;took&quot;</span> : <span class="number">321</span>,</span><br><span class="line">  <span class="attr">&quot;timed_out&quot;</span> : <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">&quot;_shards&quot;</span> : &#123;</span><br><span class="line">    <span class="attr">&quot;total&quot;</span> : <span class="number">1</span>,</span><br><span class="line">    <span class="attr">&quot;successful&quot;</span> : <span class="number">1</span>,</span><br><span class="line">    <span class="attr">&quot;skipped&quot;</span> : <span class="number">0</span>,</span><br><span class="line">    <span class="attr">&quot;failed&quot;</span> : <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;hits&quot;</span> : &#123;</span><br><span class="line">    <span class="attr">&quot;total&quot;</span> : &#123;</span><br><span class="line">      <span class="attr">&quot;value&quot;</span> : <span class="number">2</span>,</span><br><span class="line">      <span class="attr">&quot;relation&quot;</span> : <span class="string">&quot;eq&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;max_score&quot;</span> : <span class="number">0.45665967</span>,</span><br><span class="line">    <span class="attr">&quot;hits&quot;</span> : [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">&quot;_index&quot;</span> : <span class="string">&quot;testdb&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;_type&quot;</span> : <span class="string">&quot;_doc&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;_id&quot;</span> : <span class="string">&quot;1&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;_score&quot;</span> : <span class="number">0.45665967</span>,</span><br><span class="line">        <span class="attr">&quot;_source&quot;</span> : &#123;</span><br><span class="line">          <span class="attr">&quot;name&quot;</span> : <span class="string">&quot;狂神说java name&quot;</span>,						<span class="comment">//只要名字中带有“狂”的都可以</span></span><br><span class="line">          <span class="attr">&quot;desc&quot;</span> : <span class="string">&quot;狂神说java desc&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">&quot;_index&quot;</span> : <span class="string">&quot;testdb&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;_type&quot;</span> : <span class="string">&quot;_doc&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;_id&quot;</span> : <span class="string">&quot;2&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;_score&quot;</span> : <span class="number">0.45665967</span>,</span><br><span class="line">        <span class="attr">&quot;_source&quot;</span> : &#123;</span><br><span class="line">          <span class="attr">&quot;name&quot;</span> : <span class="string">&quot;狂神说java name&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;desc&quot;</span> : <span class="string">&quot;狂神说java desc2&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>测试2</li>
</ul>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET testdb/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;query&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;term&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;desc&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;value&quot;</span>: <span class="string">&quot;狂神说java desc&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">===============测试结果====================</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;took&quot;</span> : <span class="number">0</span>,</span><br><span class="line">  <span class="attr">&quot;timed_out&quot;</span> : <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">&quot;_shards&quot;</span> : &#123;</span><br><span class="line">    <span class="attr">&quot;total&quot;</span> : <span class="number">1</span>,</span><br><span class="line">    <span class="attr">&quot;successful&quot;</span> : <span class="number">1</span>,</span><br><span class="line">    <span class="attr">&quot;skipped&quot;</span> : <span class="number">0</span>,</span><br><span class="line">    <span class="attr">&quot;failed&quot;</span> : <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;hits&quot;</span> : &#123;</span><br><span class="line">    <span class="attr">&quot;total&quot;</span> : &#123;</span><br><span class="line">      <span class="attr">&quot;value&quot;</span> : <span class="number">1</span>,</span><br><span class="line">      <span class="attr">&quot;relation&quot;</span> : <span class="string">&quot;eq&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;max_score&quot;</span> : <span class="number">0.9808291</span>,</span><br><span class="line">    <span class="attr">&quot;hits&quot;</span> : [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">&quot;_index&quot;</span> : <span class="string">&quot;testdb&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;_type&quot;</span> : <span class="string">&quot;_doc&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;_id&quot;</span> : <span class="string">&quot;1&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;_score&quot;</span> : <span class="number">0.9808291</span>,</span><br><span class="line">        <span class="attr">&quot;_source&quot;</span> : &#123;</span><br><span class="line">          <span class="attr">&quot;name&quot;</span> : <span class="string">&quot;狂神说java name&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;desc&quot;</span> : <span class="string">&quot;狂神说java desc&quot;</span>			 			<span class="comment">//只有一个了</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>原因分析：name使用的是text，所以会被分词器解析；desc用的是keyword，所以必须完全匹配</strong></li>
</ul>
<ol start="8">
<li><h5 id="多个值匹配的精确查询"><a href="#多个值匹配的精确查询" class="headerlink" title="多个值匹配的精确查询"></a>多个值匹配的精确查询</h5></li>
</ol>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET testdb/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;query&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;bool&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;should&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">&quot;term&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;t1&quot;</span>: &#123;</span><br><span class="line">              <span class="attr">&quot;value&quot;</span>: <span class="string">&quot;22&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">&quot;term&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;t1&quot;</span>: <span class="string">&quot;33&quot;</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ol start="9">
<li><h5 id="高亮查询"><a href="#高亮查询" class="headerlink" title="高亮查询"></a>高亮查询</h5></li>
</ol>
<ul>
<li>让name字段为Kim的高亮</li>
</ul>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET mine/user/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;query&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;match&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;Kim&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;highlight&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;fields&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;name&quot;</span>:&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>结果</li>
</ul>
<figure class="highlight ada"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;highlight&quot;</span> : &#123;</span><br><span class="line">          <span class="string">&quot;name&quot;</span> : [</span><br><span class="line">            <span class="string">&quot;&lt;em&gt;Kim&lt;/em&gt;&quot;</span></span><br><span class="line">          ]</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>此时使用<em>标签包裹起来，也可以自己修改</li>
</ul>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET mine/user/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;query&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;match&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;Kim&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;highlight&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;pre_tags&quot;</span>: <span class="string">&quot;&lt;p class=&#x27;key&#x27; style=&#x27;color:red&#x27;&gt;&quot;</span>,			<span class="comment">//前缀</span></span><br><span class="line">    <span class="attr">&quot;post_tags&quot;</span>: <span class="string">&quot;&lt;/p&gt;&quot;</span>, 										<span class="comment">//后缀</span></span><br><span class="line">    <span class="attr">&quot;fields&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;name&quot;</span>:&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>结果</li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&quot;highlight&quot; : &#123;</span><br><span class="line">          &quot;name&quot; : [</span><br><span class="line">            <span class="string">&quot;&lt;p class=&#x27;key&#x27; style=&#x27;color:red&#x27;&gt;Kim&lt;/p&gt;&quot;</span></span><br><span class="line">          ]</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>



<h2 id="集成SpringBoot"><a href="#集成SpringBoot" class="headerlink" title="集成SpringBoot"></a>集成SpringBoot</h2><ul>
<li>Maven原生依赖</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.elasticsearch.client<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>elasticsearch-rest-high-level-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>7.6.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>初始化</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">RestHighLevelClient client = <span class="keyword">new</span> RestHighLevelClient(</span><br><span class="line">        RestClient.builder(</span><br><span class="line">                <span class="keyword">new</span> HttpHost(<span class="string">&quot;localhost&quot;</span>, <span class="number">9200</span>, <span class="string">&quot;http&quot;</span>),</span><br><span class="line">                <span class="keyword">new</span> HttpHost(<span class="string">&quot;localhost&quot;</span>, <span class="number">9201</span>, <span class="string">&quot;http&quot;</span>)));</span><br></pre></td></tr></table></figure>

<ul>
<li>关闭客户端</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">client.close();</span><br></pre></td></tr></table></figure>



<h4 id="使用模板"><a href="#使用模板" class="headerlink" title="使用模板"></a>使用模板</h4><ol>
<li><p>创建SpringBoot项目并选中NoSQL中的ElasticSearch模块</p>
</li>
<li><p>下载下来springboot版本与es版本不一致，需要自己定义es版本依赖，保证和本地一致</p>
</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.5.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> </span><br><span class="line">   <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.Kim<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>es-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">name</span>&gt;</span>es-api<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">description</span>&gt;</span>Demo project for Spring Boot<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">       </span><br><span class="line">       <span class="comment">&lt;!--自己定义es版本依赖，保证和本地一致--&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">elasticsearch.version</span>&gt;</span>7.6.1<span class="tag">&lt;/<span class="name">elasticsearch.version</span>&gt;</span></span><br><span class="line">       </span><br><span class="line">   <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>创建ElasticSearchClientConfig.java</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ElasticSearchClientConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RestHighLevelClient <span class="title">restHighLevelClient</span><span class="params">()</span></span>&#123;</span><br><span class="line">        RestHighLevelClient client = <span class="keyword">new</span> RestHighLevelClient(</span><br><span class="line">                RestClient.builder(</span><br><span class="line">                        <span class="keyword">new</span> HttpHost(<span class="string">&quot;localhost&quot;</span>, <span class="number">9200</span>, <span class="string">&quot;http&quot;</span>)));</span><br><span class="line">        <span class="keyword">return</span> client;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="Api测试"><a href="#Api测试" class="headerlink" title="Api测试"></a>Api测试</h4><h5 id="索引操作-1"><a href="#索引操作-1" class="headerlink" title="索引操作"></a>索引操作</h5><ul>
<li>在测试类中创建对象</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> RestHighLevelClient restHighLevelClient;</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="meta">@Qualifier(&quot;restHighLevelClient&quot;)</span></span><br><span class="line"><span class="keyword">private</span> RestHighLevelClient client;</span><br></pre></td></tr></table></figure>



<ul>
<li>索引的创建（类似于  PUT kim_index ）</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试索引的创建</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testCreatIndex</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">//1.创建索引请求</span></span><br><span class="line">    CreateIndexRequest request = <span class="keyword">new</span> CreateIndexRequest(<span class="string">&quot;kim_index&quot;</span>);</span><br><span class="line">    <span class="comment">//2.客户端执行请求（请求后获得响应）</span></span><br><span class="line">    CreateIndexResponse response = client.indices().create(request, RequestOptions.DEFAULT);</span><br><span class="line">    System.out.println(response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>测试获取索引</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试获取索引（只能判断存不存在）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testExistIndex</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">//获得索引请求</span></span><br><span class="line">    GetIndexRequest request = <span class="keyword">new</span> GetIndexRequest(<span class="string">&quot;kim_index2&quot;</span>);</span><br><span class="line">    <span class="keyword">boolean</span> exists = client.indices().exists(request, RequestOptions.DEFAULT);</span><br><span class="line">    System.out.println(exists);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>测试删除索引</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试删除索引</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testDeleteIndex</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    DeleteIndexRequest request = <span class="keyword">new</span> DeleteIndexRequest(<span class="string">&quot;kim_index&quot;</span>);</span><br><span class="line">    AcknowledgedResponse delete = client.indices().delete(request, RequestOptions.DEFAULT);</span><br><span class="line">    <span class="comment">//删除索引成功则返回true</span></span><br><span class="line">    System.out.println(delete.isAcknowledged());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="文档操作-1"><a href="#文档操作-1" class="headerlink" title="文档操作"></a>文档操作</h5><ul>
<li>添加文档</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试添加文档</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testAddDocument</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">//创建对象</span></span><br><span class="line">    User user = <span class="keyword">new</span> User(<span class="string">&quot;Kim&quot;</span>, <span class="number">20</span>);</span><br><span class="line">    <span class="comment">//创建请求</span></span><br><span class="line">    IndexRequest request = <span class="keyword">new</span> IndexRequest(<span class="string">&quot;kim_index&quot;</span>);</span><br><span class="line">    <span class="comment">//规则 PUT /kim_index/_doc/1</span></span><br><span class="line">    request.id(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    request.timeout(TimeValue.timeValueSeconds(<span class="number">1</span>));</span><br><span class="line">    <span class="comment">//设置超时时间（两种方法都行）</span></span><br><span class="line">    request.timeout(<span class="string">&quot;1s&quot;</span>);</span><br><span class="line">    <span class="comment">//将数据放入请求 json</span></span><br><span class="line">    request.source(JSON.toJSONString(user), XContentType.JSON);</span><br><span class="line">    <span class="comment">//客户端发送请求，获取响应的结果</span></span><br><span class="line">    IndexResponse indexResponse = client.index(request, RequestOptions.DEFAULT);</span><br><span class="line">    System.out.println(indexResponse.toString());</span><br><span class="line">    System.out.println(indexResponse.status());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>获取文档</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取文档，判断是否存在  GET index/_doc/1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testIsExists</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    GetRequest getRequest = <span class="keyword">new</span> GetRequest(<span class="string">&quot;kim_index&quot;</span>, <span class="string">&quot;1&quot;</span>);</span><br><span class="line">    <span class="comment">//不获取返回的 _source 的上下文，效率更高（可写可不写）</span></span><br><span class="line">    getRequest.fetchSourceContext(<span class="keyword">new</span> FetchSourceContext(<span class="keyword">false</span>));</span><br><span class="line">    <span class="keyword">boolean</span> exists = client.exists(getRequest, RequestOptions.DEFAULT);</span><br><span class="line">    System.out.println(exists);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>获取文档信息</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取文档信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testGetDocument</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    GetRequest getRequest = <span class="keyword">new</span> GetRequest(<span class="string">&quot;kim_index&quot;</span>, <span class="string">&quot;1&quot;</span>);</span><br><span class="line">    GetResponse getResponse = client.get(getRequest, RequestOptions.DEFAULT);</span><br><span class="line">    System.out.println(getResponse.getSourceAsString());</span><br><span class="line">    System.out.println(getResponse);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>更新文档信息</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 更新文档信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testUpdateDocument</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    UpdateRequest updateRequest = <span class="keyword">new</span> UpdateRequest(<span class="string">&quot;kim_index&quot;</span>, <span class="string">&quot;1&quot;</span>);</span><br><span class="line">    updateRequest.timeout(<span class="string">&quot;1s&quot;</span>);</span><br><span class="line">    User user = <span class="keyword">new</span> User(<span class="string">&quot;KimTou&quot;</span>, <span class="number">21</span>);</span><br><span class="line">    updateRequest.doc(JSON.toJSONString(user),XContentType.JSON);</span><br><span class="line">    UpdateResponse updateResponse = client.update(updateRequest, RequestOptions.DEFAULT);</span><br><span class="line">    System.out.println(updateResponse.status());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>删除文档记录</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除文档记录</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testDeleteDocument</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    DeleteRequest deleteRequest = <span class="keyword">new</span> DeleteRequest(<span class="string">&quot;kim_index&quot;</span>, <span class="string">&quot;1&quot;</span>);</span><br><span class="line">    deleteRequest.timeout(<span class="string">&quot;1s&quot;</span>);</span><br><span class="line">    DeleteResponse deleteResponse = client.delete(deleteRequest, RequestOptions.DEFAULT);</span><br><span class="line">    System.out.println(deleteResponse.status());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>批量导入数据</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 批量插入数据</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testBulkRequest</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    BulkRequest bulkRequest = <span class="keyword">new</span> BulkRequest();</span><br><span class="line">    bulkRequest.timeout(<span class="string">&quot;10s&quot;</span>);</span><br><span class="line">    ArrayList&lt;User&gt; userList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    userList.add(<span class="keyword">new</span> User(<span class="string">&quot;Kim1&quot;</span>,<span class="number">20</span>));</span><br><span class="line">    userList.add(<span class="keyword">new</span> User(<span class="string">&quot;Kim2&quot;</span>,<span class="number">20</span>));</span><br><span class="line">    userList.add(<span class="keyword">new</span> User(<span class="string">&quot;Kim3&quot;</span>,<span class="number">20</span>));</span><br><span class="line">    userList.add(<span class="keyword">new</span> User(<span class="string">&quot;KimTou1&quot;</span>,<span class="number">20</span>));</span><br><span class="line">    userList.add(<span class="keyword">new</span> User(<span class="string">&quot;KimTou2&quot;</span>,<span class="number">20</span>));</span><br><span class="line">    userList.add(<span class="keyword">new</span> User(<span class="string">&quot;KimTou3&quot;</span>,<span class="number">20</span>));</span><br><span class="line">    <span class="comment">//批处理请求</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; userList.size(); i++) &#123;</span><br><span class="line">        <span class="comment">//更新删除操作类似</span></span><br><span class="line">        bulkRequest.add(</span><br><span class="line">                <span class="keyword">new</span> IndexRequest(<span class="string">&quot;kim_index&quot;</span>)</span><br><span class="line">                .id(<span class="string">&quot;&quot;</span>+(i+<span class="number">1</span>))</span><br><span class="line">                .source(JSON.toJSONString(userList.get(i)),XContentType.JSON));</span><br><span class="line">    &#125;</span><br><span class="line">    BulkResponse bulkResponse = client.bulk(bulkRequest, RequestOptions.DEFAULT);</span><br><span class="line">    System.out.println(bulkResponse.hasFailures());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>查询</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 查询</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testSearch</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">//搜索请求</span></span><br><span class="line">    SearchRequest searchRequest = <span class="keyword">new</span> SearchRequest();</span><br><span class="line">    <span class="comment">//构建查询条件</span></span><br><span class="line">    SearchSourceBuilder sourceBuilder = <span class="keyword">new</span> SearchSourceBuilder();</span><br><span class="line">    <span class="comment">//查询条件，可以使用 QueryBuilders 工具类来实现</span></span><br><span class="line">    <span class="comment">//QueryBuilders.termQuery  精确查询</span></span><br><span class="line">    <span class="comment">//QueryBuilders.matchAllQuery  匹配所有</span></span><br><span class="line">    TermQueryBuilder termQueryBuilder = QueryBuilders.termQuery(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;KimTou1&quot;</span>);</span><br><span class="line">    <span class="comment">//MatchAllQueryBuilder matchAllQueryBuilder = QueryBuilders.matchAllQuery();</span></span><br><span class="line">    sourceBuilder.query(termQueryBuilder);</span><br><span class="line">    <span class="comment">//超时时间60s</span></span><br><span class="line">    sourceBuilder.timeout(<span class="keyword">new</span> TimeValue(<span class="number">60</span>, TimeUnit.SECONDS));</span><br><span class="line">    searchRequest.source(sourceBuilder);</span><br><span class="line">    SearchResponse searchResponse = client.search(searchRequest, RequestOptions.DEFAULT);</span><br><span class="line">    System.out.println(JSON.toJSONString(searchResponse.getHits()));</span><br><span class="line">    System.out.println(<span class="string">&quot;====================================&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (SearchHit documentFields : searchResponse.getHits().getHits()) &#123;</span><br><span class="line">        System.out.println(documentFields.getSourceAsMap());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="项目实战"><a href="#项目实战" class="headerlink" title="项目实战"></a>项目实战</h2><h4 id="项目搭建"><a href="#项目搭建" class="headerlink" title="项目搭建"></a>项目搭建</h4><ul>
<li>模块选择：DevTools三个、Web、Thymeleaf、ElasticSearch</li>
<li>pom.xml中修改正确版本</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">//SpringBoot版本选择2.2.5</span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.5.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"></span><br><span class="line">//ElasticSearch选择7.6.1</span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--自己定义es版本依赖，保证和本地一致--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">elasticsearch.version</span>&gt;</span>7.6.1<span class="tag">&lt;/<span class="name">elasticsearch.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>pom.xml中添加fastjson依赖</p>
</li>
<li><p>修改application.properties配置文件</p>
</li>
</ul>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">server.port</span>=<span class="string">9090</span></span><br><span class="line"><span class="comment"># 关闭Thymeleaf缓存</span></span><br><span class="line"><span class="meta">spring.thymeleaf.cache</span>=<span class="string">false</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>导入前端素材</p>
</li>
<li><p>访问首页</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&#123;&quot;/&quot;,&quot;/index&quot;&#125;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">index</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;index&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="爬虫"><a href="#爬虫" class="headerlink" title="爬虫"></a>爬虫</h4><p>导入jsoup依赖（解析网页）</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--解析网页--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.jsoup<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jsoup<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.13.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p><img src="https://gitee.com/KIMTOU/img/raw/master/20211007214615.PNG" alt="html"></p>
<ul>
<li>测试</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//获取请求</span></span><br><span class="line">        String url = <span class="string">&quot;https://search.jd.com/Search?keyword=java&quot;</span>;</span><br><span class="line">        <span class="comment">//解析网页（Jsoup返回的Document对象就是浏览器Document对象）</span></span><br><span class="line">        Document document = Jsoup.parse(<span class="keyword">new</span> URL(url), <span class="number">30000</span>);</span><br><span class="line">        <span class="comment">//所有能在javascript中使用的方法，这里都能用</span></span><br><span class="line">        Element element = document.getElementById(<span class="string">&quot;J_goodsList&quot;</span>);</span><br><span class="line">        <span class="comment">//获取所有的li元素</span></span><br><span class="line">        Elements elements = element.getElementsByTag(<span class="string">&quot;li&quot;</span>);</span><br><span class="line">        <span class="comment">//获取元素中的内容，这里的el就是每一个li标签</span></span><br><span class="line">        <span class="keyword">for</span> (Element el : elements) &#123;</span><br><span class="line">            <span class="comment">/*京东网站使用了懒加载</span></span><br><span class="line"><span class="comment">            String img = el.getElementsByTag(&quot;img&quot;).eq(0).attr(&quot;src&quot;);*/</span></span><br><span class="line">            String img = el.getElementsByTag(<span class="string">&quot;img&quot;</span>).eq(<span class="number">0</span>).attr(<span class="string">&quot;data-lazy-img&quot;</span>);</span><br><span class="line">            String price = el.getElementsByClass(<span class="string">&quot;p-price&quot;</span>).eq(<span class="number">0</span>).text();</span><br><span class="line">            String title = el.getElementsByClass(<span class="string">&quot;p-name&quot;</span>).eq(<span class="number">0</span>).text();</span><br><span class="line">            System.out.println(<span class="string">&quot;===============================================&quot;</span>);</span><br><span class="line">            System.out.println(img);</span><br><span class="line">            System.out.println(price);</span><br><span class="line">            System.out.println(title);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>封装工具类</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HtmlParseUtil</span> </span>&#123;</span><br><span class="line">    <span class="comment">//测试</span></span><br><span class="line">    <span class="comment">//public static void main(String[] args) throws IOException &#123;</span></span><br><span class="line">    <span class="comment">//    new HtmlParseUtil().parseJD(&quot;心理学&quot;).forEach(System.out::println);</span></span><br><span class="line">    <span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 工具类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Content&gt; <span class="title">parseJD</span><span class="params">(String keyword)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        String url = <span class="string">&quot;https://search.jd.com/Search?keyword=&quot;</span>+keyword;</span><br><span class="line">        Document document = Jsoup.parse(<span class="keyword">new</span> URL(url), <span class="number">30000</span>);</span><br><span class="line">        Element element = document.getElementById(<span class="string">&quot;J_goodsList&quot;</span>);</span><br><span class="line">        <span class="comment">//获取所有的li元素</span></span><br><span class="line">        Elements elements = element.getElementsByTag(<span class="string">&quot;li&quot;</span>);</span><br><span class="line">        ArrayList&lt;Content&gt; goodsList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">//获取元素中的内容，这里的el就是每一个li标签</span></span><br><span class="line">        <span class="keyword">for</span> (Element el : elements) &#123;</span><br><span class="line">            <span class="comment">/*京东网站使用了懒加载</span></span><br><span class="line"><span class="comment">            String img = el.getElementsByTag(&quot;img&quot;).eq(0).attr(&quot;src&quot;);*/</span></span><br><span class="line">            String img = el.getElementsByTag(<span class="string">&quot;img&quot;</span>).eq(<span class="number">0</span>).attr(<span class="string">&quot;data-lazy-img&quot;</span>);</span><br><span class="line">            String price = el.getElementsByClass(<span class="string">&quot;p-price&quot;</span>).eq(<span class="number">0</span>).text();</span><br><span class="line">            String title = el.getElementsByClass(<span class="string">&quot;p-name&quot;</span>).eq(<span class="number">0</span>).text();</span><br><span class="line">            Content content = <span class="keyword">new</span> Content();</span><br><span class="line">            content.setTitle(title);</span><br><span class="line">            content.setPrice(price);</span><br><span class="line">            content.setImg(img);</span><br><span class="line">            goodsList.add(content);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> goodsList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="业务编写"><a href="#业务编写" class="headerlink" title="业务编写"></a>业务编写</h4><ol>
<li><p>解析数据放入es索引中</p>
</li>
<li><p>获取这些数据，实现搜索功能</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ContentService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RestHighLevelClient restHighLevelClient;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 1.解析数据放入es索引中</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Boolean <span class="title">parseContent</span><span class="params">(String keyword)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        List&lt;Content&gt; contents = <span class="keyword">new</span> HtmlParseUtil().parseJD(keyword);</span><br><span class="line">        BulkRequest bulkRequest = <span class="keyword">new</span> BulkRequest();</span><br><span class="line">        bulkRequest.timeout(<span class="string">&quot;2m&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; contents.size(); i++) &#123;</span><br><span class="line">            bulkRequest.add(</span><br><span class="line">                    <span class="keyword">new</span> IndexRequest(<span class="string">&quot;jd_goods&quot;</span>)</span><br><span class="line">                    .source(JSON.toJSONString(contents.get(i)), XContentType.JSON));</span><br><span class="line">        &#125;</span><br><span class="line">        BulkResponse bulkResponse = restHighLevelClient.bulk(bulkRequest, RequestOptions.DEFAULT);</span><br><span class="line">        <span class="keyword">return</span> !bulkResponse.hasFailures();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 2.获取这些数据，实现搜索功能</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Map&lt;String,Object&gt;&gt; searchPage(String keyword,<span class="keyword">int</span> pageNo,<span class="keyword">int</span> pageSize) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">if</span>(pageNo&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">            pageNo = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//条件搜索</span></span><br><span class="line">        SearchRequest searchRequest = <span class="keyword">new</span> SearchRequest(<span class="string">&quot;jd_goods&quot;</span>);</span><br><span class="line">        SearchSourceBuilder sourceBuilder = <span class="keyword">new</span> SearchSourceBuilder();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//分页</span></span><br><span class="line">        sourceBuilder.from(pageNo);</span><br><span class="line">        sourceBuilder.size(pageSize);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//精确查询</span></span><br><span class="line">        TermQueryBuilder termQueryBuilder = QueryBuilders.termQuery(<span class="string">&quot;title&quot;</span>, keyword);</span><br><span class="line">        sourceBuilder.query(termQueryBuilder);</span><br><span class="line">        sourceBuilder.timeout(<span class="keyword">new</span> TimeValue(<span class="number">60</span>, TimeUnit.SECONDS));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//执行搜索</span></span><br><span class="line">        searchRequest.source(sourceBuilder);</span><br><span class="line">        SearchResponse searchResponse = restHighLevelClient.search(searchRequest, RequestOptions.DEFAULT);</span><br><span class="line"></span><br><span class="line">        ArrayList&lt;Map&lt;String,Object&gt;&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">//解析结果</span></span><br><span class="line">        <span class="keyword">for</span> (SearchHit document : searchResponse.getHits().getHits()) &#123;</span><br><span class="line">            list.add(document.getSourceAsMap());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>Controller层</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ContentController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ContentService contentService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/parse/&#123;keyword&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Boolean <span class="title">parse</span><span class="params">(<span class="meta">@PathVariable(&quot;keyword&quot;)</span> String keyword)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> contentService.parseContent(keyword);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/search/&#123;keyword&#125;/&#123;pageNo&#125;/&#123;pageSize&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Map&lt;String,Object&gt;&gt; search(<span class="meta">@PathVariable(&quot;keyword&quot;)</span> String keyword,</span><br><span class="line">                                           <span class="meta">@PathVariable(&quot;pageNo&quot;)</span> <span class="keyword">int</span> pageNo,</span><br><span class="line">                                           <span class="meta">@PathVariable(&quot;pageSize&quot;)</span> <span class="keyword">int</span> pageSize) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">return</span> contentService.searchPage(keyword, pageNo, pageSize);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="前后端交互"><a href="#前后端交互" class="headerlink" title="前后端交互"></a>前后端交互</h4><ul>
<li>创建vue</li>
</ul>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line">C:\Users\MI\Desktop\vue&gt;npm install vue</span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">C:\Users\MI\Desktop\vue&gt;npm install axios			//ajax</span><br><span class="line">......</span><br></pre></td></tr></table></figure>

<ul>
<li><p>导入这两个的js文件</p>
</li>
<li><p>index.html</p>
</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">xmlns:th</span>=<span class="string">&quot;http://www.thymeleaf.org&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>狂神说Java-ES仿京东实战<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;/css/style.css&#125;&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span> <span class="attr">class</span>=<span class="string">&quot;pg&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;page&quot;</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;mallPage&quot;</span> <span class="attr">class</span>=<span class="string">&quot; mallist tmall- page-not-market &quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 头部搜索 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;header&quot;</span> <span class="attr">class</span>=<span class="string">&quot; header-list-app&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;headerLayout&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;headerCon &quot;</span>&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!-- Logo--&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">h1</span> <span class="attr">id</span>=<span class="string">&quot;mallLogo&quot;</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">img</span> <span class="attr">th:src</span>=<span class="string">&quot;@&#123;/images/jdlogo.png&#125;&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"></span><br><span class="line">                    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;header-extra&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">                        <span class="comment">&lt;!--搜索--&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;mallSearch&quot;</span> <span class="attr">class</span>=<span class="string">&quot;mall-search&quot;</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">form</span> <span class="attr">name</span>=<span class="string">&quot;searchTop&quot;</span> <span class="attr">class</span>=<span class="string">&quot;mallSearch-form clearfix&quot;</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">fieldset</span>&gt;</span></span><br><span class="line">                                    <span class="tag">&lt;<span class="name">legend</span>&gt;</span>天猫搜索<span class="tag">&lt;/<span class="name">legend</span>&gt;</span></span><br><span class="line">                                    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;mallSearch-input clearfix&quot;</span>&gt;</span></span><br><span class="line">                                        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;s-combobox&quot;</span> <span class="attr">id</span>=<span class="string">&quot;s-combobox-685&quot;</span>&gt;</span></span><br><span class="line">                                            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;s-combobox-input-wrap&quot;</span>&gt;</span></span><br><span class="line">                                                <span class="tag">&lt;<span class="name">input</span>  <span class="attr">v-model</span>=<span class="string">&quot;keyword&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">autocomplete</span>=<span class="string">&quot;off&quot;</span> <span class="attr">value</span>=<span class="string">&quot;dd&quot;</span> <span class="attr">id</span>=<span class="string">&quot;mq&quot;</span></span></span><br><span class="line"><span class="tag">                                                       <span class="attr">class</span>=<span class="string">&quot;s-combobox-input&quot;</span> <span class="attr">aria-haspopup</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">                                            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                                        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                                        <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> @<span class="attr">click.prevent</span>=<span class="string">&quot;searchKey&quot;</span> <span class="attr">id</span>=<span class="string">&quot;searchbtn&quot;</span>&gt;</span>搜索<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">                                    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;/<span class="name">fieldset</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">&quot;relKeyTop&quot;</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span>&gt;</span>狂神说Java<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span>&gt;</span>狂神说前端<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span>&gt;</span>狂神说Linux<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span>&gt;</span>狂神说大数据<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span>&gt;</span>狂神聊理财<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 商品详情页面 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;content&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;main&quot;</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!-- 品牌分类 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">form</span> <span class="attr">class</span>=<span class="string">&quot;navAttrsForm&quot;</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;attrs j_NavAttrs&quot;</span> <span class="attr">style</span>=<span class="string">&quot;display:block&quot;</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;brandAttr j_nav_brand&quot;</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;j_Brand attr&quot;</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;attrKey&quot;</span>&gt;</span></span><br><span class="line">                                    品牌</span><br><span class="line">                                <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;attrValues&quot;</span>&gt;</span></span><br><span class="line">                                    <span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">&quot;av-collapse row-2&quot;</span>&gt;</span></span><br><span class="line">                                        <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span> 狂神说 <span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">                                        <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span> Java <span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">                                    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">&lt;!-- 排序规则 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;filter clearfix&quot;</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">&quot;fSort fSort-cur&quot;</span>&gt;</span>综合<span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&quot;f-ico-arrow-d&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">&quot;fSort&quot;</span>&gt;</span>人气<span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&quot;f-ico-arrow-d&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">&quot;fSort&quot;</span>&gt;</span>新品<span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&quot;f-ico-arrow-d&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">&quot;fSort&quot;</span>&gt;</span>销量<span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&quot;f-ico-arrow-d&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">&quot;fSort&quot;</span>&gt;</span>价格<span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&quot;f-ico-triangle-mt&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span><span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&quot;f-ico-triangle-mb&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">&lt;!-- 商品详情 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;view grid-nosku&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">                    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;product&quot;</span> <span class="attr">v-for</span>=<span class="string">&quot;result in results&quot;</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;product-iWrap&quot;</span>&gt;</span></span><br><span class="line">                            <span class="comment">&lt;!--商品封面--&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;productImg-wrap&quot;</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">&quot;productImg&quot;</span>&gt;</span></span><br><span class="line">                                    <span class="tag">&lt;<span class="name">img</span> <span class="attr">:src</span>=<span class="string">&quot;result.img&quot;</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                            <span class="comment">&lt;!--价格--&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;productPrice&quot;</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">em</span>&gt;</span>&#123;&#123;result.price&#125;&#125;<span class="tag">&lt;/<span class="name">em</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">                            <span class="comment">&lt;!--标题--&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;productTitle&quot;</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">a</span> <span class="attr">v-html</span>=<span class="string">&quot;result.title&quot;</span>&gt;</span>  <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">                            <span class="comment">&lt;!-- 店铺名 --&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;productShop&quot;</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">span</span>&gt;</span>店铺： 狂神说Java <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                            <span class="comment">&lt;!-- 成交信息 --&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;productStatus&quot;</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">span</span>&gt;</span>月成交<span class="tag">&lt;<span class="name">em</span>&gt;</span>999笔<span class="tag">&lt;/<span class="name">em</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">span</span>&gt;</span>评价 <span class="tag">&lt;<span class="name">a</span>&gt;</span>3<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--前端使用Vue，实现前后端分离--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--&lt;script type=&quot;text/javascript&quot; src=&quot;https://unpkg.com/vue&quot;&gt;&lt;/script&gt;</span></span><br><span class="line"><span class="comment">&lt;script src=&quot;https://unpkg.com/axios/dist/axios.min.js&quot;&gt;&lt;/script&gt;--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">th:src</span>=<span class="string">&quot;@&#123;/js/axios.min.js&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">th:src</span>=<span class="string">&quot;@&#123;/js/vue.min.js&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">    <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">        el: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line">        data:&#123;</span><br><span class="line"><span class="javascript">            keyword:<span class="string">&#x27;&#x27;</span>,     <span class="comment">//搜索关键字</span></span></span><br><span class="line"><span class="javascript">            results:[]       <span class="comment">//搜索结果</span></span></span><br><span class="line">        &#125;,</span><br><span class="line">        methods:&#123;</span><br><span class="line"><span class="javascript">            <span class="function"><span class="title">searchKey</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">var</span> keyword = <span class="built_in">this</span>.keyword;</span></span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(keyword);</span></span><br><span class="line"><span class="javascript">                <span class="comment">//对接后端接口</span></span></span><br><span class="line"><span class="javascript">                axios.get(<span class="string">&#x27;search/&#x27;</span>+keyword+<span class="string">&quot;/1/10&quot;</span>).then(<span class="function"><span class="params">response</span>=&gt;</span>&#123;</span></span><br><span class="line"><span class="javascript">                    <span class="built_in">console</span>.log(response);</span></span><br><span class="line"><span class="javascript">                    <span class="built_in">this</span>.results = response.data;    <span class="comment">//绑定数据</span></span></span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h4 id="关键字高亮"><a href="#关键字高亮" class="headerlink" title="关键字高亮"></a>关键字高亮</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 3.获取这些数据，实现搜索高亮功能</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> List&lt;Map&lt;String,Object&gt;&gt; searchPageHighlightBuilder(String keyword,<span class="keyword">int</span> pageNo,<span class="keyword">int</span> pageSize) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="keyword">if</span>(pageNo&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">        pageNo = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//条件搜索</span></span><br><span class="line">    SearchRequest searchRequest = <span class="keyword">new</span> SearchRequest(<span class="string">&quot;jd_goods&quot;</span>);</span><br><span class="line">    SearchSourceBuilder sourceBuilder = <span class="keyword">new</span> SearchSourceBuilder();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//分页</span></span><br><span class="line">    sourceBuilder.from(pageNo);</span><br><span class="line">    sourceBuilder.size(pageSize);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//精确查询</span></span><br><span class="line">    TermQueryBuilder termQueryBuilder = QueryBuilders.termQuery(<span class="string">&quot;title&quot;</span>, keyword);</span><br><span class="line">    sourceBuilder.query(termQueryBuilder);</span><br><span class="line">    sourceBuilder.timeout(<span class="keyword">new</span> TimeValue(<span class="number">60</span>, TimeUnit.SECONDS));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//高亮</span></span><br><span class="line">    HighlightBuilder highlightBuilder = <span class="keyword">new</span> HighlightBuilder();</span><br><span class="line">    highlightBuilder.field(<span class="string">&quot;title&quot;</span>);</span><br><span class="line">    <span class="comment">//多个高亮显示</span></span><br><span class="line">    highlightBuilder.requireFieldMatch(<span class="keyword">false</span>);</span><br><span class="line">    highlightBuilder.preTags(<span class="string">&quot;&lt;span style=&#x27;color:red&#x27;&gt;&quot;</span>);</span><br><span class="line">    highlightBuilder.postTags(<span class="string">&quot;&lt;/span&gt;&quot;</span>);</span><br><span class="line">    sourceBuilder.highlighter(highlightBuilder);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//执行搜索</span></span><br><span class="line">    searchRequest.source(sourceBuilder);</span><br><span class="line">    SearchResponse searchResponse = restHighLevelClient.search(searchRequest, RequestOptions.DEFAULT);</span><br><span class="line"></span><br><span class="line">    ArrayList&lt;Map&lt;String,Object&gt;&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="comment">//解析结果</span></span><br><span class="line">    <span class="keyword">for</span> (SearchHit document : searchResponse.getHits().getHits()) &#123;</span><br><span class="line"></span><br><span class="line">        Map&lt;String, HighlightField&gt; highlightFields = document.getHighlightFields();</span><br><span class="line">        HighlightField title = highlightFields.get(<span class="string">&quot;title&quot;</span>);</span><br><span class="line">        <span class="comment">//原来的结果</span></span><br><span class="line">        Map&lt;String, Object&gt; sourceAsMap = document.getSourceAsMap();</span><br><span class="line">        <span class="comment">//解析高亮的字段，将原来的字段替换为高亮的字段</span></span><br><span class="line">        <span class="keyword">if</span>(title!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            Text[] fragments = title.fragments();</span><br><span class="line">            String newTitle = <span class="string">&quot;&quot;</span>;</span><br><span class="line">            <span class="keyword">for</span> (Text text : fragments) &#123;</span><br><span class="line">                newTitle += text;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//替换为高亮的字段</span></span><br><span class="line">            sourceAsMap.put(<span class="string">&quot;title&quot;</span>,newTitle);</span><br><span class="line">        &#125;</span><br><span class="line">        list.add(sourceAsMap);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>参考资料：</li>
</ul>
<p><a href="https://www.bilibili.com/video/BV17a4y1x7zq">https://www.bilibili.com/video/BV17a4y1x7zq</a></p>
]]></content>
      <categories>
        <category>搜索引擎ElasticSearch</category>
      </categories>
      <tags>
        <tag>ElasticSearch</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 8新特性：函数式接口, Lambda表达式, Stream API, Optional类</title>
    <url>/2021/08/15/Java8%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%9A%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3-Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F-StreamAPI-Optional%E7%B1%BB/</url>
    <content><![CDATA[<p>在 Java 8 中，增加了Lambda表达式、函数式接口、接口的默认方法和静态方法等语言新特性；在类库方面又新增了Stream API、Optional类等。</p>
<h2 id="接口默认方法"><a href="#接口默认方法" class="headerlink" title="接口默认方法"></a>接口默认方法</h2><p>从 Java 8 开始接口<code>interface</code>的方法可以使用 <code>default</code> 或 <code>static</code> 修饰，这样就可以有方法体，且实现类不必进行重写。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;111&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;222&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<h2 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h2><p><strong>函数式接口（Functional Interface）就是有且仅有一个抽象方法，但是可以有多个非抽象方法的接口。函数式接口可以被隐式转换为 lambda 表达式。</strong></p>
<p>像我们经常使用的 <strong><code>Runnable</code>、<code>Callable</code>、<code>Comparator</code></strong> 就是函数式接口。</p>
<p>一般我们可以给函数式接口添加 <code>@FunctionalInterface</code> 注解，当然是不是函数式接口与加不加这个注解无关，只要符合函数式接口定义，即只包含一个抽象方法，虚拟机就会自动判断该接口为函数式接口。使用<code>@FunctionalInterface</code> 注解只是在编译时起到强制规范定义的作用。</p>
<br>

<h4 id="实战运用"><a href="#实战运用" class="headerlink" title="实战运用"></a>实战运用</h4><p>当我们在做项目时，如果遇到接口需要前端传递时间日期参数，此时我们只需配置一个日期转换类，即可实现自动将前端传递过来的时间戳字符串转换为 <code>Date</code> 类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DateConfig</span> <span class="keyword">implements</span> <span class="title">Converter</span>&lt;<span class="title">String</span>, <span class="title">Date</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Date <span class="title">convert</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Date(Long.parseLong(str));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们只需实现 <code>Converter</code> 接口中的抽象方法 <code>convert()</code>，重写转换规则即可。同时我们可以看到 <code>Converter</code> 接口正是一个函数式接口。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Converter</span>&lt;<span class="title">S</span>, <span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function">T <span class="title">convert</span><span class="params">(S var1)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>之后我们的接口便可以直接使用 Date 类来接收时间类型参数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ApiOperation(value = &quot;查询审计&quot;, tags = &quot;审计管理&quot;)</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/findAudit&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result&lt;List&lt;AuditResVo&gt;&gt; findAudit(Date createTimeStart, Date createTimeEnd)&#123;</span><br><span class="line">    List&lt;AuditResVo&gt; auditList = auditService.getAuditList(createTimeStart, createTimeEnd);</span><br><span class="line">    <span class="keyword">return</span> Result.success(auditList);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<h2 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h2><br>

<h2 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h2><p>lambada表达式是一个可传递的代码块，可以在以后执行一次或多次。Lambda允许把函数作为一个方法的参数。</p>
<p>例如我们平时给集合或数组排序，都会使用<code>Collections.sort </code>或 <code>Arrays.sort</code> 进行排序，此时需要向 sort 方法传入一个 Comparator 对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; strList = Arrays.asList(<span class="string">&quot;one&quot;</span>, <span class="string">&quot;two&quot;</span>, <span class="string">&quot;three&quot;</span>);</span><br><span class="line">Collections.sort(strList, <span class="keyword">new</span> Comparator&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(String str1, String str2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> str2.length() - str1.length();	<span class="comment">//将集合按照字符串长度降序排序</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>现在我们有了Lambada表达式，就能以更简洁的方式定制这个比较器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; strList = Arrays.asList(<span class="string">&quot;one&quot;</span>, <span class="string">&quot;two&quot;</span>, <span class="string">&quot;three&quot;</span>);</span><br><span class="line">Collections.sort(strList, (String str1, String str2) </span><br><span class="line">                 				-&gt; str2.length() - str1.length());</span><br></pre></td></tr></table></figure>

<p>这便是一种lambada表达式形式：参数，箭头（-&gt;）以及一个表达式。如果代码要完成的计算无法放在一个表达式中，就可以像写方法一样，把代码放在 {} 中，并包含显示的 return 语句：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; strList = Arrays.asList(<span class="string">&quot;one&quot;</span>, <span class="string">&quot;two&quot;</span>, <span class="string">&quot;three&quot;</span>);</span><br><span class="line">Collections.sort(strList, (String str1, String str2) -&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (str2.length() &gt; str1.length())  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (str2.length() &lt; str1.length()) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>当lambada表达式没有参数时，仍然要提供小括号<code>()</code>，就像无参方法一样：</p>
<ul>
<li>传统方式</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;线程执行&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure>

<ul>
<li>lambada表达式</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Thread(() -&gt; System.out.println(<span class="string">&quot;线程执行&quot;</span>)).start();</span><br></pre></td></tr></table></figure>

<p>如果编译器可以推导出参数类型，则可以忽略其类型：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Comparator&lt;String&gt; comparator = (str1, str2) -&gt; str2.length() - str1.length();</span><br></pre></td></tr></table></figure>

<p>如果方法只有一个参数，而且这个参数的类型可以推导出来，那么甚至可以省略小括号：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Predicate&lt;Integer&gt; predicate = data -&gt; data &gt; <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<h4 id="实战运用-1"><a href="#实战运用-1" class="headerlink" title="实战运用"></a>实战运用</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> Integer no;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(Integer no, String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.no = no;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getNo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> no;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Stream流中的 <code>filter</code> 过滤需要通过一个 <code>predicate</code> 接口来过滤并只保留符合条件的元素，此时配合lambada表达式会非常方便。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Student student1 = <span class="keyword">new</span> Student(<span class="number">1</span>, <span class="string">&quot;小明&quot;</span>);</span><br><span class="line">Student student2 = <span class="keyword">new</span> Student(<span class="number">6</span>, <span class="string">&quot;小李&quot;</span>);</span><br><span class="line">Student student3 = <span class="keyword">new</span> Student(<span class="number">12</span>, <span class="string">&quot;小月&quot;</span>);</span><br><span class="line">List&lt;Student&gt; studentList = Arrays.asList(student1, student2, student3);</span><br><span class="line">List&lt;Student&gt; collect = studentList.stream()</span><br><span class="line">    		.filter(student -&gt; student.getNo() &lt; <span class="number">10</span>).collect(Collectors.toList());</span><br></pre></td></tr></table></figure>

<br>

<h2 id="Stream-API"><a href="#Stream-API" class="headerlink" title="Stream API"></a>Stream API</h2><h3 id="什么是Stream"><a href="#什么是Stream" class="headerlink" title="什么是Stream"></a>什么是Stream</h3><blockquote>
<p>Stream（流）是一个来自数据源的元素队列，它可以支持聚合操作，极大简化了集合的操作。</p>
<ul>
<li>数据源：流的数据来源，构造Stream对象的数据源，比如通过一个List来构造Stream对象，这个List就是数据源；</li>
<li>聚合操作：对Stream对象进行处理后使得Stream对象返回指定规则数据的操作称之为聚合操作，比如filter、map、limit、sorted等都是聚合操作。</li>
</ul>
</blockquote>
<br>

<h3 id="Stream聚合操作"><a href="#Stream聚合操作" class="headerlink" title="Stream聚合操作"></a>Stream聚合操作</h3><p>这里使用一个实体类（User）作为示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Long userId;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例数据：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">User user1 = <span class="keyword">new</span> User(<span class="number">1001L</span>, <span class="string">&quot;小明&quot;</span>, <span class="number">21</span>, <span class="string">&quot;深圳&quot;</span>);</span><br><span class="line">User user2 = <span class="keyword">new</span> User(<span class="number">1002L</span>, <span class="string">&quot;小红&quot;</span>, <span class="number">23</span>, <span class="string">&quot;成都&quot;</span>);</span><br><span class="line">User user3 = <span class="keyword">new</span> User(<span class="number">1003L</span>, <span class="string">&quot;小华&quot;</span>, <span class="number">25</span>, <span class="string">&quot;广州&quot;</span>);</span><br><span class="line">User user4 = <span class="keyword">new</span> User(<span class="number">1004L</span>, <span class="string">&quot;大海&quot;</span>, <span class="number">30</span>, <span class="string">&quot;杭州&quot;</span>);</span><br><span class="line">List&lt;User&gt; userList = Arrays.asList(user1, user2, user3, user4);</span><br></pre></td></tr></table></figure>

<h4 id="流的创建"><a href="#流的创建" class="headerlink" title="流的创建"></a>流的创建</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="comment">//创建一个顺序流</span></span><br><span class="line">Stream&lt;String&gt; stream = list.stream();</span><br><span class="line"><span class="comment">//创建一个并行流</span></span><br><span class="line">Stream&lt;String&gt; parallelStream = list.parallelStream();</span><br><span class="line"></span><br><span class="line"><span class="comment">//将示例数据转换成流</span></span><br><span class="line">Stream&lt;User&gt; userStream = userList.stream();</span><br></pre></td></tr></table></figure>

<ul>
<li>顺序流与并行流的区别</li>
</ul>
<p>stream是顺序流，由主线程按顺序对流执行操作； parallelStream是并行流，内部以多线程并行执行的方式对流进行操作，但前提是流中的数据处理没有顺序要求。</p>
<h4 id="collect收集"><a href="#collect收集" class="headerlink" title="collect收集"></a>collect收集</h4><p><strong>collect方法用于传入一个Collector实例，将流转换为其他数据结构并返回</strong></p>
<ul>
<li>将List集合转换为Set集合</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Set&lt;User&gt; collect = userList.stream()</span><br><span class="line">        .collect(Collectors.toSet());</span><br></pre></td></tr></table></figure>

<ul>
<li>将List集合转换为Map集合</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;Long, User&gt; collect = userList.stream()</span><br><span class="line">        .collect(Collectors.toMap(User::getUserId, user -&gt; user));</span><br></pre></td></tr></table></figure>

<h4 id="filter过滤"><a href="#filter过滤" class="headerlink" title="filter过滤"></a>filter过滤</h4><p><strong>根据一定规则对stream流进行过滤，将符合条件的元素提取到新的流中</strong></p>
<ul>
<li>筛选出List集合大于6的数据</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamAPI</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; list = Arrays.asList(<span class="number">2</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>);</span><br><span class="line">        Stream&lt;Integer&gt; stream = list.stream();</span><br><span class="line">        stream.filter(num -&gt; num &gt; <span class="number">6</span>).forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>将示例数据中年龄大于24的数据筛选出来</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;User&gt; collect = userList.stream()</span><br><span class="line">                .filter(user -&gt; user.getAge() &lt; <span class="number">24</span>)</span><br><span class="line">                .collect(Collectors.toList());</span><br></pre></td></tr></table></figure>

<h4 id="map映射"><a href="#map映射" class="headerlink" title="map映射"></a>map映射</h4><p>将流的元素按照一定映射规则进行转换处理后映射到另一个流中</p>
<ul>
<li>将实例集合中的对象的name映射为新的List集合</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; collect = userList.stream()</span><br><span class="line">        .map(user -&gt; user.getUserName())</span><br><span class="line">        .collect(Collectors.toList());</span><br></pre></td></tr></table></figure>

<h4 id="distinct去重"><a href="#distinct去重" class="headerlink" title="distinct去重"></a>distinct去重</h4><p>将stream流中的相同元素进行去重处理（通过流中元素的 hashCode() 和 equals() 去除重复元素）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;User&gt; collect = userList.stream()</span><br><span class="line">        .distinct()</span><br><span class="line">        .collect(Collectors.toList());</span><br></pre></td></tr></table></figure>

<h4 id="limit"><a href="#limit" class="headerlink" title="limit"></a>limit</h4><p>从stream流中获取指定个数的元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;User&gt; collect = userList.stream()</span><br><span class="line">        .limit(<span class="number">2</span>)</span><br><span class="line">        .collect(Collectors.toList());</span><br></pre></td></tr></table></figure>

<h4 id="skip"><a href="#skip" class="headerlink" title="skip"></a>skip</h4><p>跳过指定个数的流中的元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;User&gt; collect = userList.stream()</span><br><span class="line">        .skip(<span class="number">2</span>)</span><br><span class="line">        .collect(Collectors.toList());</span><br></pre></td></tr></table></figure>

<h4 id="分页操作"><a href="#分页操作" class="headerlink" title="分页操作"></a>分页操作</h4><p>使用limit配合skip可实现分页操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;User&gt; collect = userList.stream()</span><br><span class="line">        .skip(<span class="number">0</span>)</span><br><span class="line">        .limit(<span class="number">2</span>)</span><br><span class="line">        .collect(Collectors.toList());</span><br></pre></td></tr></table></figure>

<h4 id="count"><a href="#count" class="headerlink" title="count"></a>count</h4><p>返回stream流中元素个数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">long</span> count = userList.stream().count();</span><br></pre></td></tr></table></figure>

<h4 id="sorted排序"><a href="#sorted排序" class="headerlink" title="sorted排序"></a>sorted排序</h4><p>按照某种规则对元素进行排序</p>
<p>排序有两种方式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 自然排序，流中元素需要实现Comparable接口</span></span><br><span class="line"><span class="function">Stream&lt;T&gt; <span class="title">sorted</span><span class="params">()</span></span>;		</span><br><span class="line"><span class="comment">// Comparator自定义排序</span></span><br><span class="line"><span class="function">Stream&lt;T&gt; <span class="title">sorted</span><span class="params">(Comparator&lt;? <span class="keyword">super</span> T&gt; comparator)</span></span>;	</span><br></pre></td></tr></table></figure>

<ul>
<li>年龄大的排在前面</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;User&gt; collect = userList.stream()</span><br><span class="line">        .sorted((userA, userB) -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> userB.getAge().compareTo(userA.getAge());</span><br><span class="line">        &#125;)</span><br><span class="line">        .collect(Collectors.toList());</span><br></pre></td></tr></table></figure>

<br>

<h2 id="Optional类"><a href="#Optional类" class="headerlink" title="Optional类"></a>Optional类</h2><p>Optional类是 Java 8 提供的用于解决 <strong>空指针异常 <code>NullPointerException</code></strong> 的工具，它能帮助我们减少各种 <code>null</code> 检查的代码，使程序变得更加简洁。</p>
<h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><p>从下面源码可以发现，Optional类维护了一个变量value，初始时其值为null。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Optional</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 全局EMPTY对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Optional&lt;?&gt; EMPTY = <span class="keyword">new</span> Optional&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Optional维护的值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> T value;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始值为null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Optional</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回Optional的Empty空对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span>&lt;T&gt; Optional&lt;T&gt; <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Optional&lt;T&gt; t = (Optional&lt;T&gt;) EMPTY;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 私有构造方法，给Optional对象的value赋值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Optional</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = Objects.requireNonNull(value);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Objects.requireNonNull方法</span></span><br><span class="line"><span class="comment">     * 可以发现使用of方法若value为null，则抛出NullPointerException异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">requireNonNull</span><span class="params">(T obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (obj == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建指定value值的Optional对象并返回</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Optional&lt;T&gt; <span class="title">of</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Optional&lt;&gt;(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果value为null则返回EMPTY，否则返回of(value)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Optional&lt;T&gt; <span class="title">ofNullable</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value == <span class="keyword">null</span> ? empty() : of(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果value值为空，则抛出异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException(<span class="string">&quot;No value present&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>通过源码我们可以看到， <code>of()</code> 以及 <code>ofNullable()</code> 这两个方法都可以创建Optional对象并返回，那么它们有上面不同呢？主要在于<strong>使用<code>of()</code>方法传入的 value 值为 null 时，则会直接抛出 <code>NullPointerException</code> 空指针异常；而<code>ofNullable()</code>方法不会报空指针异常，而是返回 <code>EMPTY</code></strong> （一个 value 为 null 值的Optional对象）。如果需要把 <code>NullPointerException</code> 暴漏出来就用 <code>of</code>，否则就用 <code>ofNullable</code>。</p>
<br>

<h3 id="of与ofNullable测试"><a href="#of与ofNullable测试" class="headerlink" title="of与ofNullable测试"></a>of与ofNullable测试</h3><p>我们先使用<code>of()</code>方法进行测试，当value不为null，使用<code>get()</code>方法能够正常获取。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str1 = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">String str2 = <span class="keyword">null</span>;</span><br><span class="line">Optional&lt;String&gt; optional = Optional.of(str1);</span><br><span class="line">String str = optional1.get();</span><br><span class="line">System.out.println(str);</span><br></pre></td></tr></table></figure>

<p>当value为null时，在<code>of()</code>方法中直接抛出NullPointerException空指针异常。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str1 = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">String str2 = <span class="keyword">null</span>;</span><br><span class="line">Optional&lt;String&gt; optional = Optional.of(str2);<span class="comment">//抛出异常</span></span><br><span class="line">String str = optional1.get();</span><br><span class="line">System.out.println(str);</span><br></pre></td></tr></table></figure>

<p>我们再使用<code>ofNullable()</code>方法进行测试，当传入value为null值时，<code>ofNullable()</code>方法并不会抛出异常，而是在<code>get()</code>时抛出NoSuchElementException异常。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str1 = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">String str2 = <span class="keyword">null</span>;</span><br><span class="line">Optional&lt;String&gt; optional = Optional.ofNullable(str2);<span class="comment">//未抛出异常</span></span><br><span class="line">String str = optional.get();<span class="comment">//抛出异常</span></span><br><span class="line">System.out.println(str);</span><br></pre></td></tr></table></figure>

<br>

<h3 id="其他实用方法"><a href="#其他实用方法" class="headerlink" title="其他实用方法"></a>其他实用方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPresent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value != <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 如果Optional内部维护的value不为null，则执行consumer</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ifPresent</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; consumer)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (value != <span class="keyword">null</span>)</span><br><span class="line">        consumer.accept(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 如果Optional内部维护的value不为null则将其返回，否则返回other其他值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">orElse</span><span class="params">(T other)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value != <span class="keyword">null</span> ? value : other;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<h3 id="map与flatMap"><a href="#map与flatMap" class="headerlink" title="map与flatMap"></a>map与flatMap</h3><p><strong>源码分析</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 如果value为null，返回EMPTY，否则返回Optional封装的参数值</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span>&lt;U&gt; Optional&lt;U&gt; <span class="title">map</span><span class="params">(Function&lt;? <span class="keyword">super</span> T, ? extends U&gt; mapper)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(mapper);</span><br><span class="line">    <span class="keyword">if</span> (!isPresent())</span><br><span class="line">        <span class="keyword">return</span> empty();</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Optional.ofNullable(mapper.apply(value));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 如果value为null，返回EMPTY，否则返回Optional封装的参数值，如果参数值返回null会抛 NullPointerException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span>&lt;U&gt; Optional&lt;U&gt; <span class="title">flatMap</span><span class="params">(Function&lt;? <span class="keyword">super</span> T, Optional&lt;U&gt;&gt; mapper)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(mapper);</span><br><span class="line">    <span class="keyword">if</span> (!isPresent())</span><br><span class="line">        <span class="keyword">return</span> empty();</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.requireNonNull(mapper.apply(value));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>区别：</strong></p>
<ul>
<li>参数不一样</li>
<li><code>flatMap()</code> 参数返回值如果是 null 会抛 <code>NullPointerException</code>，而 <code>map()</code> 返回<code>EMPTY</code></li>
</ul>
<br>

<h3 id="小试身手"><a href="#小试身手" class="headerlink" title="小试身手"></a>小试身手</h3><p>下面代码严格的逻辑判断避免了程序发生空指针异常，但也导致了代码冗杂。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getName</span><span class="params">(School school)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (school != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Student student = school.getStudent();</span><br><span class="line">        <span class="keyword">if</span> (student != <span class="keyword">null</span>) &#123;</span><br><span class="line">            String name = student.getName();</span><br><span class="line">            System.out.println(name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时使用Optional进行简化代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getName</span><span class="params">(School school)</span></span>&#123;</span><br><span class="line">    Optional.ofNullable(school).map(School::getStudent).map(Student::getName)</span><br><span class="line">                .ifPresent(name -&gt; System.out.println(name));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>若方法需要返回name，则可以改写为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getName</span><span class="params">(School school)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Optional.ofNullable(school).map(School::getStudent).map(Student::getName)</span><br><span class="line">            .orElse(<span class="string">&quot;发现null值&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<blockquote>
<p>参考资料</p>
</blockquote>
<p>《Java核心技术 卷1》</p>
<p><a href="https://blog.nowcoder.net/n/4e5c389e638147938bcd7b2340474a45">字节二面被问“Java Stream 流操作‘’？看完这篇，教你自信应对！</a></p>
<p><a href="http://www.macrozheng.com/#/technology/java_stream?id=java-8%E9%83%BD%E5%87%BA%E9%82%A3%E4%B9%88%E4%B9%85%E4%BA%86%EF%BC%8Cstream-api%E4%BA%86%E8%A7%A3%E4%B8%8B%EF%BC%9F">Java 8都出那么久了，Stream API了解下？</a></p>
<p><a href="https://mp.weixin.qq.com/s/ojyl7B6PiHaTWADqmUq2rw">我，一个10年老程序员，最近才开始用 Java8 新特性 (qq.com)</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>一文了解Docker的基本操作与使用</title>
    <url>/2021/10/17/%E4%B8%80%E6%96%87%E4%BA%86%E8%A7%A3Docker%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E4%B8%8E%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>Docker 包括三个基本概念:</p>
<ul>
<li><strong>镜像（Image）</strong>：Docker 镜像（Image），就相当于是一个 root 文件系统。比如官方镜像 ubuntu:16.04 就包含了完整的一套 Ubuntu16.04 最小系统的 root 文件系统。</li>
<li><strong>容器（Container）</strong>：镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中的类和实例一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。</li>
<li><strong>仓库（Repository）</strong>：仓库可看成一个代码控制中心，用来保存镜像。</li>
</ul>
<p><img src="https://gitee.com/KIMTOU/img/raw/master/20211017002530.png" alt="docker"></p>
<h4 id="容器与镜像"><a href="#容器与镜像" class="headerlink" title="容器与镜像"></a>容器与镜像</h4><p>镜像是一种静态的结构，可以看成面向对象里面的类，而容器是镜像的一个实例。</p>
<p>镜像包含着容器运行时所需要的代码以及其它组件，它是一种分层结构，每一层都是只读的（read-only layers）。构建镜像时，会一层一层构建，前一层是后一层的基础。镜像的这种分层存储结构很适合镜像的复用以及定制。</p>
<p>构建容器时，通过在镜像的基础上添加一个可写层（writable layer），用来保存着容器运行过程中的修改。</p>
<h4 id="解决的问题"><a href="#解决的问题" class="headerlink" title="解决的问题"></a>解决的问题</h4><p>由于不同的机器有不同的操作系统，以及不同的库和组件，在将一个应用部署到多台机器上需要进行大量的环境配置操作。</p>
<p>Docker 主要解决环境配置问题，它是一种虚拟化技术，<strong>对进程进行隔离，被隔离的进程独立于宿主操作系统和其它隔离的进程</strong>。使用 Docker 可以不修改应用程序代码，不需要开发人员学习特定环境下的技术，就能够将现有的应用程序部署在其它机器上。</p>
<br>

<h2 id="Docker的优势"><a href="#Docker的优势" class="headerlink" title="Docker的优势"></a>Docker的优势</h2><h4 id="启动速度"><a href="#启动速度" class="headerlink" title="启动速度"></a>启动速度</h4><p>启动虚拟机需要先启动虚拟机的操作系统，再启动应用，这个过程非常慢；</p>
<p>而启动 Docker 相当于启动宿主操作系统上的一个进程。</p>
<h4 id="占用资源"><a href="#占用资源" class="headerlink" title="占用资源"></a>占用资源</h4><p>虚拟机是一个完整的操作系统，需要占用大量的磁盘、内存和 CPU 资源，一台机器只能开启几十个的虚拟机。</p>
<p><strong>而 Docker 只是一个进程</strong>，只需要将应用以及相关的组件打包，在运行时占用很少的资源，一台机器可以开启成千上万个 Docker。</p>
<h4 id="更容易迁移"><a href="#更容易迁移" class="headerlink" title="更容易迁移"></a>更容易迁移</h4><p><strong>提供一致性的运行环境</strong>。已经打包好的应用可以在不同的机器上进行迁移，而不用担心环境变化导致无法运行。</p>
<h4 id="更容易维护"><a href="#更容易维护" class="headerlink" title="更容易维护"></a>更容易维护</h4><p>使用分层技术和镜像，使得应用可以更容易复用重复的部分。复用程度越高，维护工作也越容易。</p>
<h4 id="更容易扩展"><a href="#更容易扩展" class="headerlink" title="更容易扩展"></a>更容易扩展</h4><p>可以使用基础镜像进一步扩展得到新的镜像，并且官方和开源社区提供了大量的镜像，通过扩展这些镜像可以非常容易得到我们想要的镜像。</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><ul>
<li>环境查看</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 系统内核</span></span><br><span class="line">[root@localhost /]# uname -r</span><br><span class="line">3.10.0-1160.11.1.el7.x86_64</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 系统版本</span></span><br><span class="line">[root@localhost /]# cat /etc/os-release </span><br><span class="line">NAME=&quot;CentOS Linux&quot;</span><br><span class="line">VERSION=&quot;7 (Core)&quot;</span><br><span class="line">ID=&quot;centos&quot;</span><br><span class="line">ID_LIKE=&quot;rhel fedora&quot;</span><br><span class="line">VERSION_ID=&quot;7&quot;</span><br><span class="line">PRETTY_NAME=&quot;CentOS Linux 7 (Core)&quot;</span><br><span class="line">ANSI_COLOR=&quot;0;31&quot;</span><br><span class="line">CPE_NAME=&quot;cpe:/o:centos:centos:7&quot;</span><br><span class="line">HOME_URL=&quot;https://www.centos.org/&quot;</span><br><span class="line">BUG_REPORT_URL=&quot;https://bugs.centos.org/&quot;</span><br><span class="line"></span><br><span class="line">CENTOS_MANTISBT_PROJECT=&quot;CentOS-7&quot;</span><br><span class="line">CENTOS_MANTISBT_PROJECT_VERSION=&quot;7&quot;</span><br><span class="line">REDHAT_SUPPORT_PRODUCT=&quot;centos&quot;</span><br><span class="line">REDHAT_SUPPORT_PRODUCT_VERSION=&quot;7&quot;</span><br></pre></td></tr></table></figure>

<ul>
<li>安装文档链接：<a href="https://docs.docker.com/engine/install/centos/">https://docs.docker.com/engine/install/centos/</a></li>
</ul>
<ol>
<li>卸载旧的版本</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum remove docker \</span><br><span class="line">                  docker-client \</span><br><span class="line">                  docker-client-latest \</span><br><span class="line">                  docker-common \</span><br><span class="line">                  docker-latest \</span><br><span class="line">                  docker-latest-logrotate \</span><br><span class="line">                  docker-logrotate \</span><br><span class="line">                  docker-engine</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>安装需要的安装包（提供实用程序）</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install -y yum-utils</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 若安装失败，可能是网络问题</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> ping www.baidu.com失败，结果发现是（DNS文件没有配置）</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment">#    vi /etc/resolv.conf</span></span> </span><br><span class="line"><span class="meta">#</span><span class="bash">    nameserver 8.8.8.8</span></span><br><span class="line"><span class="meta">#</span><span class="bash">    nameserver 8.8.4.4</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>设置镜像的仓库</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> yum-config-manager \</span></span><br><span class="line"><span class="bash"><span class="comment">#     --add-repo \</span></span></span><br><span class="line"><span class="bash"><span class="comment">#     https://download.docker.com/linux/centos/docker-ce.repo		# 默认国外（慢）</span></span></span><br><span class="line">    </span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用阿里云镜像</span></span><br><span class="line">yum-config-manager \</span><br><span class="line">    --add-repo \</span><br><span class="line">    http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>安装最新版本的Docker 引擎和容器</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 可以先更新yum软件包索引</span></span><br><span class="line">yum makecache fast</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 安装docker</span></span><br><span class="line">yum install docker-ce docker-ce-cli containerd.io</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>启动docker</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl start docker</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看是否安装成功</span></span><br><span class="line">docker version</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>测试：通过运行映像验证 Docker 引擎安装是否正确</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run hello-world</span><br></pre></td></tr></table></figure>

<ol start="7">
<li>查看下载的hello-world镜像</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# docker images</span><br><span class="line">REPOSITORY    TAG       IMAGE ID       CREATED         SIZE</span><br><span class="line">hello-world   latest    bf756fb1ae65   13 months ago   13.3kB</span><br></pre></td></tr></table></figure>



<ul>
<li>了解：卸载docker</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 卸载 Docker 引擎、CLI 和容器包</span></span><br><span class="line">yum remove docker-ce docker-ce-cli containerd.io</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除资源</span></span><br><span class="line">rm -rf /var/lib/docker</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> /var/lib/docker         docker默认工作路径</span></span><br></pre></td></tr></table></figure>

<br>

<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><h4 id="帮助命令"><a href="#帮助命令" class="headerlink" title="帮助命令"></a>帮助命令</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker version		# 显示docker的版本信息</span><br><span class="line">docker info			# 显示docker的系统信息（包括镜像和容器的数量）</span><br><span class="line">docker --help		# 查看所有的命令</span><br><span class="line">docker import --help	#查看目录的帮助</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 帮助文档：https://docs.docker.com/reference/</span></span><br></pre></td></tr></table></figure>

<h4 id="镜像命令"><a href="#镜像命令" class="headerlink" title="镜像命令"></a>镜像命令</h4><ul>
<li><strong>docker images</strong>：查看所有本地主机上的镜像</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# docker images</span><br><span class="line">REPOSITORY    TAG       IMAGE ID       CREATED         SIZE</span><br><span class="line">hello-world   latest    bf756fb1ae65   13 months ago   13.3kB</span><br><span class="line"></span><br><span class="line">-----------------------------------------------------------------</span><br><span class="line"><span class="meta">#</span><span class="bash"> 说明</span></span><br><span class="line">REPOSITORY		# 镜像的仓库源</span><br><span class="line">TAG				# 镜像的标签</span><br><span class="line">IMAGE ID		# 镜像的id</span><br><span class="line">CREATED			# 镜像创建的时间</span><br><span class="line">SIZE			# 镜像的大小</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 可选项</span></span><br><span class="line">Options:</span><br><span class="line">  -a, --all             # 列出所有镜像</span><br><span class="line">  -q, --quiet           # 只显示镜像id</span><br><span class="line"></span><br><span class="line">--------------------------------------------------------------------</span><br><span class="line"><span class="meta">#</span><span class="bash"> 测试</span></span><br><span class="line">[root@localhost ~]# docker images -a</span><br><span class="line">REPOSITORY    TAG       IMAGE ID       CREATED         SIZE</span><br><span class="line">hello-world   latest    bf756fb1ae65   13 months ago   13.3kB</span><br><span class="line">[root@localhost ~]# docker images -q</span><br><span class="line">bf756fb1ae65</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>docker search</strong>：搜索镜像</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# docker search mysql</span><br><span class="line">..................列出在dockerhub搜索的结果（name，description，stars等）.....................</span><br><span class="line"></span><br><span class="line">-------------------------------------------------------------------------</span><br><span class="line"><span class="meta">#</span><span class="bash"> 可选项</span></span><br><span class="line">Options:</span><br><span class="line">  -f, --filter filter   过滤条件</span><br><span class="line"></span><br><span class="line">-------------------------------------------------------------------------</span><br><span class="line"><span class="meta">#</span><span class="bash"> 测试</span></span><br><span class="line">[root@localhost ~]# docker search mysql --filter=STARS=3000</span><br><span class="line">..................搜索出来的镜像STARS数大于3000的.....................................</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>docker pull</strong>：下载镜像</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> docker pull 镜像名[:tag]</span></span><br><span class="line">[root@localhost ~]# docker pull mysql</span><br><span class="line">Using default tag: latest		# 如果不写tag，默认就是latest最新版</span><br><span class="line">latest: Pulling from library/mysql</span><br><span class="line">45b42c59be33: Pull complete 	# 分层下载，docker image的核心，联合文件系统</span><br><span class="line">b4f790bd91da: Pull complete </span><br><span class="line">325ae51788e9: Pull complete </span><br><span class="line">adcb9439d751: Pull complete </span><br><span class="line">174c7fe16c78: Pull complete </span><br><span class="line">698058ef136c: Pull complete </span><br><span class="line">4690143a669e: Pull complete </span><br><span class="line">f7599a246fd6: Pull complete </span><br><span class="line">35a55bf0c196: Pull complete </span><br><span class="line">790ac54f4c47: Pull complete </span><br><span class="line">18602acc97e1: Pull complete </span><br><span class="line">365caa3500d0: Pull complete </span><br><span class="line">Digest: sha256:b1cc887ed32cc6c2f217b12703bd05f503f2037892c8bb226047fe5dff85a109	# 签名</span><br><span class="line">Status: Downloaded newer image for mysql:latest</span><br><span class="line">docker.io/library/mysql:latest		# 真实地址</span><br><span class="line"></span><br><span class="line">------------------------------------------------------------------</span><br><span class="line"><span class="meta">#</span><span class="bash"> 指定版本下载</span></span><br><span class="line">[root@localhost ~]# docker pull mysql:5.7</span><br><span class="line">5.7: Pulling from library/mysql</span><br><span class="line">45b42c59be33: Already exists    # 有与刚刚下载的mysql最新版重合的，故不用下载</span><br><span class="line">b4f790bd91da: Already exists 	# 节省了内存（联合文件系统的优势） </span><br><span class="line">325ae51788e9: Already exists </span><br><span class="line">adcb9439d751: Already exists </span><br><span class="line">174c7fe16c78: Already exists </span><br><span class="line">698058ef136c: Already exists </span><br><span class="line">4690143a669e: Already exists </span><br><span class="line">66676c1ab9b3: Pull complete </span><br><span class="line">25ebf78a38b6: Pull complete </span><br><span class="line">349a839d5e27: Pull complete </span><br><span class="line">40b03e3e5980: Pull complete </span><br><span class="line">Digest: sha256:853105ad984a9fe87dd109be6756e1fbdba8b003b303d88ac0dda6b455f36556</span><br><span class="line">Status: Downloaded newer image for mysql:5.7</span><br><span class="line">docker.io/library/mysql:5.7</span><br><span class="line"></span><br><span class="line">-------------------------------------------------------------------</span><br><span class="line"><span class="meta">#</span><span class="bash"> 等价</span></span><br><span class="line">docker pull mysql</span><br><span class="line">docker pull docker.io/library/mysql:latest</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>docker rmi</strong>：删除镜像</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> docker rmi -f 镜像id							删除指定镜像</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> docker rmi -f 镜像id 镜像id 镜像id 镜像id			删除多个指定镜像</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> docker rmi -f 镜像id $(docker images -aq)		删除全部镜像</span></span><br><span class="line"></span><br><span class="line">---------------------------------------------------------------------------</span><br><span class="line"><span class="meta">#</span><span class="bash"> 测试</span></span><br><span class="line">[root@localhost ~]# docker images</span><br><span class="line">REPOSITORY    TAG       IMAGE ID       CREATED         SIZE</span><br><span class="line">mysql         5.7       5f47254ca581   21 hours ago    449MB</span><br><span class="line">mysql         latest    2933adc350f3   21 hours ago    546MB</span><br><span class="line">hello-world   latest    bf756fb1ae65   13 months ago   13.3kB</span><br><span class="line">[root@localhost ~]# docker rmi -f 5f47254ca581					# 删除指定</span><br><span class="line">Untagged: mysql:5.7</span><br><span class="line">Untagged: mysql@sha256:853105ad984a9fe87dd109be6756e1fbdba8b003b303d88ac0dda6b455f36556</span><br><span class="line">Deleted: sha256:5f47254ca5817f99cdd387ce7345d43e770e0682a4c81b62776f3347551b1d85</span><br><span class="line">......</span><br><span class="line">[root@localhost ~]# docker images</span><br><span class="line">REPOSITORY    TAG       IMAGE ID       CREATED         SIZE</span><br><span class="line">mysql         latest    2933adc350f3   21 hours ago    546MB</span><br><span class="line">hello-world   latest    bf756fb1ae65   13 months ago   13.3kB</span><br><span class="line">[root@localhost ~]# docker rmi -f $(docker images -aq)			# 删除全部</span><br><span class="line">Untagged: mysql:latest</span><br><span class="line">Untagged: mysql@sha256:b1cc887ed32cc6c2f217b12703bd05f503f2037892c8bb226047fe5dff85a109</span><br><span class="line">Deleted: sha256:2933adc350f3b62c05a66f700fba68ef93997d67263121250ec7848c50dcf3f5</span><br><span class="line">......</span><br><span class="line">[root@localhost ~]# docker images</span><br><span class="line">REPOSITORY   TAG       IMAGE ID   CREATED   SIZE</span><br></pre></td></tr></table></figure>

<br>

<h4 id="容器命令"><a href="#容器命令" class="headerlink" title="容器命令"></a>容器命令</h4><ul>
<li>说明：有了镜像才能创建容器</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 下载centos镜像来测试学习</span></span><br><span class="line">docker pull centos</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>新建容器并启动</strong></li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run [可选参数] image</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 参数说明</span></span><br><span class="line">--name=&quot;Name&quot;	# 容器名字（用来区分容器）</span><br><span class="line">-d				# 后台方式运行</span><br><span class="line">-it 			# 交互方式运行（进入容器查看内容）</span><br><span class="line">-p				# 指定容器端口		-p 主机端口:容器端口（常用）</span><br><span class="line">									# 将容器中的某个端口映射到本地的某个端口上</span><br><span class="line">-P				# 随机指定端口</span><br><span class="line"></span><br><span class="line">-----------------------------------------------------------------------------</span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动并进入容器</span></span><br><span class="line">[root@localhost ~]# docker run -it centos /bin/bash</span><br><span class="line">[root@83089d026ece /]# ls</span><br><span class="line">bin  dev  etc  home  lib  lib64  lost+found  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var</span><br><span class="line"><span class="meta">#</span><span class="bash"> 从容器中退回主机</span></span><br><span class="line">[root@83089d026ece /]# exit</span><br><span class="line">exit</span><br></pre></td></tr></table></figure>

<ul>
<li>退出容器</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">exit		# 退出并停止容器</span><br><span class="line">Ctrl+P+Q	# 退出不停止容器</span><br></pre></td></tr></table></figure>

<ul>
<li>列出所有运行的容器</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker ps		# 列出当前所有运行的容器</span><br><span class="line">docker ps -a	# 列出当前所有运行的容器 + 过去运行的容器</span><br><span class="line">docker ps -aq	# -q ： 只显示容器编号</span><br></pre></td></tr></table></figure>

<ul>
<li>删除容器</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker rm 容器id		# 删除指定容器（不能删除正在运行的容器）</span><br><span class="line">docker rm -f 容器id	# 删除指定容器（可以强制删除正在运行的容器）</span><br><span class="line">docker rm -f $(docker ps -aq)		# 删除所有容器</span><br></pre></td></tr></table></figure>

<ul>
<li>启动和停止容器</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker start 容器id		# 启动容器</span><br><span class="line">docker restart 容器id		# 重启容器</span><br><span class="line">docker stop 容器id		# 停止当前正在运行的容器</span><br><span class="line">docker kill 容器id		# 强制停止当前正在运行的容器</span><br></pre></td></tr></table></figure>



<hr>
<ul>
<li>问题</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 使用后台方式运行容器</span></span><br><span class="line">docker run -d centos</span><br><span class="line"><span class="meta">#</span><span class="bash"> 但查看时发现容器没有运行</span></span><br><span class="line">docker ps</span><br><span class="line"><span class="meta">#</span><span class="bash"> 原因：docker发现没有应用，会自动停止</span></span><br></pre></td></tr></table></figure>

<hr>
<ul>
<li>查看日志</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker logs -f -t 容器编号					# 显示所有日志	</span><br><span class="line">docker logs -f -t --tail 条数 容器编号		# 显示指定条数日志</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 测试</span></span><br><span class="line">[root@localhost ~]# docker logs -f -t --tail 10 ca683a40c363</span><br></pre></td></tr></table></figure>

<ul>
<li>查看容器中的进程信息</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker top 容器id</span><br><span class="line"></span><br><span class="line">[root@localhost ~]# docker top ca683a40c363</span><br></pre></td></tr></table></figure>

<ul>
<li>查看镜像的元数据</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker inspect 容器id</span><br></pre></td></tr></table></figure>



<hr>
<ul>
<li><strong>进入当前正在运行的容器</strong></li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 方式一 ： docker <span class="built_in">exec</span> -it 容器id /bin/bash</span></span><br><span class="line">[root@localhost ~]# docker ps</span><br><span class="line">CONTAINER ID   IMAGE     COMMAND</span><br><span class="line">ca683a40c363   centos    &quot;/bin/bash&quot;       </span><br><span class="line">[root@localhost ~]# docker exec -it ca683a40c363 /bin/bash</span><br><span class="line">[root@ca683a40c363 /]# ls</span><br><span class="line">bin  dev  etc  home  lib  lib64  lost+found  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var</span><br><span class="line">[root@ca683a40c363 /]# ps -ef</span><br><span class="line">UID         PID   PPID  C STIME TTY          TIME CMD</span><br><span class="line">root          1      0  0 14:16 pts/0    00:00:00 /bin/bash</span><br><span class="line">root         15      0  0 14:38 pts/1    00:00:00 /bin/bash</span><br><span class="line">root         30     15  0 14:39 pts/1    00:00:00 ps -ef</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 方式二 ： docker attach 容器id</span></span><br><span class="line">[root@localhost ~]# docker attach ca683a40c363 </span><br><span class="line">。。。。。。正在执行的代码。。。。。。</span><br><span class="line"></span><br><span class="line">----------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">docker exec			# 进入容器后开启一个新的终端，可以在里面操作（常用）</span><br><span class="line">docker attach		# 进入容器正在执行的终端，不会开启新的进程</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>从容器内拷贝文件到主机</strong></li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost home]# docker attach ca683a40c363</span><br><span class="line">[root@ca683a40c363 /]# cd /home</span><br><span class="line">[root@ca683a40c363 home]# ls</span><br><span class="line">[root@ca683a40c363 home]# touch first_test.java			# 新建文件</span><br><span class="line">[root@ca683a40c363 home]# ls</span><br><span class="line">first_test.java</span><br><span class="line">[root@ca683a40c363 home]# exit  </span><br><span class="line">exit		# 容器停止也没关系，只要存在就能拷贝</span><br><span class="line">[root@localhost home]# docker cp ca683a40c363:/home/first_test.java /home</span><br><span class="line">[root@localhost home]# ls</span><br><span class="line">first_test.java</span><br></pre></td></tr></table></figure>



<img src="https://gitee.com/KIMTOU/img/raw/master/20211017002816.png" alt="dockercmd" style="zoom: 67%;" />

<br>

<h2 id="部署实战"><a href="#部署实战" class="headerlink" title="部署实战"></a>部署实战</h2><h4 id="部署nginx"><a href="#部署nginx" class="headerlink" title="部署nginx"></a>部署nginx</h4><p>1、搜索镜像（docker hub或使用docker search）</p>
<p>2、docker pull nginx</p>
<p>3、运行测试</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> -d 后台运行  --name 给容器命名		-p 主机端口:容器端口</span></span><br><span class="line">[root@localhost ~]# docker run -d --name nginx01 -p 3344:80 nginx</span><br><span class="line">eb9f48472ee95a78b144180884e2207bf3ab37d55beae4564411ae66df036bdc</span><br><span class="line">[root@localhost ~]# docker ps</span><br><span class="line">CONTAINER ID   IMAGE     COMMAND                  PORTS                  NAMES</span><br><span class="line">eb9f48472ee9   nginx     &quot;/docker-entrypoint.…&quot;   0.0.0.0:3344-&gt;80/tcp   nginx01</span><br><span class="line">[root@localhost ~]# curl localhost:3344</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 进入容器</span></span><br><span class="line">[root@localhost ~]# docker exec -it nginx01 /bin/bash</span><br><span class="line">root@eb9f48472ee9:/# whereis nginx</span><br><span class="line">nginx: /usr/sbin/nginx /usr/lib/nginx /etc/nginx /usr/share/nginx</span><br><span class="line">root@eb9f48472ee9:/# cd /etc/nginx</span><br><span class="line">root@eb9f48472ee9:/etc/nginx# ls</span><br><span class="line">conf.d	fastcgi_params	koi-utf  koi-win  mime.types  modules  nginx.conf  scgi_params	uwsgi_params  win-utf</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 停止容器</span></span><br><span class="line">root@eb9f48472ee9:/etc/nginx# exit</span><br><span class="line">exit</span><br><span class="line">[root@localhost ~]# docker stop nginx01				# stop 容器id或容器names</span><br><span class="line">nginx01</span><br></pre></td></tr></table></figure>

<br>

<h4 id="部署tomcat"><a href="#部署tomcat" class="headerlink" title="部署tomcat"></a>部署tomcat</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 测试使用命令</span></span><br><span class="line">docker run -it --rm tomcat:9.0</span><br><span class="line"><span class="meta">#</span><span class="bash"> docker run -it --rm  用完就删除容器（一般测试时使用）（删除后镜像还在）</span></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 一般使用</span></span><br><span class="line">docker pull tomcat:9.0</span><br><span class="line">docker run -d -p 3355:8080 --name tomcat01 tomcat:9.0</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 测试访问时发现无法访问</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 发现问题</span></span><br><span class="line">[root@localhost ~]# docker exec -it tomcat01 /bin/bash</span><br><span class="line">root@4b6db47cca38:/usr/local/tomcat# ls</span><br><span class="line">BUILDING.txt	 LICENSE  README.md	 RUNNING.txt  conf  logs	    temp     webapps.dist</span><br><span class="line">CONTRIBUTING.md  NOTICE   RELEASE-NOTES  bin	      lib   native-jni-lib  webapps  work</span><br><span class="line">root@4b6db47cca38:/usr/local/tomcat# cd webapps</span><br><span class="line">root@4b6db47cca38:/usr/local/tomcat/webapps# ls</span><br><span class="line"><span class="meta">#</span><span class="bash"> webapps目录下为空（因为阿里云镜像只是保证最小可运行环境）</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 应用都放在webapps.dist目录下</span></span><br><span class="line">root@4b6db47cca38:/usr/local/tomcat/webapps# cd ..</span><br><span class="line">root@4b6db47cca38:/usr/local/tomcat# ls</span><br><span class="line">BUILDING.txt	 LICENSE  README.md	 RUNNING.txt  conf  logs	    temp     webapps.dist</span><br><span class="line">CONTRIBUTING.md  NOTICE   RELEASE-NOTES  bin	      lib   native-jni-lib  webapps  work</span><br><span class="line">root@4b6db47cca38:/usr/local/tomcat# cd webapps.dist/</span><br><span class="line">root@4b6db47cca38:/usr/local/tomcat/webapps.dist# ls</span><br><span class="line">ROOT  docs  examples  host-manager  manager</span><br><span class="line"><span class="meta">#</span><span class="bash"> 进行拷贝</span></span><br><span class="line">root@4b6db47cca38:/usr/local/tomcat# cp -r webapps.dist/* webapps</span><br></pre></td></tr></table></figure>

<br>

<h4 id="部署es"><a href="#部署es" class="headerlink" title="部署es"></a>部署es</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> es非常耗内存</span></span><br><span class="line">docker run -d --name elasticsearch  -p 9200:9200 -p 9300:9300 -e &quot;discovery.type=single-node&quot; elasticsearch:7.6.1</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看cpu占用</span></span><br><span class="line">docker stats 969c0b25f00e</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 修改配置</span></span><br><span class="line">docker run -d --name elasticsearch01  -p 9200:9200 -p 9300:9300 -e &quot;discovery.type=single-node&quot; -e ES_JAVA_OPTS=&quot;-Xms64m -Xmx256m&quot;  elasticsearch:7.6.1</span><br><span class="line"></span><br><span class="line">docker run -d --name elasticsearch  -p 9200:9200 -p 9300:9300 -e &quot;discovery.type=single-node&quot; -e ES_JAVA_OPTS=&quot;-Xms64m -Xmx128m&quot; -v /mydata/elasticsearch/data:/usr/share/elasticsearch/data -v /mydata/elasticsearch/plugins:/usr/share/elasticsearch/plugins elasticsearch:7.6.1</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 访问</span></span><br><span class="line">curl localhost:9200</span><br></pre></td></tr></table></figure>

<br>

<h4 id="docker可视化"><a href="#docker可视化" class="headerlink" title="docker可视化"></a>docker可视化</h4><ul>
<li>安装portainer（docker图形化界面管理工具）</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d -p 9000:9000 \</span><br><span class="line">--restart=always -v /var/run/docker.sock:/var/run/docker.sock --privileged=true portainer/portainer</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 访问测试</span></span><br><span class="line">http://192.168.132.3:9000</span><br></pre></td></tr></table></figure>

<br>

<h2 id="镜像原理"><a href="#镜像原理" class="headerlink" title="镜像原理"></a>镜像原理</h2><p><strong>镜像：</strong></p>
<p>镜像是一种轻量级、可执行的独立软件保，用来打包软件运行环境和基于运行环境开发的软件，他包含运行某个软件所需的所有内容，包括代码、运行时库、环境变量和配置文件</p>
<p><strong>联合文件系统</strong></p>
<p>UnionFs（联合文件系统）：Union文件系统（UnionFs）是一种分层、轻量级并且高性能的文件系统，他支持对文件系统的修改作为一次提交来一层层的叠加，同时可以将不同目录挂载到同一个虚拟文件系统下（ unite several directories into a single virtual filesystem)。Union文件系统是  Docker镜像的基础。镜像可以通过分层来进行继承，基于基础镜像（没有父镜像），可以制作各种具体的应用镜像<br>特性：一次同时加载多个文件系统，但从外面看起来，只能看到一个文件系统，联合加载会把各层文件系统叠加起来，这样最终的文件系统会包含所有底层的文件和目录</p>
<p><strong>Docker镜像加载原理：</strong></p>
<p>docker的镜像实际上由一层一层的文件系统组成，这种层级的文件系统UnionFS。<br>boots(boot file  system）主要包含 bootloader和 Kernel, bootloader主要是引导加 kernel,  Linux刚启动时会加bootfs文件系统，在 Docker镜像的最底层是  boots。这一层与我们典型的Linux/Unix系统是一样的，包含boot加載器和内核。当boot加载完成之后整个内核就都在内存中了，此时内存的使用权已由 bootfs转交给内核，此时系统也会卸载bootfs。<br>rootfs（root file system),在 bootfs之上。包含的就是典型 Linux系统中的/dev,/proc,/bin,/etc等标准目录和文件。 rootfs就是各种不同的操作系统发行版，比如 Ubuntu, Centos等等。</p>
<p><strong>分层理解：</strong></p>
<p>所有的 Docker镜像都起始于一个基础镜像层，当进行修改或培加新的内容时，就会在当前镜像层之上，创建新的镜像层。</p>
<blockquote>
<p>特点：</p>
</blockquote>
<p>Docker 镜像都是只读的，当容器启动时，一个新的可写层加载到镜像的顶部！</p>
<p>这一层就是我们通常说的容器层，容器之下的都叫镜像层！</p>
<br>

<h4 id="commit镜像"><a href="#commit镜像" class="headerlink" title="commit镜像"></a>commit镜像</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker commit 提交容器成为一个新的副本</span><br><span class="line">docker commit -m&quot;提交的描述信息&quot; -a&quot;作者&quot; 容器id 目标镜像名:tag</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 测试</span></span><br><span class="line">1、启动一个默认的tomcat</span><br><span class="line">2、发现没有webapps</span><br><span class="line">3、进行拷贝</span><br><span class="line">4、使用commit提交该修改过的镜像</span><br><span class="line"><span class="meta">#</span><span class="bash"> 类似于VM里的快照</span></span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/KIMTOU/img/raw/master/20211017002941.PNG" alt="docker_commit"></p>
<br>

<h2 id="容器数据卷"><a href="#容器数据卷" class="headerlink" title="容器数据卷"></a>容器数据卷</h2><p>在Docker容器的实际使用中，经常会遇到容器的数据持久化，容器之间的数据共享等问题，通常我们有两种解决方案：</p>
<ul>
<li>1、数据卷（Data Volumes）：就是将容器内数据直接映射到本地主机环境的指定文件目录之中，可以理解为容器挂载一个虚拟数据卷然后映射到一个主机目录中</li>
<li>2、数据卷容器（Data Volume Containers）：用专门的容器来挂载数据卷，其他容器通过挂载这个父容器来实现数据共享，这个专门挂载数据卷的容器就是数据卷容器，简单的总结就是有一个容器来专门管理数据的持久化和容器之间数据共享</li>
</ul>
<p>前者常用于单一容器数据持久化，后者常用于多容器之间的数据共享和数据持久化</p>
<br>

<h4 id="数据卷"><a href="#数据卷" class="headerlink" title="数据卷"></a>数据卷</h4><blockquote>
<p>方式一：直接使用命令来挂载 -v</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -it -v 主机目录:容器目录</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 测试</span></span><br><span class="line">[root@localhost ~]# docker run -it -v /home/test:/home centos /bin/bash</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 可通过docker inspect 容器id 查看是否挂载</span></span><br><span class="line"></span><br><span class="line">&quot;Mounts&quot;: [</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;Type&quot;: &quot;bind&quot;,</span><br><span class="line">                &quot;Source&quot;: &quot;/home/test&quot;,</span><br><span class="line">                &quot;Destination&quot;: &quot;/home&quot;,</span><br><span class="line">                &quot;Mode&quot;: &quot;&quot;,</span><br><span class="line">                &quot;RW&quot;: true,</span><br><span class="line">                &quot;Propagation&quot;: &quot;rprivate&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        ],</span><br></pre></td></tr></table></figure>

<br>

<h4 id="实战MySQL"><a href="#实战MySQL" class="headerlink" title="实战MySQL"></a>实战MySQL</h4><ul>
<li>解决MySQL数据持久化问题</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-d 后台运行</span><br><span class="line">-p 端口映射</span><br><span class="line">-v 数据卷挂载</span><br><span class="line">-e 环境配置</span><br><span class="line">--name 容器名字</span><br><span class="line">[root@localhost ~]# docker run -d -p 3306:3306 -v /home/mysql/conf:/etc/mysql/conf.d -v /home/mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 --name my_mysql mysql:5.7</span><br></pre></td></tr></table></figure>

<br>

<h4 id="初始DockerFile"><a href="#初始DockerFile" class="headerlink" title="初始DockerFile"></a>初始DockerFile</h4><blockquote>
<p>方式二：生成一个镜像时就进行挂载</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost docker-test-volume]# pwd</span><br><span class="line">/home/docker-test-volume</span><br><span class="line"><span class="meta">#</span><span class="bash"> 编写dockerfile文件</span></span><br><span class="line">[root@localhost docker-test-volume]# vim dockerfile1</span><br><span class="line">[root@localhost docker-test-volume]# cat dockerfile1 </span><br><span class="line">FROM centos</span><br><span class="line"></span><br><span class="line">VOLUME [&quot;volume1&quot;,&quot;volume2&quot;]				# 匿名挂载</span><br><span class="line"></span><br><span class="line">CMD echo &quot;----end----&quot;</span><br><span class="line">CMD /bin/bash</span><br><span class="line"><span class="meta">#</span><span class="bash"> 构建镜像</span></span><br><span class="line">[root@localhost docker-test-volume]# docker build -f dockerfile1 -t kim/centos .</span><br><span class="line">Successfully built 684169834073</span><br><span class="line">Successfully tagged kim/centos:latest</span><br><span class="line">[root@localhost docker-test-volume]# docker images</span><br><span class="line">REPOSITORY            TAG       IMAGE ID       CREATED             SIZE</span><br><span class="line">kim/centos            latest    684169834073   52 seconds ago      209MB</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 启动容器</span></span><br><span class="line">[root@localhost docker-test-volume]# docker run -it 684169834073 /bin/bash</span><br><span class="line">[root@2a70b06f1bdc /]# ls -l</span><br><span class="line">total 0</span><br><span class="line">lrwxrwxrwx   1 root root   7 Nov  3 15:22 bin -&gt; usr/bin</span><br><span class="line">drwxr-xr-x   5 root root 360 Feb 17 15:22 dev</span><br><span class="line">drwxr-xr-x   1 root root  66 Feb 17 15:22 etc</span><br><span class="line">drwxr-xr-x   2 root root   6 Nov  3 15:22 home</span><br><span class="line">lrwxrwxrwx   1 root root   7 Nov  3 15:22 lib -&gt; usr/lib</span><br><span class="line">lrwxrwxrwx   1 root root   9 Nov  3 15:22 lib64 -&gt; usr/lib64</span><br><span class="line">drwx------   2 root root   6 Dec  4 17:37 lost+found</span><br><span class="line">drwxr-xr-x   2 root root   6 Nov  3 15:22 media</span><br><span class="line">drwxr-xr-x   2 root root   6 Nov  3 15:22 mnt</span><br><span class="line">drwxr-xr-x   2 root root   6 Nov  3 15:22 opt</span><br><span class="line">dr-xr-xr-x 115 root root   0 Feb 17 15:22 proc</span><br><span class="line">dr-xr-x---   2 root root 162 Dec  4 17:37 root</span><br><span class="line">drwxr-xr-x  11 root root 163 Dec  4 17:37 run</span><br><span class="line">lrwxrwxrwx   1 root root   8 Nov  3 15:22 sbin -&gt; usr/sbin</span><br><span class="line">drwxr-xr-x   2 root root   6 Nov  3 15:22 srv</span><br><span class="line">dr-xr-xr-x  13 root root   0 Feb 17 14:49 sys</span><br><span class="line">drwxrwxrwt   7 root root 145 Dec  4 17:37 tmp</span><br><span class="line">drwxr-xr-x  12 root root 144 Dec  4 17:37 usr</span><br><span class="line">drwxr-xr-x  20 root root 262 Dec  4 17:37 var</span><br><span class="line">drwxr-xr-x   2 root root   6 Feb 17 15:22 volume1		# 生成镜像时自动挂载（数据卷目录）</span><br><span class="line">drwxr-xr-x   2 root root   6 Feb 17 15:22 volume2</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看外部同步的目录</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用docker inspect查看卷挂载的路径</span></span><br><span class="line">&quot;Mounts&quot;: [</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;Type&quot;: &quot;volume&quot;,</span><br><span class="line">                &quot;Name&quot;: &quot;3d62dfe2c6f5da3091d52cc64f105c98e4196c1861d1544d9bac2be8a8391c30&quot;,</span><br><span class="line">                &quot;Source&quot;: &quot;/var/lib/docker/volumes/3d62dfe2c6f5da3091d52cc64f105c98e4196c1861d1544d9bac2be8a8391c30/_data&quot;,			容器外的数据卷目录</span><br><span class="line">                &quot;Destination&quot;: &quot;volume2&quot;,</span><br><span class="line">                &quot;Driver&quot;: &quot;local&quot;,</span><br><span class="line">                &quot;Mode&quot;: &quot;&quot;,</span><br><span class="line">                &quot;RW&quot;: true,</span><br><span class="line">                &quot;Propagation&quot;: &quot;&quot;</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;Type&quot;: &quot;volume&quot;,</span><br><span class="line">                &quot;Name&quot;: &quot;2e889d6623ada2313d0502f6e2a9d702a4995551994f42a37eefc12dee358220&quot;,</span><br><span class="line">                &quot;Source&quot;: &quot;/var/lib/docker/volumes/2e889d6623ada2313d0502f6e2a9d702a4995551994f42a37eefc12dee358220/_data&quot;,			容器外的数据卷目录</span><br><span class="line">                &quot;Destination&quot;: &quot;volume1&quot;,</span><br><span class="line">                &quot;Driver&quot;: &quot;local&quot;,</span><br><span class="line">                &quot;Mode&quot;: &quot;&quot;,</span><br><span class="line">                &quot;RW&quot;: true,</span><br><span class="line">                &quot;Propagation&quot;: &quot;&quot;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">[root@localhost _data]# cd /var/lib/docker/volumes/2e889d6623ada2313d0502f6e2a9d702a4995551994f42a37eefc12dee358220/_data</span><br><span class="line">[root@localhost _data]# ls</span><br><span class="line">container.txt</span><br></pre></td></tr></table></figure>

<br>

<h4 id="数据卷容器"><a href="#数据卷容器" class="headerlink" title="数据卷容器"></a>数据卷容器</h4><ul>
<li><p>作用：实现容器间的数据共享</p>
</li>
<li><p>应用：多个mysql同步数据</p>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> docker01作为父容器</span></span><br><span class="line">[root@localhost ~]# docker run -it --name docker01 kim/centos</span><br><span class="line">[root@467f8f8d46af /]# ls -l</span><br><span class="line">......</span><br><span class="line">drwxr-xr-x   2 root root   6 Feb 18 01:49 volume1</span><br><span class="line">drwxr-xr-x   2 root root   6 Feb 18 01:49 volume2</span><br><span class="line">[root@localhost ~]# docker run -it --name docker02 --volumes-from docker01 kim/centos</span><br><span class="line">[root@localhost ~]# docker run -it --name docker03 --volumes-from docker01 kim/centos</span><br></pre></td></tr></table></figure>

<br>

<h2 id="DockerFile"><a href="#DockerFile" class="headerlink" title="DockerFile"></a>DockerFile</h2><p>Dockerfile 是一个用来构建镜像的文本文件，文本内容包含了一条条构建镜像所需的指令和说明。</p>
<img src="https://gitee.com/KIMTOU/img/raw/master/20211019211654.jpg" alt="Dockerfile" style="zoom: 67%;" />



<h4 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">FROM		# 基础镜像</span><br><span class="line">MAINTAINER	# 维护者信息（姓名+邮箱）</span><br><span class="line">COPY		# 复制指令，将文件拷贝到镜像中</span><br><span class="line">ADD			# 添加内容</span><br><span class="line">WORKDIR		# 镜像的工作目录</span><br><span class="line">VOLUME		# 挂载目录</span><br><span class="line">EXPOSE		# 暴露端口（与-p作用相同）</span><br><span class="line">RUN			# 镜像构建时需要运行的命令</span><br><span class="line">ENV			# 设置环境变量</span><br><span class="line">CMD			# 指定容器启动时要运行的命令</span><br><span class="line"><span class="meta">#</span><span class="bash"> 类似于 RUN 指令，用于运行程序，但二者运行的时间点不同:</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> CMD 在 docker run 时运行</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> RUN 是在 docker build</span></span><br><span class="line">ENTRYPOINT	</span><br><span class="line"><span class="meta">#</span><span class="bash"> 类似于 CMD 指令，但其不会被 docker run 的命令行参数指定的指令所覆盖（即只有最后一个生效），而且这些命令行参数会被当作参数送给 ENTRYPOINT 指令指定的程序（即可追加命令）</span></span><br><span class="line">ONBUILD		</span><br><span class="line"><span class="meta">#</span><span class="bash"> 在本次构建镜像的过程中不会执行（假设镜像为 test-build）。当有新的 Dockerfile 使用了之前构建的镜像 FROM test-build ，这是执行新镜像的 Dockerfile 构建时候，会执行 test-build 的 Dockerfile 里的 ONBUILD 指定的命令。</span></span><br></pre></td></tr></table></figure>

<br>

<h4 id="构建centos"><a href="#构建centos" class="headerlink" title="构建centos"></a>构建centos</h4><ul>
<li>初始（无法使用vim、ifconfig等）</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# docker run -it centos</span><br><span class="line">[root@0fda862a6d76 /]# vim</span><br><span class="line">bash: vim: command not found</span><br><span class="line">[root@0fda862a6d76 /]# ifconfig</span><br><span class="line">bash: ifconfig: command not found</span><br></pre></td></tr></table></figure>

<ul>
<li>添加内容</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 编写DockerFile的文件</span></span><br><span class="line">[root@localhost dockerfile]# vim my_centos</span><br><span class="line">[root@localhost dockerfile]# cat my_centos </span><br><span class="line">FROM centos</span><br><span class="line">MAINTAINER KimTou&lt;752160655@qq.com&gt;</span><br><span class="line"></span><br><span class="line">ENV MYPATH /usr/local</span><br><span class="line">WORKDIR $MYPATH					# 默认的工作目录是/</span><br><span class="line"></span><br><span class="line">RUN yum -y install vim</span><br><span class="line">RUN yum -y install net-tools</span><br><span class="line"></span><br><span class="line">EXPOSE 80</span><br><span class="line"></span><br><span class="line">CMD echo $MYPATH</span><br><span class="line">CMD echo &quot;------end------&quot;</span><br><span class="line">CMD /bin/bash</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 通过文件构建镜像</span></span><br><span class="line">[root@localhost dockerfile]# docker build -f my_centos -t mycentos:1.0 .</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> docker bild -f dockerfile文件路径 -t 镜像名:[tag] .</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 运行测试</span></span><br><span class="line">[root@localhost dockerfile]# docker run -it mycentos:1.0</span><br><span class="line">[root@3ee183346afd local]# pwd</span><br><span class="line">/usr/local</span><br><span class="line">[root@3ee183346afd local]# ifconfig</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看本地变更历史</span></span><br><span class="line">docker history 镜像id</span><br></pre></td></tr></table></figure>

<br>

<h4 id="CMD与ENTRYPOINT"><a href="#CMD与ENTRYPOINT" class="headerlink" title="CMD与ENTRYPOINT"></a>CMD与ENTRYPOINT</h4><ul>
<li>测试CMD</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 编写dockerfile文件</span></span><br><span class="line">[root@localhost dockerfile]# vim dockerfile-cmd-test</span><br><span class="line">FROM centos</span><br><span class="line">CMD [&quot;ls&quot;,&quot;-a&quot;]</span><br><span class="line"><span class="meta">#</span><span class="bash"> 构建镜像</span></span><br><span class="line">[root@localhost dockerfile]# docker build -f dockerfile-cmd-test -t cmdtest .</span><br><span class="line">Successfully built 23e5ab5b3d93</span><br><span class="line">Successfully tagged cmdtest:latest</span><br><span class="line"><span class="meta">#</span><span class="bash"> run运行，发现 ls -a 命令生效</span></span><br><span class="line">[root@localhost dockerfile]# docker run 23e5ab5b3d93</span><br><span class="line">.</span><br><span class="line">..</span><br><span class="line">.dockerenv</span><br><span class="line">bin</span><br><span class="line">dev</span><br><span class="line">etc</span><br><span class="line">home</span><br><span class="line">等等</span><br><span class="line"><span class="meta">#</span><span class="bash"> 此时追加一个命令<span class="string">&quot;-l&quot;</span>（即为了形成ls -al），却报错</span></span><br><span class="line">[root@localhost dockerfile]# docker run 23e5ab5b3d93 -l</span><br><span class="line">docker: Error response from daemon: OCI runtime create failed: container_linux.go:370: starting container process caused: exec: &quot;-l&quot;: executable file not found in $PATH: unknown.</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 原因分析：CMD的情况下，-l替换了CMD [<span class="string">&quot;ls&quot;</span>,<span class="string">&quot;-a&quot;</span>]命令，而-l不是命令，所以报错</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 想正确执行，需使用</span></span><br><span class="line">[root@localhost dockerfile]# docker run 23e5ab5b3d93 ls -al</span><br></pre></td></tr></table></figure>

<ul>
<li>测试ENTRYPOINT</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost dockerfile]# vim dockerfile-cmd-entrypoint</span><br><span class="line">FROM centos</span><br><span class="line">ENTRYPOINT [&quot;ls&quot;,&quot;-a&quot;]</span><br><span class="line">[root@localhost dockerfile]# docker build -f dockerfile-cmd-entrypoint -t entrypoint .</span><br><span class="line">Successfully built fd019392b084</span><br><span class="line">Successfully tagged entrypoint:latest</span><br><span class="line">[root@localhost dockerfile]# docker run fd019392b084</span><br><span class="line">.</span><br><span class="line">..</span><br><span class="line">.dockerenv</span><br><span class="line">bin</span><br><span class="line">dev</span><br><span class="line">etc</span><br><span class="line">home</span><br><span class="line">等等</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 进行追加命令，直接拼接在ENTRYPOINT命令后面</span></span><br><span class="line">[root@localhost dockerfile]# docker run fd019392b084 -l</span><br><span class="line">total 0</span><br><span class="line">drwxr-xr-x   1 root root   6 Feb 17 14:54 .</span><br><span class="line">drwxr-xr-x   1 root root   6 Feb 17 14:54 ..</span><br><span class="line">-rwxr-xr-x   1 root root   0 Feb 17 14:54 .dockerenv</span><br><span class="line">lrwxrwxrwx   1 root root   7 Nov  3 15:22 bin -&gt; usr/bin</span><br><span class="line">drwxr-xr-x   5 root root 340 Feb 17 14:54 dev</span><br><span class="line">drwxr-xr-x   1 root root  66 Feb 17 14:54 etc</span><br><span class="line">drwxr-xr-x   2 root root   6 Nov  3 15:22 home</span><br><span class="line">等等</span><br></pre></td></tr></table></figure>

<br>

<h4 id="制作tomcat镜像"><a href="#制作tomcat镜像" class="headerlink" title="制作tomcat镜像"></a>制作tomcat镜像</h4><p>1、准备镜像文件，tomcat压缩包、jdk压缩包</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost tomcat]# ls</span><br><span class="line">apache-tomcat-9.0.38.tar.gz  jdk-8u281-linux-x64.tar.gz</span><br><span class="line">[root@localhost tomcat]# pwd</span><br><span class="line">/home/build/tomcat</span><br></pre></td></tr></table></figure>

<p>2、编写dockerfile文件( 名字为Dockerfile，build就会自动寻找，不需要使用 -f 命令来指定)</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">FROM centos</span><br><span class="line">MAINTAINER KimTou&lt;752160655@qq.com&gt;</span><br><span class="line"></span><br><span class="line">COPY README.txt /usr/loacl/README.txt</span><br><span class="line"></span><br><span class="line">ADD jdk-8u281-linux-x64.tar.gz /usr/local</span><br><span class="line">ADD apache-tomcat-9.0.38.tar.gz /usr/local</span><br><span class="line"></span><br><span class="line">RUN yum -y install vim</span><br><span class="line"></span><br><span class="line">ENV MYPATH /usr/local</span><br><span class="line">WORKDIR $MYPATH</span><br><span class="line"></span><br><span class="line">ENV JAVA_HOME /usr/local/jdk1.8.0_281</span><br><span class="line">ENV CLASSPATH $JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar</span><br><span class="line">ENV CATALINA_HOME /usr/local/apache-tomcat-9.0.38</span><br><span class="line">ENV CATALINA_BASE /usr/local/apache-tomcat-9.0.38</span><br><span class="line">ENV PATH $PATH:$JAVA_HOME/bin:$CATALINA_HOME/lib:$CATALINA_HOME/bin</span><br><span class="line"></span><br><span class="line">EXPOSE 8080</span><br><span class="line"></span><br><span class="line">CMD /usr/local/apache-tomcat-9.0.38/bin/startup.sh &amp;&amp; tail -F /usr/local/apache-tomcat-9.0.38/bin/logs/catalina.out</span><br></pre></td></tr></table></figure>

<p>3、构建镜像</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost tomcat]# docker build -t diytomcat .</span><br></pre></td></tr></table></figure>

<p>4、启动镜像</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost tomcat]# docker run -d -p 8080:8080 --name diytomcat -v /home/build/tomcat/test:/usr/local/apache-tomcat-9.0.38/webapps/test -v /home/build/tomcat/tomcatlogs:/usr/local/apache-tomcat-9.0.38/logs diytomcat </span><br><span class="line">b894eae2b2f0ad6650c1ef15c1079f83f80539acb9ce2fc15f1f5c8f48cfc930</span><br><span class="line">[root@localhost tomcat]# docker exec -it b894eae2b2f0a /bin/bash</span><br></pre></td></tr></table></figure>

<p>5、访问测试</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl localhost:8080				# 内部测试</span><br><span class="line">http://192.168.132.3:8080/		# 外部测试</span><br></pre></td></tr></table></figure>

<p>6、发布项目（由于做了卷挂载，我们直接在本地编写项目就可以发布了）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost tomcat]# ls</span><br><span class="line">apache-tomcat-9.0.38.tar.gz  Dockerfile  jdk-8u281-linux-x64.tar.gz  README.txt  test  tomcatlogs</span><br><span class="line">[root@localhost tomcat]# cd test</span><br><span class="line">[root@localhost test]# ls</span><br><span class="line">[root@localhost test]# pwd</span><br><span class="line">/home/build/tomcat/test</span><br><span class="line">[root@localhost test]# mkdir WEB-INF</span><br><span class="line">[root@localhost test]# ls</span><br><span class="line">WEB-INF</span><br><span class="line">[root@localhost test]# cd WEB-INF/</span><br><span class="line">[root@localhost WEB-INF]# vim web.xml</span><br><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;web-app xmlns=&quot;http://java.sun.com/xml/ns/javaee&quot;</span><br><span class="line">           xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">           xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/javaee</span><br><span class="line">                               http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd&quot;</span><br><span class="line">           version=&quot;2.5&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;/web-app&gt;</span><br><span class="line">[root@localhost WEB-INF]# cd ..</span><br><span class="line">[root@localhost test]# ls</span><br><span class="line">WEB-INF</span><br><span class="line">[root@localhost test]# vim index.jsp</span><br><span class="line">&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot;</span><br><span class="line">    pageEncoding=&quot;UTF-8&quot;%&gt;</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line">&lt;title&gt;hello，我的tomcat&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">Hello World!&lt;br/&gt;</span><br><span class="line">&lt;%</span><br><span class="line">System.out.println(&quot;-----my test web logs-----&quot;);</span><br><span class="line"><span class="meta">%</span><span class="bash">&gt;</span></span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>7、访问测试</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">http:<span class="regexp">//</span><span class="number">192.168</span>.<span class="number">132.3</span>:<span class="number">8080</span><span class="regexp">/test/</span></span><br></pre></td></tr></table></figure>

<br>

<h4 id="发布镜像至DockerHub"><a href="#发布镜像至DockerHub" class="headerlink" title="发布镜像至DockerHub"></a>发布镜像至DockerHub</h4><ul>
<li>登录</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost tomcat]# docker login --help</span><br><span class="line"></span><br><span class="line">Usage:  docker login [OPTIONS] [SERVER]</span><br><span class="line"></span><br><span class="line">Log in to a Docker registry.</span><br><span class="line">If no server is specified, the default is defined by the daemon.</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">  -p, --password string   Password</span><br><span class="line">      --password-stdin    Take the password from stdin</span><br><span class="line">  -u, --username string   Username</span><br><span class="line">[root@localhost tomcat]# docker login -u kimtou </span><br><span class="line">Password: </span><br><span class="line">WARNING! Your password will be stored unencrypted in /root/.docker/config.json.</span><br><span class="line">Configure a credential helper to remove this warning. See</span><br><span class="line">https://docs.docker.com/engine/reference/commandline/login/#credentials-store</span><br><span class="line"></span><br><span class="line">Login Succeeded</span><br></pre></td></tr></table></figure>

<ul>
<li>docker push</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost tomcat]# docker push diytomcat</span><br><span class="line">Using default tag: latest</span><br><span class="line">The push refers to repository [docker.io/library/diytomcat]</span><br><span class="line">0b5f6503d033: Preparing </span><br><span class="line">1ca989e043c6: Preparing </span><br><span class="line">b0f9e083fd93: Preparing </span><br><span class="line">13ab4cbc0c90: Preparing </span><br><span class="line">2653d992f4ef: Preparing </span><br><span class="line">denied: requested access to the resource is denied		# 拒绝（原因：本地没有tag信息）</span><br><span class="line"><span class="meta">#</span><span class="bash"> 添加tag信息</span></span><br><span class="line">[root@localhost tomcat]# docker tag a9181af1fc76（diytomcat镜像id） kimtou/tomcat:1.0</span><br><span class="line">[root@localhost tomcat]# docker push kimtou/tomcat:1.0</span><br></pre></td></tr></table></figure>

<br>

<h2 id="Dokcer网络"><a href="#Dokcer网络" class="headerlink" title="Dokcer网络"></a>Dokcer网络</h2><h4 id="理解docker0"><a href="#理解docker0" class="headerlink" title="理解docker0"></a>理解docker0</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看内部网络地址</span></span><br><span class="line">[root@localhost ~]# ip addr</span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">    inet 127.0.0.1/8 scope host lo					# 本机回环地址</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 ::1/128 scope host </span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">2: ens33: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000</span><br><span class="line">    link/ether 00:0c:29:8b:8f:c6 brd ff:ff:ff:ff:ff:ff		# 虚拟机内网地址</span><br><span class="line">    inet 192.168.132.3/24 brd 192.168.132.255 scope global noprefixroute ens33</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 fe80::b337:5b2f:b8aa:54f7/64 scope link noprefixroute </span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">3: docker0: &lt;NO-CARRIER,BROADCAST,MULTICAST,UP&gt; mtu 1500 qdisc noqueue state DOWN group default </span><br><span class="line">    link/ether 02:42:40:82:c8:42 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 172.17.0.1/16 brd 172.17.255.255 scope global docker0		# docker0地址</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br></pre></td></tr></table></figure>

<ul>
<li>三个网卡</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# docker run -d -P --name tomcat01 tomcat:9.0</span><br><span class="line">e07dc049270c66313c2fa9d0bc3f59af5656012377ece17c887226fb68097716</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看容器的内部网络地址（不想进去/bin/bash，，只想查看网络地址，所以直接可以写ip addr）</span></span><br><span class="line">[root@localhost ~]# docker exec -it tomcat01 ip addr</span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">    inet 127.0.0.1/8 scope host lo</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">4: eth0@if5: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default </span><br><span class="line">    link/ether 02:42:ac:11:00:02 brd ff:ff:ff:ff:ff:ff link-netnsid 0</span><br><span class="line">    inet 172.17.0.2/16 brd 172.17.255.255 scope global eth0</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line"><span class="meta">#</span><span class="bash"> 发现得到一个 eth0@if5 ip地址（docker分配的）</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 发现linux可以ping通容器内部</span></span><br><span class="line">[root@localhost ~]# ping 172.17.0.2</span><br><span class="line">PING 172.17.0.2 (172.17.0.2) 56(84) bytes of data.</span><br><span class="line">64 bytes from 172.17.0.2: icmp_seq=1 ttl=64 time=0.295 ms</span><br></pre></td></tr></table></figure>

<ul>
<li>启动容器后，再次使用ip addr</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# ip addr</span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">    inet 127.0.0.1/8 scope host lo</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 ::1/128 scope host </span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">2: ens33: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000</span><br><span class="line">    link/ether 00:0c:29:8b:8f:c6 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 192.168.132.3/24 brd 192.168.132.255 scope global noprefixroute ens33</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 fe80::b337:5b2f:b8aa:54f7/64 scope link noprefixroute </span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">3: docker0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default </span><br><span class="line">    link/ether 02:42:40:82:c8:42 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 172.17.0.1/16 brd 172.17.255.255 scope global docker0</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 fe80::42:40ff:fe82:c842/64 scope link </span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">5: veth2d24b84@if4: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue master docker0 state UP group default </span><br><span class="line">    link/ether 26:e5:f5:40:f9:dc brd ff:ff:ff:ff:ff:ff link-netnsid 0</span><br><span class="line">    inet6 fe80::24e5:f5ff:fe40:f9dc/64 scope link </span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line"><span class="meta">#</span><span class="bash"> 多了 5: veth2d24b84@if4 ，这个正好对应容器的 4: eth0@if5</span></span><br></pre></td></tr></table></figure>

<ul>
<li>启动另一个容器ping容器，发现可以ping通</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# docker run -d -P --name tomcat02 tomcat:9.0</span><br><span class="line">db1d55c1d4888f7d91fe08acd742b149080982f221c7273c1c258fc8564e4add</span><br><span class="line">[root@localhost ~]# docker exec -it tomcat02 ping 172.17.0.2</span><br><span class="line">PING 172.17.0.2 (172.17.0.2) 56(84) bytes of data.</span><br><span class="line">64 bytes from 172.17.0.2: icmp_seq=1 ttl=64 time=0.132 ms</span><br></pre></td></tr></table></figure>

 <br>

<h4 id="自定义网络"><a href="#自定义网络" class="headerlink" title="自定义网络"></a>自定义网络</h4><ul>
<li>查看所有docker网络</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# docker network ls</span><br><span class="line">NETWORK ID     NAME      DRIVER    SCOPE</span><br><span class="line">86c387d828ca   bridge    bridge    local</span><br><span class="line">804bff49826a   host      host      local</span><br><span class="line">6525353ed74f   none      null      local</span><br></pre></td></tr></table></figure>

<p><strong>网络模式</strong></p>
<ul>
<li>bridge ： 桥接模式（默认）</li>
<li>none  ： 不配置网络</li>
<li>host ： 与宿主机（Linux服务器）共享网络</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 两者作用相同，使用docker0</span></span><br><span class="line">docker run -d -P --name tomcat01 tomcat:9.0</span><br><span class="line">docker run -d -P --name tomcat01 --net bridge tomcat:9.0</span><br></pre></td></tr></table></figure>

<ul>
<li>创建自定义网络</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> --driver bridge</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> --subnet 192.168.0.0/16		192.168.0.2 ~ 192.168.255.255</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> --gateway 192.168.0.1</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 创建自定义网络</span></span><br><span class="line">[root@localhost ~]# docker network create --driver bridge --subnet 192.168.0.0/16 --gateway 192.168.0.1 mynet</span><br><span class="line">5e6793046451757d49b52b93be2d655dce9673b1b4abb72918de92b716d26654</span><br><span class="line">[root@localhost ~]# docker network ls</span><br><span class="line">NETWORK ID     NAME      DRIVER    SCOPE</span><br><span class="line">86c387d828ca   bridge    bridge    local</span><br><span class="line">804bff49826a   host      host      local</span><br><span class="line">5e6793046451   mynet     bridge    local</span><br><span class="line">6525353ed74f   none      null      local</span><br></pre></td></tr></table></figure>

<ul>
<li>使用我们的自定义网络</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 启动两个容器</span></span><br><span class="line">[root@localhost ~]# docker run -d -P --name tomcat-net-01 --net mynet tomcat:9.0</span><br><span class="line">df65ecd0612fc3e4c1e1337c4f58d0d49c0289ced365e89b3cf1a8b0bfb87be3</span><br><span class="line">[root@localhost ~]# docker run -d -P --name tomcat-net-02 --net mynet tomcat:9.0</span><br><span class="line">7b73264240aec380c1ab3deb7e6d3bf773570065a8c68216b348db7afa617745</span><br><span class="line">[root@localhost ~]# docker network inspect mynet</span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;Name&quot;: &quot;mynet&quot;,</span><br><span class="line">        &quot;Id&quot;: &quot;5e6793046451757d49b52b93be2d655dce9673b1b4abb72918de92b716d26654&quot;,</span><br><span class="line">        &quot;Created&quot;: &quot;2021-02-19T12:26:58.440470651+08:00&quot;,</span><br><span class="line">        &quot;Scope&quot;: &quot;local&quot;,</span><br><span class="line">        &quot;Driver&quot;: &quot;bridge&quot;,</span><br><span class="line">        &quot;EnableIPv6&quot;: false,</span><br><span class="line">        &quot;IPAM&quot;: &#123;</span><br><span class="line">            &quot;Driver&quot;: &quot;default&quot;,</span><br><span class="line">            &quot;Options&quot;: &#123;&#125;,</span><br><span class="line">            &quot;Config&quot;: [</span><br><span class="line">                &#123;</span><br><span class="line">                    &quot;Subnet&quot;: &quot;192.168.0.0/16&quot;,</span><br><span class="line">                    &quot;Gateway&quot;: &quot;192.168.0.1&quot;</span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;Internal&quot;: false,</span><br><span class="line">        &quot;Attachable&quot;: false,</span><br><span class="line">        &quot;Ingress&quot;: false,</span><br><span class="line">        &quot;ConfigFrom&quot;: &#123;</span><br><span class="line">            &quot;Network&quot;: &quot;&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;ConfigOnly&quot;: false,</span><br><span class="line">        &quot;Containers&quot;: &#123;</span><br><span class="line">            &quot;7b73264240aec380c1ab3deb7e6d3bf773570065a8c68216b348db7afa617745&quot;: &#123;</span><br><span class="line">                &quot;Name&quot;: &quot;tomcat-net-02&quot;,</span><br><span class="line">                &quot;EndpointID&quot;: &quot;9136cf64444aeb45fbb7809d884fcf05b84e8d2d07a89cf588b5df9e70f986dc&quot;,</span><br><span class="line">                &quot;MacAddress&quot;: &quot;02:42:c0:a8:00:03&quot;,</span><br><span class="line">                &quot;IPv4Address&quot;: &quot;192.168.0.3/16&quot;,		分配的ip地址</span><br><span class="line">                &quot;IPv6Address&quot;: &quot;&quot;</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;df65ecd0612fc3e4c1e1337c4f58d0d49c0289ced365e89b3cf1a8b0bfb87be3&quot;: &#123;</span><br><span class="line">                &quot;Name&quot;: &quot;tomcat-net-01&quot;,</span><br><span class="line">                &quot;EndpointID&quot;: &quot;b8ff576a005ea18db3da7661e2e2fb65547bf4a61948bc54a3c7e74a163d0877&quot;,</span><br><span class="line">                &quot;MacAddress&quot;: &quot;02:42:c0:a8:00:02&quot;,</span><br><span class="line">                &quot;IPv4Address&quot;: &quot;192.168.0.2/16&quot;,		 分配的ip地址</span><br><span class="line">                &quot;IPv6Address&quot;: &quot;&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;Options&quot;: &#123;&#125;,</span><br><span class="line">        &quot;Labels&quot;: &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<ul>
<li>用处</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 自定义网络可以使用域名ping通，则默认的docker0不行</span></span><br><span class="line">[root@localhost ~]# docker exec -it tomcat-net-01 ping 192.168.0.3</span><br><span class="line">PING 192.168.0.3 (192.168.0.3) 56(84) bytes of data.</span><br><span class="line">64 bytes from 192.168.0.3: icmp_seq=1 ttl=64 time=0.159 ms</span><br><span class="line">[root@localhost ~]# docker exec -it tomcat-net-01 ping tomcat-net-02</span><br><span class="line">PING tomcat-net-02 (192.168.0.3) 56(84) bytes of data.</span><br><span class="line">64 bytes from tomcat-net-02.mynet (192.168.0.3): icmp_seq=1 ttl=64 time=0.077 ms</span><br></pre></td></tr></table></figure>

<ul>
<li>同时也可以让不同的集群使用不同的网络，如redis集群使用192.160.0.0，mysql集群使用192.161.0.0</li>
</ul>
<br>

<h4 id="网络连通"><a href="#网络连通" class="headerlink" title="网络连通"></a>网络连通</h4><ul>
<li>尝试ping不同网段的容器（结果：无法ping）</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# docker exec -it tomcat01 ping tomcat-net-01</span><br><span class="line">ping: tomcat-net-01: Name or service not known</span><br></pre></td></tr></table></figure>

<ul>
<li>打通docker0与mynet</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# docker network --help</span><br><span class="line"></span><br><span class="line">Usage:  docker network COMMAND</span><br><span class="line"></span><br><span class="line">Manage networks</span><br><span class="line"></span><br><span class="line">Commands:</span><br><span class="line">  connect     Connect a container to a network		# 连接一个容器到一个网络</span><br><span class="line">  create      Create a network</span><br><span class="line">  disconnect  Disconnect a container from a network</span><br><span class="line">  inspect     Display detailed information on one or more networks</span><br><span class="line">  ls          List networks</span><br><span class="line">  prune       Remove all unused networks</span><br><span class="line">  rm          Remove one or more networks</span><br></pre></td></tr></table></figure>

<ul>
<li>测试打通 tomcat01 到 mynet</li>
</ul>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 作用：将 tomcat01 放到 mynet 网络下（一个容器两个ip）</span></span><br><span class="line">[root@localhost ~]# docker network connect mynet tomcat01</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看mynet发现tomcat01已被加入</span></span><br><span class="line">[root@localhost ~]# docker network inspect mynet</span><br><span class="line">&quot;Containers&quot;: &#123;</span><br><span class="line">            &quot;69e094144858a922928b9297bd5e59c2f04914f3138e0e31e9e5623daa594792&quot;: &#123;</span><br><span class="line">                &quot;Name&quot;: &quot;tomcat01&quot;,			加入mynet</span><br><span class="line">                &quot;EndpointID&quot;: &quot;f4d4b6d389f7ceb223b60a41a8f751c283e8b0548c3a66dde632e7ccb89a11d0&quot;,</span><br><span class="line">                &quot;MacAddress&quot;: &quot;02:42:c0:a8:00:03&quot;,</span><br><span class="line">                &quot;IPv4Address&quot;: &quot;192.168.0.3/16&quot;,</span><br><span class="line">                &quot;IPv6Address&quot;: &quot;&quot;</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;df65ecd0612fc3e4c1e1337c4f58d0d49c0289ced365e89b3cf1a8b0bfb87be3&quot;: &#123;</span><br><span class="line">                &quot;Name&quot;: &quot;tomcat-net-01&quot;,</span><br><span class="line">                &quot;EndpointID&quot;: &quot;9247cf33ad07415038294d98de0875699ab0a4cd7d8c6099493eb4fdb4fd8230&quot;,</span><br><span class="line">                &quot;MacAddress&quot;: &quot;02:42:c0:a8:00:02&quot;,</span><br><span class="line">                &quot;IPv4Address&quot;: &quot;192.168.0.2/16&quot;,</span><br><span class="line">                &quot;IPv6Address&quot;: &quot;&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br></pre></td></tr></table></figure>

<br>

<h2 id="SpringBoot微服务打包Docker镜像"><a href="#SpringBoot微服务打包Docker镜像" class="headerlink" title="SpringBoot微服务打包Docker镜像"></a>SpringBoot微服务打包Docker镜像</h2><p>1、创建SpringBoot项目</p>
<p>2、打包应用</p>
<p>3、编写dockerfile</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">FROM java:8</span><br><span class="line"></span><br><span class="line">COPY *.jar app.jar</span><br><span class="line"></span><br><span class="line">CMD [&quot;--server.port=8080&quot;]</span><br><span class="line"></span><br><span class="line">EXPOSE 8080</span><br><span class="line"></span><br><span class="line">ENTRYPOINT [&quot;java&quot;,&quot;-jar&quot;,&quot;app.jar&quot;]</span><br></pre></td></tr></table></figure>

<p>4、构建镜像</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost idea]# ls</span><br><span class="line">docker-0.0.1-SNAPSHOT.jar  Dockerfile</span><br><span class="line">[root@localhost idea]# docker build -t kim-springboot .</span><br></pre></td></tr></table></figure>

<p>5、发布运行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost idea]# docker run -d -P --name kim-springboot-web kim-springboot</span><br><span class="line">4a0ac515eaac0100dc69c5ecc9b10562bc71c45902ac4f4aa79516a9ddb3d264</span><br><span class="line">[root@localhost idea]# docker ps</span><br><span class="line">CONTAINER ID   IMAGE            COMMAND                  PORTS                     NAMES</span><br><span class="line">4a0ac515eaac   kim-springboot   &quot;java -jar app.jar -…&quot;   0.0.0.0:49162-&gt;8080/tcp   kim-springboot-web</span><br><span class="line">[root@localhost idea]# curl localhost:49162</span><br><span class="line">&#123;&quot;timestamp&quot;:&quot;2021-02-19T09:34:58.322+00:00&quot;,&quot;status&quot;:404,&quot;error&quot;:&quot;Not Found&quot;,&quot;message&quot;:&quot;&quot;,&quot;path&quot;:&quot;/&quot;&#125;[root@localhost idea]# curl localhost:49162/hello</span><br><span class="line">hello,kim[root@localhost idea]# </span><br></pre></td></tr></table></figure>



<h2 id="安装Vim"><a href="#安装Vim" class="headerlink" title="安装Vim"></a>安装Vim</h2><p>当我们进入docker容器时，经常会发现容器内并没有安装vim，此时需要我们手动去进行安装。</p>
<p>1、apt-get update</p>
<p>2、apt-get install vim</p>
<p>3、cd /usr/share/vim/vim81</p>
<p>4、vim defaults.vim</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 在=前加-</span></span><br><span class="line">if has(&#x27;mouse&#x27;)</span><br><span class="line">set mouse-=a</span><br><span class="line">endif</span><br></pre></td></tr></table></figure>



<br>

<blockquote>
<p>文章内容参考狂神说：<a href="https://www.bilibili.com/video/BV1og4y1q7M4">https://www.bilibili.com/video/BV1og4y1q7M4</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>环境配置</tag>
        <tag>docker</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>MongoDB学习总结</title>
    <url>/2021/10/17/MongoDB%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="初始"><a href="#初始" class="headerlink" title="初始"></a>初始</h1><h3 id="什么是MongoDB"><a href="#什么是MongoDB" class="headerlink" title="什么是MongoDB"></a>什么是MongoDB</h3><p>MongoDB 是一个基于分布式文件存储的数据库。</p>
<p>MongoDB 将数据存储为一个文档，数据结构由键值(key=&gt;value)对组成。MongoDB 文档类似于 JSON 对象。字段值可以包含其他文档，数组及文档数组。</p>
<img src="https://gitee.com/KIMTOU/img/raw/master/20211017235512.png" style="zoom:50%;" />

<h3 id="与MySQL相比的优势"><a href="#与MySQL相比的优势" class="headerlink" title="与MySQL相比的优势"></a>与MySQL相比的优势</h3><h5 id="1、弱一致性（最终一致），更能保证用户的访问速度"><a href="#1、弱一致性（最终一致），更能保证用户的访问速度" class="headerlink" title="1、弱一致性（最终一致），更能保证用户的访问速度"></a>1、弱一致性（最终一致），更能保证用户的访问速度</h5><h5 id="2、文档结构的存储方式，高扩展性"><a href="#2、文档结构的存储方式，高扩展性" class="headerlink" title="2、文档结构的存储方式，高扩展性"></a>2、文档结构的存储方式，高扩展性</h5><p>高扩展性，存储的数据格式是json格式</p>
<h5 id="3、第三方支持丰富"><a href="#3、第三方支持丰富" class="headerlink" title="3、第三方支持丰富"></a>3、第三方支持丰富</h5><h5 id="4、性能优越"><a href="#4、性能优越" class="headerlink" title="4、性能优越"></a>4、性能优越</h5><p>MySQL在海量数据处理的时候效率会显著变慢。</p>
<p>在适量级的内存的Mongodb的性能是非常迅速的，它将热数据存储在物理内存中，使得热数据的读写变得十分快。</p>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><h5 id="1、不支持事务操作"><a href="#1、不支持事务操作" class="headerlink" title="1、不支持事务操作"></a>1、不支持事务操作</h5><h5 id="2、占用空间过大"><a href="#2、占用空间过大" class="headerlink" title="2、占用空间过大"></a>2、占用空间过大</h5><br>

<h1 id="安装下载"><a href="#安装下载" class="headerlink" title="安装下载"></a>安装下载</h1><p>下载地址：<a href="https://www.mongodb.com/try/download/community">https://www.mongodb.com/try/download/community</a></p>
<br>

<h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><p>在data目录下创建db文件夹，在mongodb的bin目录下打开cmd输入命令 <code>mongod -dbpath 所在位置</code></p>
<figure class="highlight taggerscript"><table><tr><td class="code"><pre><span class="line">D:<span class="symbol">\E</span>nvironment<span class="symbol">\M</span>ongoDB<span class="symbol">\b</span>in&gt;mongod -dbpath D:<span class="symbol">\E</span>nvironment<span class="symbol">\M</span>ongoDB<span class="symbol">\d</span>ata<span class="symbol">\d</span>b</span><br></pre></td></tr></table></figure>

<br>

<h1 id="启动运行"><a href="#启动运行" class="headerlink" title="启动运行"></a>启动运行</h1><h4 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h4><p>1、cmd输入命令 <code>net start mongodb</code></p>
<p>2、启动mongo.exe</p>
<h4 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h4><p>show dbs ：显示当前所有数据库</p>
<p>use 数据库 ：进入到指定数据库（不管有没有该数据库，都可以进入，若插入了文档，便会创建该数据库）</p>
<p>db：当前所处数据库</p>
<p>show collections：显示数据库中有多少个集合</p>
<p><img src="https://gitee.com/KIMTOU/img/raw/master/20211017233927.png" alt="image-20211017233911818"></p>
<br>

<h1 id="增删改查"><a href="#增删改查" class="headerlink" title="增删改查"></a>增删改查</h1><h2 id="数据库操作"><a href="#数据库操作" class="headerlink" title="数据库操作"></a>数据库操作</h2><h4 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a><strong>创建数据库</strong></h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">use DATABASE_NAME</span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果数据库不存在，则创建数据库，否则切换到指定数据库</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 或者插入时创建数据库</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> show dbs</span></span><br><span class="line">admin   0.000GB</span><br><span class="line">config  0.000GB</span><br><span class="line">local   0.000GB</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> db.test.insert(&#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;Kim&quot;</span>&#125;)</span></span><br><span class="line">WriteResult(&#123; &quot;nInserted&quot; : 1 &#125;)</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> show dbs</span></span><br><span class="line">admin   0.000GB</span><br><span class="line">config  0.000GB</span><br><span class="line">local   0.000GB</span><br><span class="line">test    0.000GB</span><br></pre></td></tr></table></figure>

<h4 id="删除数据库"><a href="#删除数据库" class="headerlink" title="删除数据库"></a>删除数据库</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">db.dropDatabase()</span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除当前数据库，默认为 <span class="built_in">test</span>，你可以使用 db 命令查看当前数据库名。</span></span><br></pre></td></tr></table></figure>

<br>

<h2 id="集合操作"><a href="#集合操作" class="headerlink" title="集合操作"></a>集合操作</h2><h4 id="创建集合"><a href="#创建集合" class="headerlink" title="创建集合"></a><strong>创建集合</strong></h4><p>语法格式：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">db.create<span class="constructor">Collection(<span class="params">name</span>, <span class="params">options</span>)</span></span><br></pre></td></tr></table></figure>

<p>参数说明：</p>
<ul>
<li>name: 要创建的集合名称</li>
<li>options: 可选参数, 指定有关内存大小及索引的选项</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 创建goods集合</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> db.createCollection(<span class="string">&quot;goods&quot;</span>)</span></span><br><span class="line">&#123; &quot;ok&quot; : 1 &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>使用options</li>
</ul>
<p>创建固定集合  <code>mycol</code>，整个集合空间大小 6142800 KB, 文档最大个数为 10000 个。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> db.createCollection(<span class="string">&quot;mycol&quot;</span>, &#123; capped : <span class="literal">true</span>, autoIndexId : <span class="literal">true</span>, size :</span> </span><br><span class="line">   6142800, max : 10000 &#125; )</span><br><span class="line">&#123; &quot;ok&quot; : 1 &#125;</span><br><span class="line"><span class="meta">&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>在 MongoDB 中，你不需要创建集合。当你插入一些文档时，MongoDB 会自动创建集合。</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> db.mycol2.insert(&#123;<span class="string">&quot;name&quot;</span> : <span class="string">&quot;菜鸟教程&quot;</span>&#125;)</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> show collections</span></span><br><span class="line">mycol2</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<br>

<h4 id="删除集合"><a href="#删除集合" class="headerlink" title="删除集合"></a>删除集合</h4><figure class="highlight stata"><table><tr><td class="code"><pre><span class="line"><span class="keyword">db</span>.collection.<span class="keyword">drop</span>()</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 举例</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> show collections</span></span><br><span class="line">test</span><br><span class="line">user</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> db.test.drop()</span></span><br><span class="line">true</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> show collections</span></span><br><span class="line">user</span><br></pre></td></tr></table></figure>

<br>

<h2 id="文档操作"><a href="#文档操作" class="headerlink" title="文档操作"></a>文档操作</h2><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>文档的数据结构和 JSON 基本一样。</p>
<p>所有存储在集合中的数据都是 BSON 格式。</p>
<p>BSON 是一种类似 JSON 的二进制形式的存储格式，是 Binary JSON 的简称。</p>
<br>

<h4 id="插入文档"><a href="#插入文档" class="headerlink" title="插入文档"></a><strong>插入文档</strong></h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">insert：插入一个或多个</span><br><span class="line"></span><br><span class="line">插入一个</span><br><span class="line">db.user.insert(&#123;name:&quot;zhangsan&quot;,age:20&#125;)	</span><br><span class="line"></span><br><span class="line">插入多个（使用中括号[]）</span><br><span class="line">db.goods.insert([&#123;name:&quot;apple&quot;,price:5&#125;,&#123;name:&quot;computer&quot;,price:6999&#125;])</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">insertOne：插入一个</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> db.user.insertOne(&#123;name:<span class="string">&quot;zhangsan&quot;</span>,age:32&#125;)</span></span><br><span class="line">&#123;</span><br><span class="line">        &quot;acknowledged&quot; : true,</span><br><span class="line">        &quot;insertedId&quot; : ObjectId(&quot;6039dc6c9b01016868fc8027&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">insertMany：插入多个</span><br><span class="line"></span><br><span class="line">db.goods.insertMany([&#123;name:&quot;chair&quot;,price:49&#125;,&#123;name:&quot;computer&quot;,price:6999&#125;])</span><br></pre></td></tr></table></figure>

<ul>
<li>实例</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">db.col.insert(&#123;title: <span class="string">&#x27;MongoDB 教程&#x27;</span>,</span> </span><br><span class="line">    description: &#x27;MongoDB 是一个 Nosql 数据库&#x27;,</span><br><span class="line">    by: &#x27;菜鸟教程&#x27;,</span><br><span class="line">    url: &#x27;http://www.runoob.com&#x27;,</span><br><span class="line">    tags: [&#x27;mongodb&#x27;, &#x27;database&#x27;, &#x27;NoSQL&#x27;],</span><br><span class="line">    likes: 100</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<br>

<h4 id="更新文档"><a href="#更新文档" class="headerlink" title="更新文档"></a><strong>更新文档</strong></h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> update语句基本语法</span></span><br><span class="line">db.collection.update(</span><br><span class="line">   &lt;query&gt;,</span><br><span class="line">   &lt;update&gt;,</span><br><span class="line">   &#123;</span><br><span class="line">     upsert: &lt;boolean&gt;,</span><br><span class="line">     multi: &lt;boolean&gt;,</span><br><span class="line">     writeConcern: &lt;document&gt;</span><br><span class="line">   &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p><strong>参数说明：</strong></p>
<ul>
<li><strong>query</strong> : update的查询条件，类似sql update查询内where后面的。</li>
<li><strong>update</strong> : update的对象和一些更新的操作符（如$,$inc…）等，也可以理解为sql update查询内set后面的</li>
<li><strong>upsert</strong>  : 可选，这个参数的意思是，如果不存在update的记录，是否插入objNew,true为插入，默认是false，不插入。</li>
<li><strong>multi</strong>  : 可选，mongodb 默认是false,只更新找到的第一条记录，如果这个参数为true,就把按条件查出来多条记录全部更新。</li>
<li><strong>writeConcern</strong>  :可选，抛出异常的级别。</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 例如：（将标题为“MongoDB 教程”改为“MongoDB”）</span></span><br><span class="line">db.col.update(&#123;&#x27;title&#x27;:&#x27;MongoDB 教程&#x27;&#125;,&#123;$set:&#123;&#x27;title&#x27;:&#x27;MongoDB&#x27;&#125;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 以上语句只会修改第一条发现的文档，如果你要修改多条相同的文档，则需要设置 multi 参数为 <span class="literal">true</span></span></span><br><span class="line">db.col.update(&#123;&#x27;title&#x27;:&#x27;MongoDB 教程&#x27;&#125;,&#123;$set:&#123;&#x27;title&#x27;:&#x27;MongoDB&#x27;&#125;&#125;,&#123;multi:true&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li>综合实例</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 将goods集合中name为<span class="string">&quot;apple&quot;</span>的修改为<span class="string">&quot;food&quot;</span>（只修改第一条发现的文档）</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> db.goods.find()</span></span><br><span class="line">&#123; &quot;_id&quot; : ObjectId(&quot;5fcb0237be45c9df825a5558&quot;), &quot;name&quot; : &quot;apple&quot;, &quot;price&quot; : 5 &#125;</span><br><span class="line">&#123; &quot;_id&quot; : ObjectId(&quot;5fcb0317be45c9df825a5559&quot;), &quot;name&quot; : &quot;chair&quot;, &quot;price&quot; : 49 &#125;</span><br><span class="line">&#123; &quot;_id&quot; : ObjectId(&quot;5fcb0317be45c9df825a555a&quot;), &quot;name&quot; : &quot;computer&quot;, &quot;price&quot; : 6999 &#125;</span><br><span class="line">&#123; &quot;_id&quot; : ObjectId(&quot;5fcb0346be45c9df825a555b&quot;), &quot;name&quot; : &quot;apple&quot;, &quot;price&quot; : 5 &#125;</span><br><span class="line">&#123; &quot;_id&quot; : ObjectId(&quot;5fcb0346be45c9df825a555c&quot;), &quot;name&quot; : &quot;computer&quot;, &quot;price&quot; : 6999 &#125;</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> db.goods.update(&#123;name:<span class="string">&quot;apple&quot;</span>&#125;,&#123;<span class="variable">$set</span>:&#123;name:<span class="string">&quot;food&quot;</span>&#125;&#125;)</span></span><br><span class="line">WriteResult(&#123; &quot;nMatched&quot; : 1, &quot;nUpserted&quot; : 0, &quot;nModified&quot; : 1 &#125;)</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> db.goods.find()</span></span><br><span class="line">&#123; &quot;_id&quot; : ObjectId(&quot;5fcb0237be45c9df825a5558&quot;), &quot;name&quot; : &quot;food&quot;, &quot;price&quot; : 5 &#125;</span><br><span class="line">&#123; &quot;_id&quot; : ObjectId(&quot;5fcb0317be45c9df825a5559&quot;), &quot;name&quot; : &quot;chair&quot;, &quot;price&quot; : 49 &#125;</span><br><span class="line">&#123; &quot;_id&quot; : ObjectId(&quot;5fcb0317be45c9df825a555a&quot;), &quot;name&quot; : &quot;computer&quot;, &quot;price&quot; : 6999 &#125;</span><br><span class="line">&#123; &quot;_id&quot; : ObjectId(&quot;5fcb0346be45c9df825a555b&quot;), &quot;name&quot; : &quot;apple&quot;, &quot;price&quot; : 5 &#125;</span><br><span class="line">&#123; &quot;_id&quot; : ObjectId(&quot;5fcb0346be45c9df825a555c&quot;), &quot;name&quot; : &quot;computer&quot;, &quot;price&quot; : 6999 &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> db.goods.update(&#123;name:<span class="string">&quot;apple&quot;</span>&#125;,&#123;<span class="variable">$set</span>:&#123;name:<span class="string">&quot;food&quot;</span>&#125;&#125;)</span></span><br><span class="line">WriteResult(&#123; &quot;nMatched&quot; : 1, &quot;nUpserted&quot; : 0, &quot;nModified&quot; : 1 &#125;)</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> db.goods.find()</span></span><br><span class="line">&#123; &quot;_id&quot; : ObjectId(&quot;5fcb0237be45c9df825a5558&quot;), &quot;name&quot; : &quot;food&quot;, &quot;price&quot; : 5 &#125;</span><br><span class="line">&#123; &quot;_id&quot; : ObjectId(&quot;5fcb0317be45c9df825a5559&quot;), &quot;name&quot; : &quot;chair&quot;, &quot;price&quot; : 49 &#125;</span><br><span class="line">&#123; &quot;_id&quot; : ObjectId(&quot;5fcb0317be45c9df825a555a&quot;), &quot;name&quot; : &quot;computer&quot;, &quot;price&quot; : 6999 &#125;</span><br><span class="line">&#123; &quot;_id&quot; : ObjectId(&quot;5fcb0346be45c9df825a555b&quot;), &quot;name&quot; : &quot;food&quot;, &quot;price&quot; : 5 &#125;</span><br><span class="line">&#123; &quot;_id&quot; : ObjectId(&quot;5fcb0346be45c9df825a555c&quot;), &quot;name&quot; : &quot;computer&quot;, &quot;price&quot; : 6999 &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 将goods集合中所有name为<span class="string">&quot;food&quot;</span>的修改为<span class="string">&quot;apple&quot;</span>（修改多条相同的文档，则需要设置 multi 参数为 <span class="literal">true</span>）</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> db.goods.update(&#123;name:<span class="string">&quot;food&quot;</span>&#125;,&#123;<span class="variable">$set</span>:&#123;name:<span class="string">&quot;apple&quot;</span>&#125;&#125;,&#123;multi:<span class="literal">true</span>&#125;)</span></span><br><span class="line">WriteResult(&#123; &quot;nMatched&quot; : 2, &quot;nUpserted&quot; : 0, &quot;nModified&quot; : 2 &#125;)</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> db.goods.find()</span></span><br><span class="line">&#123; &quot;_id&quot; : ObjectId(&quot;5fcb0237be45c9df825a5558&quot;), &quot;name&quot; : &quot;apple&quot;, &quot;price&quot; : 5 &#125;</span><br><span class="line">&#123; &quot;_id&quot; : ObjectId(&quot;5fcb0317be45c9df825a5559&quot;), &quot;name&quot; : &quot;chair&quot;, &quot;price&quot; : 49 &#125;</span><br><span class="line">&#123; &quot;_id&quot; : ObjectId(&quot;5fcb0317be45c9df825a555a&quot;), &quot;name&quot; : &quot;computer&quot;, &quot;price&quot; : 6999 &#125;</span><br><span class="line">&#123; &quot;_id&quot; : ObjectId(&quot;5fcb0346be45c9df825a555b&quot;), &quot;name&quot; : &quot;apple&quot;, &quot;price&quot; : 5 &#125;</span><br><span class="line">&#123; &quot;_id&quot; : ObjectId(&quot;5fcb0346be45c9df825a555c&quot;), &quot;name&quot; : &quot;computer&quot;, &quot;price&quot; : 6999 &#125;</span><br></pre></td></tr></table></figure>

<br>

<h4 id="删除文档"><a href="#删除文档" class="headerlink" title="删除文档"></a><strong>删除文档</strong></h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> remove语句基本语法</span></span><br><span class="line">db.collection.remove(</span><br><span class="line">   &lt;query&gt;,</span><br><span class="line">   &#123;</span><br><span class="line">     justOne: &lt;boolean&gt;,</span><br><span class="line">     writeConcern: &lt;document&gt;</span><br><span class="line">   &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p><strong>参数说明：</strong></p>
<ul>
<li><strong>query</strong> :（可选）删除的文档的条件。</li>
<li><strong>justOne</strong> : （可选）如果设为 true 或 1，则只删除一个文档，如果不设置该参数，或使用默认值 false，则删除所有匹配条件的文档。</li>
<li><strong>writeConcern</strong>  :（可选）抛出异常的级别。</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 将所有name为“apple”的文档删除</span></span><br><span class="line">db.goods.remove(&#123;name:&quot;apple&quot;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果你只想删除第一条找到的记录可以设置 justOne 为 1</span></span><br><span class="line">db.goods.remove(&#123;name:&quot;apple&quot;&#125;,1)</span><br></pre></td></tr></table></figure>



<ul>
<li>现在官方推荐使用 deleteOne() 和 deleteMany() 方法</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 删除goods集合下所有文档</span></span><br><span class="line">db.goods.deleteMany(&#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除name等于apple的全部文档</span></span><br><span class="line">db.goods.deleteMany(&#123;name:&quot;apple&quot;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除name等于zhangsan的一个文档</span></span><br><span class="line">db.user.deleteOne(&#123;name:&quot;zhangsan&quot;&#125;)</span><br></pre></td></tr></table></figure>

<br>

<h1 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h1><h4 id="查询文档"><a href="#查询文档" class="headerlink" title="查询文档"></a><strong>查询文档</strong></h4><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">db.collection.<span class="builtin-name">find</span>(query, projection)</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>query</strong> ：可选，使用查询操作符指定查询条件</li>
<li><strong>projection</strong> ：可选，使用投影操作符指定返回的键。查询时返回文档中所有键值， 只需省略该参数即可（默认省略）</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查询user集合中的所有文档</span></span><br><span class="line">db.user.find()</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> pretty()方法以格式化的方式来显示所有文档</span></span><br><span class="line">db.col.find().pretty()</span><br></pre></td></tr></table></figure>



<ul>
<li>MongoDB 与 RDBMS Where 语句比较</li>
</ul>
<table>
<thead>
<tr>
<th>操作</th>
<th>格式</th>
<th>范例</th>
<th>RDBMS中的类似语句</th>
</tr>
</thead>
<tbody><tr>
<td>等于</td>
<td><code>&#123;&lt;key&gt;:&lt;value&gt;</code>}</td>
<td><code>db.col.find(&#123;&quot;by&quot;:&quot;菜鸟教程&quot;&#125;).pretty()</code></td>
<td><code>where by = &#39;菜鸟教程&#39;</code></td>
</tr>
<tr>
<td>小于</td>
<td><code>&#123;&lt;key&gt;:&#123;$lt:&lt;value&gt;&#125;&#125;</code></td>
<td><code>db.col.find(&#123;&quot;likes&quot;:&#123;$lt:50&#125;&#125;).pretty()</code></td>
<td><code>where likes &lt; 50</code></td>
</tr>
<tr>
<td>小于或等于</td>
<td><code>&#123;&lt;key&gt;:&#123;$lte:&lt;value&gt;&#125;&#125;</code></td>
<td><code>db.col.find(&#123;&quot;likes&quot;:&#123;$lte:50&#125;&#125;).pretty()</code></td>
<td><code>where likes &lt;= 50</code></td>
</tr>
<tr>
<td>大于</td>
<td><code>&#123;&lt;key&gt;:&#123;$gt:&lt;value&gt;&#125;&#125;</code></td>
<td><code>db.col.find(&#123;&quot;likes&quot;:&#123;$gt:50&#125;&#125;).pretty()</code></td>
<td><code>where likes &gt; 50</code></td>
</tr>
<tr>
<td>大于或等于</td>
<td><code>&#123;&lt;key&gt;:&#123;$gte:&lt;value&gt;&#125;&#125;</code></td>
<td><code>db.col.find(&#123;&quot;likes&quot;:&#123;$gte:50&#125;&#125;).pretty()</code></td>
<td><code>where likes &gt;= 50</code></td>
</tr>
<tr>
<td>不等于</td>
<td><code>&#123;&lt;key&gt;:&#123;$ne:&lt;value&gt;&#125;&#125;</code></td>
<td><code>db.col.find(&#123;&quot;likes&quot;:&#123;$ne:50&#125;&#125;).pretty()</code></td>
<td><code>where likes != 50</code></td>
</tr>
</tbody></table>
<ul>
<li>and条件</li>
</ul>
<p>MongoDB 的 find() 方法可以传入多个键(key)，每个键(key)以逗号隔开，即常规 SQL  的 AND 条件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">db.col.find(&#123;key1:value1, key2:value2&#125;).pretty()</span><br><span class="line"></span><br><span class="line">db.goods.find(&#123;name:&quot;computer&quot;,price:&#123;$gte:6000&#125;&#125;).pretty()</span><br></pre></td></tr></table></figure>

<ul>
<li>or条件</li>
</ul>
<p>MongoDB OR 条件语句使用了关键字 <strong>$or</strong></p>
<p>查询键 <strong>by</strong> 值为 菜鸟教程 或键 <strong>title</strong> 值为 <strong>MongoDB 教程</strong> 的文档</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">db.col.find(&#123;$or:[&#123;&quot;by&quot;:&quot;菜鸟教程&quot;&#125;,&#123;&quot;title&quot;: &quot;MongoDB 教程&quot;&#125;]&#125;).pretty()</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>AND 和 OR 联合使用</strong></li>
</ul>
<p>以下实例演示了 AND 和 OR 联合使用，类似常规 SQL 语句为： <strong>‘where likes&gt;50 AND (by = ‘菜鸟教程’ OR title = ‘MongoDB 教程’)’</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">db.col.find(&#123;&quot;likes&quot;: &#123;$gt:50&#125;, $or: [&#123;&quot;by&quot;: &quot;菜鸟教程&quot;&#125;,&#123;&quot;title&quot;: &quot;MongoDB 教程&quot;&#125;]&#125;).pretty()</span><br><span class="line"></span><br><span class="line">db.goods.find(&#123;name:&quot;computer&quot;,$or:[&#123;price:&#123;$gte:6000&#125;&#125;,&#123;price:4999&#125;]&#125;).pretty()</span><br><span class="line">&#123;</span><br><span class="line">        &quot;_id&quot; : ObjectId(&quot;6039dba49b01016868fc8026&quot;),</span><br><span class="line">        &quot;name&quot; : &quot;computer&quot;,</span><br><span class="line">        &quot;price&quot; : 6999</span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">        &quot;_id&quot; : ObjectId(&quot;603a00f19b01016868fc802b&quot;),</span><br><span class="line">        &quot;name&quot; : &quot;computer&quot;,</span><br><span class="line">        &quot;price&quot; : 4999</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<h4 id="模糊查询"><a href="#模糊查询" class="headerlink" title="模糊查询"></a><strong>模糊查询</strong></h4><p>查询 title 包含”教”字的文档：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">db.col.find(&#123;title:/教/&#125;)</span><br></pre></td></tr></table></figure>

<p>查询 title 字段以”教”字开头的文档：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">db.col.find(&#123;title:/^教/&#125;)</span><br></pre></td></tr></table></figure>

<p>查询 titl e字段以”教”字结尾的文档：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">db.col.find(&#123;title:/教$/&#125;)</span><br></pre></td></tr></table></figure>

<br>

<h4 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a><strong>分页查询</strong></h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 返回指定NUMBER数量的数据记录</span></span><br><span class="line">db.COLLECTION_NAME.find().limit(NUMBER)</span><br></pre></td></tr></table></figure>

<br>

<h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><ul>
<li>在 MongoDB 中使用 sort() 方法对数据进行排序，sort() 方法可以通过参数指定排序的字段，并使用 1 和 -1 来指定排序的方式，其中 1 为升序排列，而 -1 是用于降序排列</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">db.COLLECTION_NAME.find().sort(&#123;KEY:1&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 按价格 升序 排序</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> db.goods.find().sort(&#123;price:1&#125;)</span></span><br><span class="line">&#123; &quot;_id&quot; : ObjectId(&quot;6039e2589b01016868fc8029&quot;), &quot;name&quot; : &quot;box&quot; &#125;</span><br><span class="line">&#123; &quot;_id&quot; : ObjectId(&quot;603a00f19b01016868fc802a&quot;), &quot;name&quot; : &quot;chair&quot;, &quot;price&quot; : 90 &#125;</span><br><span class="line">&#123; &quot;_id&quot; : ObjectId(&quot;603a00f19b01016868fc802b&quot;), &quot;name&quot; : &quot;computer&quot;, &quot;price&quot; : 4999 &#125;</span><br><span class="line">&#123; &quot;_id&quot; : ObjectId(&quot;6039dba49b01016868fc8026&quot;), &quot;name&quot; : &quot;computer&quot;, &quot;price&quot; : 6999 &#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>skip()，limilt()，sort()三个放在一起执行的时候，执行的顺序是先 sort()，然后是 skip()，最后是显示的 limit()</li>
</ul>
<br>

<h1 id="聚合"><a href="#聚合" class="headerlink" title="聚合"></a>聚合</h1><p>MongoDB 中聚合(aggregate)主要用于处理数据(诸如统计平均值，求和等)，并返回计算后的数据结果。</p>
<p>有点类似 SQL 语句中的 count(*)</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">db.<span class="module-access"><span class="module"><span class="identifier">COLLECTION_NAME</span>.</span></span>aggregate(AGGREGATE_OPERATION)</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> db.mycol.aggregate([&#123;<span class="variable">$group</span> : &#123;_id : <span class="string">&quot;<span class="variable">$by_user</span>&quot;</span>, num_tutorial : &#123;<span class="variable">$sum</span> : 1&#125;&#125;&#125;])</span></span><br><span class="line">&#123;</span><br><span class="line">   &quot;result&quot; : [</span><br><span class="line">      &#123;</span><br><span class="line">         &quot;_id&quot; : &quot;runoob.com&quot;,</span><br><span class="line">         &quot;num_tutorial&quot; : 2</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">         &quot;_id&quot; : &quot;Neo4j&quot;,</span><br><span class="line">         &quot;num_tutorial&quot; : 1</span><br><span class="line">      &#125;</span><br><span class="line">   ],</span><br><span class="line">   &quot;ok&quot; : 1</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">&gt;</span></span><br></pre></td></tr></table></figure>

<p>以上实例类似sql语句：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">select by_user, count(*) from mycol group by by_user</span><br></pre></td></tr></table></figure>

<p>在上面的例子中，我们通过字段 by_user 字段对数据进行分组，并计算 by_user 字段相同值的总和。</p>
<table>
<thead>
<tr>
<th>表达式</th>
<th>描述</th>
<th>实例</th>
</tr>
</thead>
<tbody><tr>
<td>$sum</td>
<td>计算总和。</td>
<td>db.mycol.aggregate([{$group : {_id : “$by_user”, num_tutorial : {$sum : “$likes”}}}])</td>
</tr>
<tr>
<td>$avg</td>
<td>计算平均值</td>
<td>db.mycol.aggregate([{$group : {_id : “$by_user”, num_tutorial : {$avg : “$likes”}}}])</td>
</tr>
<tr>
<td>$min</td>
<td>获取集合中所有文档对应值得最小值。</td>
<td>db.mycol.aggregate([{$group : {_id : “$by_user”, num_tutorial : {$min : “$likes”}}}])</td>
</tr>
<tr>
<td>$max</td>
<td>获取集合中所有文档对应值得最大值。</td>
<td>db.mycol.aggregate([{$group : {_id : “$by_user”, num_tutorial : {$max : “$likes”}}}])</td>
</tr>
<tr>
<td>$push</td>
<td>在结果文档中插入值到一个数组中。</td>
<td>db.mycol.aggregate([{$group : {_id : “$by_user”, url : {$push: “$url”}}}])</td>
</tr>
<tr>
<td>$addToSet</td>
<td>在结果文档中插入值到一个数组中，但不创建副本。</td>
<td>db.mycol.aggregate([{$group : {_id : “$by_user”, url : {$addToSet : “$url”}}}])</td>
</tr>
<tr>
<td>$first</td>
<td>根据资源文档的排序获取第一个文档数据。</td>
<td>db.mycol.aggregate([{$group : {_id : “$by_user”, first_url : {$first : “$url”}}}])</td>
</tr>
<tr>
<td>$last</td>
<td>根据资源文档的排序获取最后一个文档数据</td>
<td>db.mycol.aggregate([{$group : {_id : “$by_user”, last_url : {$last : “$url”}}}])</td>
</tr>
</tbody></table>
<hr>
<br>

<h1 id="SpringBoot集成"><a href="#SpringBoot集成" class="headerlink" title="SpringBoot集成"></a>SpringBoot集成</h1><h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--引入mongodb--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-mongodb<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 配置mongodb</span></span><br><span class="line"><span class="meta">spring.data.mongodb.uri</span>=<span class="string">mongodb://localhost:27017/recruit</span></span><br></pre></td></tr></table></figure>

<h2 id="实战应用"><a href="#实战应用" class="headerlink" title="实战应用"></a>实战应用</h2><h4 id="文章模块"><a href="#文章模块" class="headerlink" title="文章模块"></a>文章模块</h4><ul>
<li><strong>dao层</strong></li>
</ul>
<p>普通的增删改查方法可以直接调用mongoTemplate的默认方法，自定义方法则需在接口主动声明。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ArticleRepository</span> <span class="keyword">extends</span> <span class="title">MongoRepository</span>&lt;<span class="title">Article</span>, <span class="title">String</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据模块名查找文章</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> moduleName</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">List&lt;Article&gt; <span class="title">findByModuleName</span><span class="params">(String moduleName)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>service层</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArticleServiceImpl</span> <span class="keyword">implements</span> <span class="title">ArticleService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ArticleRepository articleRepository;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MongoTemplate mongoTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取默认文章（4个）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ResultInfo&lt;List&lt;Article&gt;&gt; findDefaultArticle() &#123;</span><br><span class="line">        Query query = <span class="keyword">new</span> Query();</span><br><span class="line">        Sort sort = Sort.by(<span class="string">&quot;gmtCreate&quot;</span>).descending();</span><br><span class="line">        PageRequest pageRequest = PageRequest.of(<span class="number">0</span>, <span class="number">4</span>);</span><br><span class="line">        query.with(sort);</span><br><span class="line">        query.with(pageRequest);</span><br><span class="line">        List&lt;Article&gt; articleList = mongoTemplate.find(query, Article.class);</span><br><span class="line">        <span class="keyword">return</span> ResultInfo.success(CodeEnum.SUCCESS, articleList);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据模块名查找文章</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> moduleName</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ResultInfo&lt;List&lt;Article&gt;&gt; findByModuleName(String moduleName) &#123;</span><br><span class="line">        List&lt;Article&gt; articles = articleRepository.findByModuleName(moduleName);</span><br><span class="line">        <span class="keyword">return</span> ResultInfo.success(CodeEnum.SUCCESS, articles);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据文章标题模糊查询</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> articleTitle</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ResultInfo&lt;List&lt;Article&gt;&gt; findByArticleTitle(String articleTitle) &#123;</span><br><span class="line">        Pattern pattern = </span><br><span class="line">            Pattern.compile(<span class="string">&quot;^.*&quot;</span> + articleTitle + <span class="string">&quot;.*$&quot;</span>, Pattern.CASE_INSENSITIVE);</span><br><span class="line">        Query query = <span class="keyword">new</span> Query();</span><br><span class="line">        query.addCriteria(Criteria.where(<span class="string">&quot;articleTitle&quot;</span>).regex(pattern));</span><br><span class="line">        Sort sort = Sort.by(<span class="string">&quot;gmtCreate&quot;</span>).descending();</span><br><span class="line">        query.with(sort);</span><br><span class="line">        List&lt;Article&gt; articles = mongoTemplate.find(query, Article.class);</span><br><span class="line">        <span class="keyword">return</span> ResultInfo.success(CodeEnum.SUCCESS, articles);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="题目模块"><a href="#题目模块" class="headerlink" title="题目模块"></a>题目模块</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Validated</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuestionServiceImpl</span> <span class="keyword">implements</span> <span class="title">QuestionService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> QuestionRepository questionRepository;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MongoTemplate mongoTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 新增一道题目</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> question</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveOne</span><span class="params">(Question question)</span> </span>&#123;</span><br><span class="line">        questionRepository.save(question);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自由模式随机查找一道题</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ResultInfo&lt;Question&gt; <span class="title">getOneQuestion</span><span class="params">()</span></span>&#123;</span><br><span class="line">        List&lt;Question&gt; questions = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="comment">// Aggregation.sample()可随机抽选指定数量的数据</span></span><br><span class="line">        TypedAggregation&lt;Question&gt; aggregation = </span><br><span class="line">            Aggregation.newAggregation(Question.class, Aggregation.sample(<span class="number">1</span>));</span><br><span class="line">        AggregationResults&lt;Question&gt; results = </span><br><span class="line">            mongoTemplate.aggregate(aggregation, Question.class);</span><br><span class="line">        results.forEach(result-&gt;&#123;</span><br><span class="line">            questions.add(result);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">if</span>(questions.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">return</span> ResultInfo.error(CodeEnum.PARAM_NOT_IDEAL, <span class="keyword">null</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> ResultInfo.success(CodeEnum.SUCCESS, questions.get(<span class="number">0</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自由模式根据模块名随机查找一道题</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> moduleName</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ResultInfo&lt;Question&gt; <span class="title">getOneQuestionByName</span><span class="params">(<span class="meta">@NotBlank</span> String moduleName)</span></span>&#123;</span><br><span class="line">        List&lt;Question&gt; questions = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        MatchOperation match = </span><br><span class="line">            Aggregation.match(Criteria.where(<span class="string">&quot;moduleName&quot;</span>).is(moduleName));</span><br><span class="line">        TypedAggregation&lt;Question&gt; aggregation = </span><br><span class="line">            Aggregation.newAggregation(Question.class, match, Aggregation.sample(<span class="number">1</span>));</span><br><span class="line">        AggregationResults&lt;Question&gt; results = </span><br><span class="line">            mongoTemplate.aggregate(aggregation, Question.class);</span><br><span class="line">        results.forEach(result-&gt;&#123;</span><br><span class="line">            questions.add(result);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">if</span>(questions.size() == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> ResultInfo.error(CodeEnum.PARAM_NOT_IDEAL, <span class="keyword">null</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> ResultInfo.success(CodeEnum.SUCCESS, questions.get(<span class="number">0</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 闯关模式根据模块名随机查找10道题</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> moduleName</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ResultInfo&lt;List&lt;Question&gt;&gt; getQuestionsByName(<span class="meta">@NotBlank</span> String moduleName)&#123;</span><br><span class="line">        List&lt;Question&gt; questions = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        MatchOperation match = </span><br><span class="line">            Aggregation.match(Criteria.where(<span class="string">&quot;moduleName&quot;</span>).is(moduleName));</span><br><span class="line">        TypedAggregation&lt;Question&gt; aggregation = </span><br><span class="line">            Aggregation.newAggregation(Question.class, match, Aggregation.sample(<span class="number">10</span>));</span><br><span class="line">        AggregationResults&lt;Question&gt; results = </span><br><span class="line">            mongoTemplate.aggregate(aggregation, Question.class);</span><br><span class="line">        results.forEach(result-&gt;&#123;</span><br><span class="line">            questions.add(result);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> ResultInfo.success(CodeEnum.SUCCESS, questions);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<h1 id="docker安装"><a href="#docker安装" class="headerlink" title="docker安装"></a>docker安装</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker pull mongo:4.4.1</span><br><span class="line">docker run -p 27017:27017 --name mongo -v /home/mongo/db:/data/db -d mongo:4.4.1 --auth</span><br><span class="line">docker exec -it mongo mongo		#进入容器</span><br><span class="line">use admin</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> db.createUser(&#123;</span></span><br><span class="line">... user: &quot;KimTou&quot;,</span><br><span class="line">... pwd: &quot;123456&quot;,</span><br><span class="line">... roles: [&#123; role:&quot;root&quot;,db:&quot;admin&quot; &#125;] &#125;);</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> db.auth(<span class="string">&quot;KimTou&quot;</span>,<span class="string">&quot;123456&quot;</span>)	<span class="comment"># 测试</span></span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>MongoDB</category>
      </categories>
      <tags>
        <tag>MongoDB</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解Java虚拟机——HotSpot虚拟机对象探秘</title>
    <url>/2021/10/23/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E2%80%94%E2%80%94HotSpot%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AF%B9%E8%B1%A1%E6%8E%A2%E7%A7%98/</url>
    <content><![CDATA[<h3 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h3><p><img src="https://gitee.com/KIMTOU/img/raw/master/20211023095702.png"></p>
<h5 id="1、类加载检查"><a href="#1、类加载检查" class="headerlink" title="1、类加载检查"></a>1、类加载检查</h5><p>当虚拟机遇到一条 new 指令时，首先将去检查这个指令的参数是否能在Metaspace的常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载过、解析和初始化过。如果没有，那必须先执行相应的类加载过程。（通过双亲委派模式，将类加载进内存）</p>
<h5 id="2、分配内存"><a href="#2、分配内存" class="headerlink" title="2、分配内存"></a>2、分配内存</h5><p>在类加载检查通过后，接下来虚拟机将为新生对象分配内存。<strong>对象所需的内存大小在类加载完成后便可确定，为对象分配空间的任务等同于把一块确定大小的内存块从 Java 堆中划分出来</strong>。分配方式有 “指针碰撞” 和 “空闲列表” 两种，选择哪种分配方式由 Java 堆是否规整决定，而 Java 堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。</p>
<p><strong>内存分配的两种方式：</strong></p>
<p>选择以上两种方式中的哪一种，取决于 Java 堆内存是否规整。而 Java 堆内存是否规整，取决于 GC 收集器的算法是”标记-清除”，还是”标记-整理”（也称作”标记-压缩”），复制算法内存也是规整的。</p>
<p><img src="https://gitee.com/KIMTOU/img/raw/master/20211023095705.png"></p>
<p><strong>内存分配并发问题：</strong></p>
<p>在创建对象的时候有一个很重要的问题，就是线程安全，因为在实际开发过程中，对象创建在虚拟机中是非常频繁的行为，即使仅仅修改一个指针所指向的位置，在并发情况下也并不是线程安全的，可能出现正在给对象A分配内存，指针还没来得及修改，对象B又同时使用了原来的指针来分配内存的情况。</p>
<p>保证内存分配线程安全有两种可选方案：</p>
<ul>
<li><strong>CAS+失败重试：</strong> CAS 是乐观锁的一种实现方式。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。<strong>虚拟机采用 CAS 配上失败重试的方式保证更新操作的原子性。</strong></li>
<li><strong>TLAB：</strong> 为每一个线程预先在 Java 堆中的 Eden 区分配一小块内存，称为本地线程分配缓冲。JVM 在给线程中的对象分配内存时，首先在 TLAB 分配，当对象大于 TLAB 中的剩余内存或 TLAB 的内存已用尽时，再采用上述的 CAS 进行内存分配。</li>
</ul>
<h5 id="3、初始化零值"><a href="#3、初始化零值" class="headerlink" title="3、初始化零值"></a>3、初始化零值</h5><p>内存分配完成后，虚拟机必须将分配到的内存空间（不包括对象头）都初始化为零值。这步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用，使程序能访问到这些字段的数据类型所对应的零值。</p>
<h5 id="4、设置对象头"><a href="#4、设置对象头" class="headerlink" title="4、设置对象头"></a>4、设置对象头</h5><p>初始化零值完成之后，<strong>虚拟机要对对象进行必要的设置</strong>，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息。 <strong>这些信息存放在对象的对象头（Object Header）之中。</strong>根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。</p>
<h5 id="5、执行-init-方法"><a href="#5、执行-init-方法" class="headerlink" title="5、执行 init 方法"></a>5、执行 init 方法</h5><p>在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了。但从 Java 程序的视角来看，对象创建才刚开始——构造函数，即Class文件中的 <code>&lt;init&gt;()</code> 方法还没有执行，所有的字段都为默认的零值。所以一般来说，执行 new 指令之后会接着执行 <code>&lt;init&gt;()</code> 方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全被构造出来。</p>
<blockquote>
<p>给对象的属性赋值的操作有：</p>
<p>（1）属性的默认初始化（对应步骤三 初始化零值）</p>
<p>（2）显示初始化 / （3）代码块初始化   （相同等级，执行与代码顺序有关）</p>
<p>（4）构造器初始化</p>
<p><strong>执行 init 方法</strong>这步包含了（2）（3）（4）</p>
</blockquote>
<br>

<h3 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h3><p>在 Hotspot 虚拟机中，对象在堆内存中的存储布局可以划分为三个部分：<strong>对象头</strong>、<strong>实例数据</strong>和<strong>对齐填充</strong>。</p>
<p><strong>Hotspot 虚拟机的对象头包括两部分信息</strong>，<strong>第一部分用于存储对象自身的运行时数据</strong>（哈希码、GC 分代年龄、锁状态标志等等），称为 <code>Mark Word</code> ，<strong>另一部分是类型指针</strong>，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定该对象是哪个类的实例。</p>
<p><strong>实例数据部分是对象真正存储的有效信息</strong>，即在程序代码中所定义的各种类型的字段内容。</p>
<p><strong>对齐填充部分不是必然存在的，也没有什么特别的含义，仅仅起着占位符的作用。</strong> 因为 Hotspot 虚拟机的自动内存管理系统要求对象起始地址必须是 8 字节的整数倍，换句话说就是对象的大小必须是 8 字节的整数倍。对象头部分已经被精心设计成正好是 8 字节的倍数（1 倍或 2 倍），因此，若对象实例数据部分没有对齐的话，就需要通过对齐填充来补全。</p>
<br>

<h3 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h3><p>创建对象就是为了后续使用该对象，我们的 Java 程序通过栈上的 reference 数据来操作堆上的具体对象。对象的访问方式由虚拟机实现而定，目前主流的访问方式有<strong>① 使用句柄</strong>和<strong>② 直接指针</strong>两种：</p>
<ol>
<li><strong>句柄：</strong> 如果使用句柄的话，那么 <strong>Java 堆中将会划分出一块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息</strong>。</li>
</ol>
<p><img src="https://gitee.com/KIMTOU/img/raw/master/20211023095709.png"></p>
<ol start="2">
<li><strong>直接指针（HotSpot使用）：</strong> 如果使用直接指针访问的话， Java 堆中对象的内存布局就必须考虑如何放置访问类型数据的相关信息，<strong>reference 中存储的直接就是对象地址</strong>，如果只是访问对象本身的话，就不需要多一次间接访问的开销。缺点是就是一旦对象位置改变（标记-复制算法），reference引用地址也要改变。</li>
</ol>
<p><img src="https://gitee.com/KIMTOU/img/raw/master/20211023095711.png"></p>
<p><strong>这两种对象访问方式各有优势。使用句柄来访问的最大好处是 reference 中存储的是稳定的句柄地址，在对象被移动时（垃圾收集）只会改变句柄中的实例数据指针，而 reference 本身不需要修改。使用直接指针访问方式最大的好处就是速度快，它节省了一次指针定位的时间开销</strong>。</p>
<br>

<blockquote>
<p>参考资料</p>
</blockquote>
<p><strong>《深入理解Java虚拟机  第3版》——周志明</strong></p>
<p><a href="https://github.com/Snailclimb/JavaGuide/tree/master/docs/java/jvm">https://github.com/Snailclimb/JavaGuide</a></p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解Java虚拟机——Java内存区域</title>
    <url>/2021/10/23/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E2%80%94%E2%80%94Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/</url>
    <content><![CDATA[<h2 id="运行时数据区"><a href="#运行时数据区" class="headerlink" title="运行时数据区"></a>运行时数据区</h2><ul>
<li>程序计数器（线程私有）</li>
<li>虚拟机栈（线程私有）</li>
<li>本地方法栈（线程私有）</li>
<li>堆（线程共享）</li>
<li>方法区（线程共享）</li>
</ul>
<p><img src="https://gitee.com/KIMTOU/img/raw/master/20211023094444.png" alt="JVM体系"></p>
<p><strong>Java 虚拟机在执行 Java 程序的过程中会把它管理的内存划分成若干个不同的数据区域</strong>。JDK 1.8 和之前的版本略有不同：</p>
<p><img src="https://gitee.com/KIMTOU/img/raw/master/20211023094450.png"></p>
<p><img src="https://gitee.com/KIMTOU/img/raw/master/20211023094452.png"></p>
<br>

<h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h3><p>程序计数器是一块较小的内存空间，可以看作是当前线程所执行的字节码的行号指示器。<strong>字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。</strong></p>
<p>Java虚拟机的多线程通过CPU不停切换各个线程，<strong>为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。</strong></p>
<br>

<h3 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h3><p>与程序计数器一样， Java 虚拟机栈也是线程私有的，它的生命周期与线程相同。</p>
<p><strong>虚拟机栈描述的是 Java 方法执行的线程内存模型：每个方法被执行的时候， Java 虚拟机都会同步创建一个栈帧用于存储局部变量表、操作数栈、动态连接、方法出口等信息。每一个方法被调用直至执行完毕的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。</strong>（Java 虚拟机栈是由一个个栈帧组成）</p>
<p>内存区域划分中的“栈”通常指的是虚拟机栈，或者更多情况下是指虚拟机栈中的局部变量表部分。</p>
<p><strong>局部变量表存放了编译期可知的各种基本数据类型</strong>（boolean、byte、char、short、int、float、long、double）、<strong>对象引用</strong>（reference类型，它不等同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）<strong>和returnAddress类型</strong>（指向了一条字节码指令的地址）。</p>
<p><strong>Java 虚拟机栈会出现两种异常：<code>StackOverflowError</code> 和 <code>OutOfMemoryError</code>。</strong></p>
<ul>
<li><strong><code>StackOverflowError</code>：</strong> 若 Java 虚拟机栈的内存大小不允许动态扩展，那么当线程请求栈的深度大于当前 虚拟机所允许的深度的时候，将抛出 StackOverflowError 异常。</li>
<li><strong><code>OutOfMemoryError</code>：</strong> Java 虚拟机栈的内存大小可以动态扩展， 如果虚拟机在动态扩展栈时无法申请到足够的内存空间，则抛出<code>OutOfMemoryError</code>异常。</li>
</ul>
<br>

<h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><p>与虚拟机栈所发挥的作用非常相似，其区别是： <strong>虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则是为虚拟机使用到的本地（Native）方法服务。</strong> 在 HotSpot 虚拟机中直接把本地方法栈和虚拟机栈合二为一。</p>
<p>本地方法被执行的时候，在本地方法栈也会创建一个栈帧，用于存放该本地方法的局部变量表、操作数栈、动态链接、出口信息。</p>
<p>方法执行完毕后相应的栈帧也会出栈并释放内存空间，也会出现 <code>StackOverFlowError</code> 和 <code>OutOfMemoryError</code> 两种错误。</p>
<br>

<h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><p>Java 虚拟机所管理的内存中最大的一块，Java 堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。<strong>此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存。</strong></p>
<p>堆可以处于物理上不连续的内存空间中（物理内存），但在逻辑上它应该被视为连续的（虚拟内存）。</p>
<blockquote>
<p>Java 世界中“几乎”所有的对象都在堆中分配，但是，随着 JIT 编译器的发展与逃逸分析技术逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化，所有的对象都分配到堆上也渐渐变得不那么“绝对”了。从 JDK 1.7 开始已经默认开启逃逸分析，<strong>如果某些方法中的对象引用没有被返回或者未被外面使用（也就是未逃逸出去），那么对象可以直接在栈上分配内存。</strong></p>
</blockquote>
<p>Java 堆是垃圾收集器管理的内存区域，因此也被称作<strong>GC 堆（Garbage Collected Heap）</strong>。从回收内存的角度看，由于现代垃圾收集器大部分都是基于分代收集理论设计，所以 Java 堆还可以细分为：新生代和老年代；再细致一点有：Eden 空间、From Survivor、To Survivor 空间等。当然，这些区域划分仅仅是一部分垃圾收集器的共同特性或者说设计风格而已，而非某个Java虚拟机具体实现的固有内存布局更不是对Java堆的进一步细致划分（近年来也出现了不采用“经典分代”设计的新垃圾收集器，将Java堆内存分为新生代、老年代、永久代等未必适合）。<strong>将Java堆细分的目的只是为了更好地回收内存，或者更快地分配内存。</strong></p>
<h4 id="JDK-7-与-8-的区别"><a href="#JDK-7-与-8-的区别" class="headerlink" title="JDK 7 与 8 的区别"></a>JDK 7 与 8 的区别</h4><p>在 JDK 7 版本及 JDK 7 版本之前，堆内存被通常分为下面三部分：</p>
<ol>
<li>新生代(Young Generation)</li>
<li>老生代(Old Generation)</li>
<li>永生代(Permanent Generation)</li>
</ol>
<p>JDK 8 版本之后方法区（HotSpot 的永久代）被彻底移除了（JDK1.7 就已经开始了），取而代之是元空间，元空间使用的是本地内存。</p>
<p><img src="https://gitee.com/KIMTOU/img/raw/master/20211023094712.png"></p>
<p><strong>上图所示的 Eden 区、两个 Survivor 区都属于新生代（为了区分，这两个 Survivor 区域按照顺序被命名为 from 和 to），中间一层属于老年代。</strong></p>
<ul>
<li>堆这里最容易出现的就是 OutOfMemoryError 错误，并且出现这种错误之后的表现形式还会有几种，比如：</li>
</ul>
<ol>
<li><strong><code>java.lang.OutOfMemoryError: GC Overhead Limit Exceeded</code></strong> ：当 JVM 花太多时间执行垃圾回收并且只能回收很少的堆空间时，就会发生此错误。</li>
<li><strong><code>java.lang.OutOfMemoryError: Java heap space</code></strong> ：假如在创建新的对象时, 堆内存中的空间不足以存放新创建的对象，且堆也无法再扩展时，就会引发此错误。（和配置的最大堆内存有关，且受制于物理内存大小。最大堆内存可通过<code>-Xmx</code>参数配置，若没有特别配置，将会使用默认值）</li>
</ol>
<br>

<h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><p><strong>方法区与 Java 堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码缓存等数据</strong>。虽然 Java 虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做 Non-Heap（非堆），目的是与 Java 堆区分开来。</p>
<p>方法区也被称为永久代。以下是方法区和永久代的关系：</p>
<blockquote>
<p>《Java 虚拟机规范》只是规定了有方法区这么个概念和它的作用，并没有规定如何去实现它。那么，在不同的 JVM 上方法区的实现肯定是不同的了。 <strong>方法区和永久代的关系很像 Java 中接口和类的关系，类实现了接口，而永久代就是 HotSpot 虚拟机对虚拟机规范中方法区的一种实现方式。</strong> 也就是说，永久代是 HotSpot 的概念，方法区是 Java 虚拟机规范中的定义，是一种规范，而永久代是一种实现，一个是标准一个是实现，其他的虚拟机实现并没有永久代这一说法。</p>
</blockquote>
<p>相对而言，垃圾收集行为在这个区域是比较少出现的，但并非数据进入方法区后就“永久存在”了。</p>
<p><strong>JDK 8 的时候，方法区（HotSpot 的永久代）被彻底移除了（JDK 7 就已经开始了），使用在本地内存中实现的元空间来代替</strong>。</p>
<p><strong>JDK 7 时，将原本放在永久代的字符串常量池、静态变量等移至 Java 堆中；到了 JDK 8 时，将 JDK 7 中永久代剩余的内容（类型信息）全部移到元空间。</strong></p>
<p>方法区和堆一样不需要连续的内存，并且可以动态扩展，动态扩展失败一样会抛出 OutOfMemoryError 异常。</p>
<h4 id="为什么要将永久代替换为元空间呢"><a href="#为什么要将永久代替换为元空间呢" class="headerlink" title="为什么要将永久代替换为元空间呢?"></a>为什么要将永久代替换为元空间呢?</h4><ol>
<li><p>整个永久代有一个 JVM 本身设置的固定大小上限，无法进行调整，而元空间使用的是本地内存，受本机可用内存的限制，虽然元空间仍旧可能溢出，但是比原来出现的几率会更小。</p>
<blockquote>
<p>当元空间溢出时会得到如下错误： <code>java.lang.OutOfMemoryError: MetaSpace</code></p>
</blockquote>
<p>你可以使用 <code>-XX：MaxMetaspaceSize</code> 标志设置最大元空间大小，默认值为 unlimited，这意味着它只受系统内存的限制。<code>-XX：MetaspaceSize</code> 调整标志定义元空间的初始大小，如果未指定此标志，则 Metaspace 将根据运行时的应用程序需求动态地重新调整大小。</p>
</li>
<li><p>元空间里面存放的是类的元数据，这样加载多少类的元数据就不由 <code>MaxPermSize</code> 控制了, 而由系统的实际可用空间来控制，这样能加载的类就更多了。</p>
</li>
<li><p>在 JDK8，合并 HotSpot 和 JRockit 的代码时, JRockit 从来没有一个叫永久代的东西, 合并之后就没有必要额外的设置这么一个永久代的地方了。</p>
</li>
</ol>
<hr>
<br>

<h3 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h3><p><strong>运行时常量池是方法区的一部分</strong>。Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有<strong>常量池表，用于存放编译期生成的各种字面量和符号引用</strong>，这部分内容将在类加载后存放到方法区的运行时常量池中。</p>
<p>既然运行时常量池是方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存时会抛出 OutOfMemoryError 错误。</p>
<ol>
<li><strong>JDK1.7 之前运行时常量池逻辑包含字符串常量池存放在方法区, 此时 hotspot 虚拟机对方法区的实现为永久代</strong></li>
<li><strong>JDK1.7 字符串常量池被从方法区拿到了堆中，这里没有提到运行时常量池，也就是说字符串常量池被单独拿到堆，运行时常量池剩下的东西还在方法区，也就是 hotspot 中的永久代</strong> 。</li>
<li><strong>JDK1.8 hotspot 移除了永久代用元空间(Metaspace)取而代之，这时候字符串常量池还在堆，运行时常量池还在方法区，只不过方法区的实现从永久代变成了元空间(Metaspace)</strong></li>
</ol>
<br>

<h3 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h3><p><strong>直接内存并不是虚拟机运行时数据区的一部分，也不是虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用。而且也可能导致 OutOfMemoryError 错误出现。</strong></p>
<p>JDK1.4 中新加入的 NIO(New Input/Output) 类，引入了一种基于通道（Channel）与缓存区（Buffer）的 I/O 方式，它可以直接使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆中的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样就能在一些场景中显著提高性能，因为避免了在 Java 堆和 Native 堆之间来回复制数据。</p>
<p>本机直接内存的分配不会受到 Java 堆的限制，但是，既然是内存就会受到本机总内存大小以及处理器寻址空间的限制。</p>
<br>

<h3 id="内存存储总结"><a href="#内存存储总结" class="headerlink" title="内存存储总结"></a>内存存储总结</h3><ul>
<li><strong>栈：</strong><ul>
<li>栈包含虚拟机栈、本地方法栈，<strong>线程私有</strong>，且内存连续</li>
<li><strong>每个方法被调用都会创建一个栈帧，用于存储局部变量表、操作数栈、方法出口等，其中局部变量表用于存放方法参数和方法内部定义的局部变量（基本数据类型、对象引用）。</strong></li>
<li>方法里再调用一个方法，则再开辟一个栈帧。先进后出，方法由里向外执行完关闭</li>
<li>分配内存大小和生命周期是可以确定的，当没有引用指向数据时，即方法结束或线程结束，内存就跟着回收了（注意：栈没有GC，而是因为出栈）</li>
</ul>
</li>
<li><strong>堆：</strong><ul>
<li>JVM只有一个堆区(heap)被所有<strong>线程共享</strong>，不连续的内存空间</li>
<li>堆中不存放基本类型和对象引用，只存放对象本身（数组也是对象）</li>
</ul>
</li>
<li><strong>方法区：</strong><ul>
<li> JVM只有一个方法区，<strong>线程共享</strong></li>
<li> 用来存放程序中永远不变或唯一的内容：class类信息、静态变量、常量等</li>
</ul>
</li>
</ul>
<br>

<blockquote>
<p>参考资料</p>
</blockquote>
<p><strong>《深入理解Java虚拟机  第3版》——周志明</strong></p>
<p><a href="https://github.com/Snailclimb/JavaGuide/tree/master/docs/java/jvm">https://github.com/Snailclimb/JavaGuide</a></p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>字符串常量池与包装类详解</title>
    <url>/2021/10/23/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E6%B1%A0%E4%B8%8E%E5%8C%85%E8%A3%85%E7%B1%BB%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h1 id="字符串常量池"><a href="#字符串常量池" class="headerlink" title="字符串常量池"></a>字符串常量池</h1><h3 id="设计思想"><a href="#设计思想" class="headerlink" title="设计思想"></a>设计思想</h3><p><strong>JVM为了提升性能和减少内存开销，避免重复创建字符串，其维护了一块特殊的内存空间，即字符串常量池</strong>。当需要使用字符串时，先去检查字符串常量池是否存在该字符串，若存在，则直接返回该字符串的引用地址；若不存在，则在字符串常量池中创建字符串对象，并返回对象的引用地址。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String a = <span class="string">&quot;abc&quot;</span>;	<span class="comment">// 放至常量池</span></span><br><span class="line">String b = <span class="string">&quot;abc&quot;</span>;	<span class="comment">// 从常量池中取出</span></span><br><span class="line">System.out.println(a == b);	<span class="comment">// trzue</span></span><br></pre></td></tr></table></figure>

<p><strong>注意：在 JDK7 之前，字符串常量池位置在永久代（方法区）中，此时字符串常量池存放的是对象及其引用。到 JDK7 时，字符串常量池被移动至堆中，此时字符串常量池只存放引用，字符串对象在堆中。</strong></p>
<br>

<h3 id="所处内存区域"><a href="#所处内存区域" class="headerlink" title="所处内存区域"></a>所处内存区域</h3><ul>
<li><p><strong>在 JDK 1.7 之前，运行时常量池（包括字符串常量池）存放在方法区，此时HotSpot虚拟机对方法区的实现为永久代。</strong></p>
</li>
<li><p><strong>在 JDK 1.7 时，字符串常量池被从方法区转移至 Java 堆中，注意并不是运行时常量池，而是字符串常量池被单独转移到堆，运行时常量池剩下的东西还是方法区中，也就是HotSpot的永久代</strong>。</p>
</li>
<li><p><strong>在 JDK 1.8 时，方法区（HotSpot 的永久代）被彻底移除了（JDK 7 就已经开始了），使用在本地内存中实现的元空间来代替。此时字符串常量池还在堆中，只不过方法区的实现从永久代变为了元空间，并将 JDK 1.7 中永久代剩余的内容（运行时常量池、类型信息）全部移到元空间</strong>。</p>
</li>
</ul>
<br>

<h3 id="String-类型的变量和常量做“-”运算时发生了什么？"><a href="#String-类型的变量和常量做“-”运算时发生了什么？" class="headerlink" title="String 类型的变量和常量做“+”运算时发生了什么？"></a>String 类型的变量和常量做“+”运算时发生了什么？</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str1 = <span class="string">&quot;str&quot;</span>;</span><br><span class="line">String str2 = <span class="string">&quot;ing&quot;</span>;</span><br><span class="line">String str3 = <span class="string">&quot;str&quot;</span> + <span class="string">&quot;ing&quot;</span>;	<span class="comment">//常量池中的对象</span></span><br><span class="line">String str4 = str1 + str2; 		<span class="comment">//在堆上创建的新的对象</span></span><br><span class="line">String str5 = <span class="string">&quot;string&quot;</span>;			<span class="comment">//常量池中的对象</span></span><br><span class="line">System.out.println(str3 == str4);<span class="comment">//false</span></span><br><span class="line">System.out.println(str3 == str5);<span class="comment">//true</span></span><br><span class="line">System.out.println(str4 == str5);<span class="comment">//false</span></span><br></pre></td></tr></table></figure>

<p>对于编译期可以确定值的字符串，也就是常量字符串 ，jvm 会将其存入字符串常量池。</p>
<p>并且，字符串常量拼接得到的字符串常量在编译阶段就已经被存放字符串常量池，这个得益于编译器的优化。</p>
<blockquote>
<p>在编译过程中，Javac 编译器（下文中统称为编译器）会进行一个叫做 <strong>常量折叠(Constant Folding)</strong> 的代码优化。</p>
<p>常量折叠会把常量表达式的值求出来作为常量嵌在最终生成的代码中，这是 Javac 编译器会对源代码做的极少量优化措施之一(代码优化几乎都在即时编译器中进行)。</p>
<p>对于 <code>String str3 = &quot;str&quot; + &quot;ing&quot;;</code> 编译器会给你优化成 <code>String str3 = &quot;string&quot;;</code> 。</p>
<p>并不是所有的常量都会进行折叠，只有编译器在程序编译期就可以确定值的常量才可以：</p>
<ol>
<li>基本数据类型(byte、boolean、short、char、int、float、long、double)以及字符串常量</li>
<li><code>final</code> 修饰的基本数据类型和字符串变量</li>
<li>字符串通过 “+” 拼接得到的字符串、基本数据类型之间算数运算（加减乘除）、基本数据类型的位运算（&lt;&lt;、&gt;&gt;、&gt;&gt;&gt; ）</li>
</ol>
<p>而引用的值在程序编译期无法确定的，编译器无法对其进行优化。</p>
</blockquote>
<p>因此，<code>str1</code> 、 <code>str2</code> 、 <code>str3</code> 都属于字符串常量池中的对象。</p>
<p>对象引用和 “+” 的字符串拼接方式，实际上是通过 <code>StringBuilder</code> 调用 <code>append()</code> 方法实现的，拼接完成之后调用 <code>toString()</code> 得到一个 <code>String</code> 对象 。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str4 = <span class="keyword">new</span> StringBuilder().append(str1).append(str2).toString();</span><br></pre></td></tr></table></figure>

<p>因此，<code>str4</code> 并不是字符串常量池中存在的对象，属于堆上的新对象。</p>
<p><img src="https://gitee.com/KIMTOU/img/raw/master/20211023175419.png"></p>
<p>不过，字符串使用 <code>final</code> 关键字声明之后，可以让编译器当做常量来处理。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> String str1 = <span class="string">&quot;str&quot;</span>;</span><br><span class="line"><span class="keyword">final</span> String str2 = <span class="string">&quot;ing&quot;</span>;</span><br><span class="line"><span class="comment">// 下面两个表达式其实是等价的</span></span><br><span class="line">String c = <span class="string">&quot;str&quot;</span> + <span class="string">&quot;ing&quot;</span>;	<span class="comment">// 常量池中的对象</span></span><br><span class="line">String d = str1 + str2; 	<span class="comment">// 常量池中的对象</span></span><br><span class="line">System.out.println(c == d);	<span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p><strong>被 <code>final</code> 关键字修改之后的 <code>String</code> 会被编译器当做常量来处理，编译器在程序编译期就可以确定它的值，其效果就想到于访问常量。</strong></p>
<p>可以通过查看字节码文件验证：</p>
<img src="https://gitee.com/KIMTOU/img/raw/master/20211023175522.PNG" style="zoom:67%;" />

<p>但如果编译器在运行时才能知道其确切值的话，就无法对其优化，即只要其中有一个是变量，结果就在堆中。</p>
<br>

<h3 id="new-String-会创建几个对象"><a href="#new-String-会创建几个对象" class="headerlink" title="new String()会创建几个对象"></a>new String()会创建几个对象</h3><ul>
<li>首先来看一个例子：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str1 = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">String str2 = <span class="keyword">new</span> String(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">String str3 = <span class="keyword">new</span> String(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">System.out.println(str1 == str2);	<span class="comment">//false</span></span><br><span class="line">System.out.println(str2 == str3);	<span class="comment">//false</span></span><br></pre></td></tr></table></figure>

<p>代码运行之后输出均为false，原因是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 从字符串常量池中拿对象</span></span><br><span class="line">String str1 = <span class="string">&quot;abc&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>此时 JVM 会先检查字符串常量池有没有”abc”，若存在，则str1直接指向常量池中的”abc”；若不存在，则在常量池中创建一个，然后 str1 指向字符串常量池中的对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 直接在堆内存中创建新的对象</span></span><br><span class="line">String str2 = <span class="keyword">new</span> String(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">String str3 = <span class="keyword">new</span> String(<span class="string">&quot;abc&quot;</span>);</span><br></pre></td></tr></table></figure>

<p><strong>使用 <code>new String()</code> 会在堆中创建一个字符串对象，然后检查字符串常量池中是否存在字符串值相同的字符串对象，若没有，则在字符串常量池中也创建一个值相同的字符串对象，最后返回堆中该字符串对象的地址</strong>。</p>
<p>故使用 <code>new String()</code> 会创建1或2个对象。</p>
<ul>
<li>那换一个例子：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str = <span class="keyword">new</span> String(<span class="string">&quot;a&quot;</span>) + <span class="keyword">new</span> String(<span class="string">&quot;b&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>此时创建了6个对象：</p>
<p>1、new StringBuilder（因为出现连接操作，且连接的是变量）</p>
<p>2、堆中的”a”</p>
<p>3、常量池中的”a”</p>
<p>4、堆中的”b”</p>
<p>5、常量池中的”b”</p>
<p>6、堆中的”ab”（通过<code>toString()</code>方法在堆中创建，但不会在字符串常量池中创建）</p>
<br>

<h3 id="关于intern"><a href="#关于intern" class="headerlink" title="关于intern()"></a>关于intern()</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s = <span class="keyword">new</span> String(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">s.intern();		<span class="comment">// 本质上这行代码没啥用，因为字符串常量池已经存在&quot;1&quot;了（由于new String）</span></span><br><span class="line">String s2 = <span class="string">&quot;1&quot;</span>;</span><br><span class="line">System.out.println(s == s2);	<span class="comment">// jdk6:false  jdk7/8:false</span></span><br><span class="line"></span><br><span class="line">String s3 = <span class="keyword">new</span> String(<span class="string">&quot;1&quot;</span>) + <span class="keyword">new</span> String(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">s3.intern();</span><br><span class="line">String s4 = <span class="string">&quot;11&quot;</span>;</span><br><span class="line">System.out.println(s3 == s4);	<span class="comment">// jdk6:false  jdk7/8:true</span></span><br></pre></td></tr></table></figure>

<p>在JDK1.6和 JDK1.7以后intern函数有不同的处理：</p>
<p>在JDK1.6中，intern的处理是：先判断字符串常量是否在字符串常量池中，如果存在直接返回该常量地址，如果没有找到，则在字符串常量池创建该常量并返回该对象地址；</p>
<p>在JDK1.7中，intern的处理是：先判断字符串常量是否在字符串常量池中，如果存在直接返回该常量地址；<strong>如果没有找到，说明该字符串常量在堆中，则处理是把堆区该对象的引用加入到字符串常量池中</strong>，之后拿到的是该字符串常量的引用，实际对象存储在堆中。</p>
<blockquote>
<p>使用intern方法，当常量池不存在字符串常量时：</p>
<p>JDK 1.7之前（不包括1.7）intern方法会<strong>在常量池创建对象，并返回对象的引用</strong>；JDK 1.7及以后，字符串常量池被从方法区拿到了堆中，使用intern方法时 <strong>JVM 不会在常量池中创建该对象，而是将堆中这个对象的引用直接放到常量池中</strong>，减少不必要的内存开销。</p>
</blockquote>
<br>

<h1 id="包装类以及对应的常量池"><a href="#包装类以及对应的常量池" class="headerlink" title="包装类以及对应的常量池"></a>包装类以及对应的常量池</h1><h3 id="包装类型是什么？基本类型和包装类型有什么区别？"><a href="#包装类型是什么？基本类型和包装类型有什么区别？" class="headerlink" title="包装类型是什么？基本类型和包装类型有什么区别？"></a>包装类型是什么？基本类型和包装类型有什么区别？</h3><p>Java 为每一个基本数据类型都引入了对应的包装类型（wrapper class），int 的包装类就是 Integer，从 Java 5 开始引入了自动装箱/拆箱机制，<strong>把基本类型转换成包装类型的过程叫做装箱（boxing）；反之，把包装类型转换成基本类型的过程叫做拆箱（unboxing）</strong>，使得二者可以相互转换。</p>
<p>Java 为每个原始类型提供了包装类型：</p>
<ul>
<li><p>原始类型: boolean，char，byte，short，int，long，float，double</p>
</li>
<li><p>包装类型：Boolean，Character，Byte，Short，Integer，Long，Float，Double</p>
</li>
</ul>
<p>基本类型和包装类型的区别主要有以下几点：</p>
<p>1、<strong>包装类型可以为 null，而基本类型不可以</strong>。它使得包装类型可以应用于 POJO 中，而基本类型则不行。那为什么 POJO 的属性必须要用包装类型呢？《阿里巴巴 Java 开发手册》上有详细的说明， 数据库的查询结果可能是 null，如果使用基本类型的话，因为要自动拆箱（将包装类型转为基本类型，比如说把 Integer 对象转换成 int 值），就会抛出 NullPointerException 的异常。</p>
<p>2、包装类型可用于泛型，而基本类型不可以。泛型不能使用基本类型，因为使用基本类型时会编译出错。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;<span class="keyword">int</span>&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(); <span class="comment">// 提示 Syntax error, insert &quot;Dimensions&quot; to complete ReferenceType</span></span><br><span class="line">List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br></pre></td></tr></table></figure>

<p>因为泛型在编译时会进行类型擦除，最后只保留原始类型，而原始类型只能是 Object 类及其子类——基本类型是个特例。</p>
<p>3、基本类型比包装类型更高效。基本类型在栈中直接存储的具体数值，而包装类型则存储的是堆中的引用。 很显然，相比较于基本类型而言，包装类型需要占用更多的内存空间。</p>
<br>

<h3 id="什么是自动装箱、自动拆箱"><a href="#什么是自动装箱、自动拆箱" class="headerlink" title="什么是自动装箱、自动拆箱"></a>什么是自动装箱、自动拆箱</h3><p><strong>自动装箱：将基本数据类型转化为包装类对象</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer i = <span class="number">9</span>;	==&gt;&gt;	Integer i = Integer.valueOf(<span class="number">9</span>)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>9是属于基本数据类型的，原则上它是不能直接赋值给一个对象Integer的。引入了自动装箱/拆箱机制，就可以进行这样的声明，自动将基本数据类型转化为对应的封装类型，成为一个对象以后就可以调用对象所声明的所有的方法。</p>
</blockquote>
<p><strong>自动拆箱：将包装类对象转化为基本数据类型</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer i = <span class="number">9</span>;</span><br><span class="line"><span class="keyword">int</span> j = i;	===&gt;&gt;	通过使用 Integer.intValue()	</span><br><span class="line"></span><br><span class="line"><span class="comment">// ===================</span></span><br><span class="line"></span><br><span class="line">Integer i = <span class="number">9</span>;</span><br><span class="line">System.out.print(i++);</span><br></pre></td></tr></table></figure>

<p>因为<strong>对象时不能直接进行运算的，而是要转化为基本数据类型后才能进行加减乘除</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer i1 = <span class="number">40</span>;</span><br><span class="line">Integer i2 = <span class="number">40</span>;</span><br><span class="line">Integer i3 = <span class="number">0</span>;</span><br><span class="line">Integer i4 = <span class="keyword">new</span> Integer(<span class="number">40</span>);</span><br><span class="line">Integer i5 = <span class="keyword">new</span> Integer(<span class="number">40</span>);</span><br><span class="line">Integer i6 = <span class="keyword">new</span> Integer(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(i1 == i2);<span class="comment">// true</span></span><br><span class="line">System.out.println(i1 == i2 + i3);<span class="comment">//true</span></span><br><span class="line">System.out.println(i1 == i4);<span class="comment">// false</span></span><br><span class="line">System.out.println(i4 == i5);<span class="comment">// false</span></span><br><span class="line">System.out.println(i4 == i5 + i6);<span class="comment">// true</span></span><br><span class="line">System.out.println(<span class="number">40</span> == i5 + i6);<span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p><code>i1</code> , <code>i2 </code>, <code>i3</code> 都是常量池中的对象，<code>i4</code> , <code>i5</code> , <code>i6</code> 是堆中的对象。</p>
<p><code>i4 == i5 + i6</code> 为什么是 true 呢？因为， <code>i5</code> 和 <code>i6</code> 会进行自动拆箱操作，进行数值相加，即 <code>i4 == 40</code> 。 <code>Integer</code> 对象无法与数值进行直接比较，所以 <code>i4</code> 自动拆箱转为 int 值 40，最终这条语句转为 <code>40 == 40</code> 进行数值比较。</p>
<br>

<h2 id="包装类常量池"><a href="#包装类常量池" class="headerlink" title="包装类常量池"></a>包装类常量池</h2><blockquote>
<p><code>Byte</code>, <code>Short</code>, <code>Integer</code>, <code>Long</code> 这 4 种包装类默认创建了数值 <strong>[-128, 127]</strong> 的相应类型的缓存数据，<code>Character</code> 创建了数值在 <strong>[0, 127]</strong> 范围的缓存数据，<code>Boolean</code> 直接返回 <code>True</code> or <code>False</code>。</p>
<p>两种浮点数类型的包装类 <code>Float</code>, <code>Double</code> 并没有实现常量池技术。</p>
</blockquote>
<h4 id="Integer"><a href="#Integer" class="headerlink" title="Integer"></a>Integer</h4><ul>
<li><strong>Integer缓存范围： [-128, 127]</strong></li>
</ul>
<p>Integer的equals方法被重写过，比较的是内部value的值；</p>
<p><strong>使用 == 如果在[-128, 127]会被cache缓存，超过这个则比较的是对象是否相同。</strong></p>
<p>Integer源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">        <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Integer(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">IntegerCache</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> low = -<span class="number">128</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> high;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Integer cache[];	<span class="comment">// cache数组已存储好 [-128, 127]的Integer对象</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> h = <span class="number">127</span>;</span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line">        high = h;</span><br><span class="line">        cache = <span class="keyword">new</span> Integer[(high - low) + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> j = low;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; cache.length; k++)</span><br><span class="line">            cache[k] = <span class="keyword">new</span> Integer(j++);	<span class="comment">// 创建[-128, 127]的Integer对象</span></span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="判断Integer值是否相同时，推荐使用equals方法或自动拆箱"><a href="#判断Integer值是否相同时，推荐使用equals方法或自动拆箱" class="headerlink" title="判断Integer值是否相同时，推荐使用equals方法或自动拆箱"></a>判断Integer值是否相同时，推荐使用equals方法或自动拆箱</h4><p><strong>1、使用equals方法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer x = <span class="number">128</span>;</span><br><span class="line">Integer y = <span class="number">128</span>;</span><br><span class="line">System.out.println(x == y);	<span class="comment">//结果为false</span></span><br></pre></td></tr></table></figure>

<p>因为128超过了缓存区，故x、y实际上都创建了值为128的Integer对象，地址肯定不一样</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer x = <span class="number">128</span>;</span><br><span class="line">Integer y = <span class="number">128</span>;</span><br><span class="line">System.out.println(x.equals(y));<span class="comment">//结果为true</span></span><br></pre></td></tr></table></figure>

<p>equals方法直接比较Integer对象的value属性值</p>
<p><strong>2、自动拆箱</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer x = <span class="number">128</span>;</span><br><span class="line">Integer y = <span class="number">128</span>;</span><br><span class="line"><span class="keyword">int</span> z = y;</span><br><span class="line">System.out.println(x == z);	<span class="comment">//结果为true</span></span><br></pre></td></tr></table></figure>

<p>先把运算比较的两个变量其中一个用int类型代替，==比较时x便自动拆箱转化为int</p>
<br>

<h1 id="补充：Java中的常量池"><a href="#补充：Java中的常量池" class="headerlink" title="补充：Java中的常量池"></a>补充：Java中的常量池</h1><h4 id="常量池分类"><a href="#常量池分类" class="headerlink" title="常量池分类"></a>常量池分类</h4><p>Java中常量池可分为三种：<code>全局字符串常量池</code>，<code>class文件常量池</code>，<code>运行时常量池</code>。其中<code>字符出常量池</code>就是<code>全局字符串常量池</code>。</p>
<p>关于这些常量池的详细解释可参考：<a href="http://tangxman.github.io/2015/07/27/the-difference-of-java-string-pool/">Java中几种常量池的区分</a></p>
<br>

<blockquote>
<p>参考资料</p>
</blockquote>
<p><a href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/jvm/Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F.md#%E5%9B%9B-%E9%87%8D%E7%82%B9%E8%A1%A5%E5%85%85%E5%86%85%E5%AE%B9">JavaGuide/Java内存区域.md at master · Snailclimb/JavaGuide (github.com)</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解Java虚拟机——垃圾收集器与内存分配策略</title>
    <url>/2021/10/24/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E2%80%94%E2%80%94%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/</url>
    <content><![CDATA[<h2 id="对象已死？"><a href="#对象已死？" class="headerlink" title="对象已死？"></a>对象已死？</h2><h4 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h4><p><strong>给对象中添加一个引用计数器，每当有一个地方引用它，计数器值就加 1；当引用失效时，计数器值就减 1；任何时刻计数器为 0 的对象就是不可能再被使用的。</strong></p>
<p>引用计数算法实现原理简单，判定效率高，但目前主流的虚拟机中都没有选择这个算法来管理内存，其主要原因是有很多例外情况要考虑，<strong>比如它很难解决对象之间相互循环引用的问题</strong>。所谓对象之间的相互引用问题，即对象 objA 和 objB 都有字段 instance ，且令 objA.instance = objB 及 objB.instance = objA ，除此之外，这两个对象之间再无任何引用。然后将 objA 与 objB 都置为 null，实际上着两个对象已经不可能再被访问，但是他们因为互相引用对方，导致它们的引用计数器都不为 0，于是引用计数算法无法通知 GC 回收器回收他们。</p>
<h4 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h4><p>这个算法的基本思路就是通过一系列称为 “GC Roots” 的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过程所走过的路径称为 “引用链” ，如果某个对象到 GC Roots 间没有任何引用链相连，或者用图论的话来说就是<strong>从 GC Roots 到这个对象不可达时，则证明此对象是不可能再被使用的</strong>。</p>
<p><img src="https://gitee.com/KIMTOU/img/raw/master/20211024194352.png"></p>
<p>可作为 GC Roots 的对象包括以下几种:</p>
<ul>
<li>虚拟机栈（栈帧中的本地变量表）中引用的对象，譬如当前正在运行方法所使用到的参数、局部变量等。</li>
<li>方法区中类静态属性引用的对象，譬如 Java 类的引用类型静态变量。</li>
<li>方法区中常量引用的对象，譬如字符串常量池（String Table）里的引用。</li>
<li>本地方法栈中 JNI（即Native 方法）引用的对象</li>
<li>所有被同步锁（synchronized关键字）持有的对象</li>
</ul>
<br>

<h4 id="再谈引用"><a href="#再谈引用" class="headerlink" title="再谈引用"></a>再谈引用</h4><p>无论是通过引用计数算法判断对象的引用数量，还是通过可达性分析算法判断对象是否引用链可达，判定对象是否存活都和 “引用” 有关。</p>
<p>引用分为<strong>强引用、软引用、弱引用、虚引用</strong> 4 种，引用强度依次减弱。</p>
<h5 id="强引用："><a href="#强引用：" class="headerlink" title="强引用："></a>强引用：</h5><p>指在代码之中普遍存在的引用赋值，即使用 <code>new</code> 对象创建强引用。无论任何情况下，<strong>只要强引用关系还存在，垃圾收集器就永远不会对被引用的对象进行回收</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object obj = <span class="keyword">new</span> Object();</span><br></pre></td></tr></table></figure>

<h5 id="软引用："><a href="#软引用：" class="headerlink" title="软引用："></a>软引用：</h5><p>用来描述一些还有用但非必须的对象，<strong>即只有在内存不够的情况下才会被回收</strong>。可使用 <code>SoftReference</code> 类来创建软引用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object obj = <span class="keyword">new</span> Object();</span><br><span class="line">SoftReference&lt;Object&gt; sf = <span class="keyword">new</span> SoftReference&lt;&gt;(obj);</span><br><span class="line">obj = <span class="keyword">null</span>;	<span class="comment">// 使对象只被软引用关联</span></span><br></pre></td></tr></table></figure>

<h5 id="弱引用："><a href="#弱引用：" class="headerlink" title="弱引用："></a>弱引用：</h5><p>也是用来描述那些非必须对象，<strong>但被弱引用关联的对象不管内存是否足够都一定会被回收，也就是说它只能存活到下一次垃圾回收发生为止</strong>，比起软引用，只具有弱引用的对象拥有更短暂的生命周期。可以使用 <code>WeakReference</code> 类来创建弱引用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object obj = <span class="keyword">new</span> Object();</span><br><span class="line">WeakReference&lt;Object&gt; wf = <span class="keyword">new</span> WeakReference&lt;&gt;(obj);</span><br><span class="line">obj = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>软引用和弱引用都可以和一个引用队列（ReferenceQueue）联合使用，如果软/弱引用所引用的对象被垃圾回收，JAVA 虚拟机就会把这个软/弱引用加入到与之关联的引用队列中。</p>
<p>虚引用必须和引用队列（ReferenceQueue）联合使用</p>
</blockquote>
<h5 id="虚引用："><a href="#虚引用：" class="headerlink" title="虚引用："></a>虚引用：</h5><p>又称为“幽灵引用”或者“幻影引用”，一个对象是否有虚引用的存在，完全不会对其生存时间造成影响，也无法通过虚引用来取得一个对象实例。<strong>为一个对象设置虚引用的唯一目的是能在这个对象被回收时收到一个系统通知</strong>。可以使用 <code>PhantomReference</code> 来创建虚引用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object obj = <span class="keyword">new</span> Object();</span><br><span class="line">PhantomReference&lt;Object&gt; pf = <span class="keyword">new</span> PhantomReference&lt;&gt;(obj, <span class="keyword">null</span>);</span><br><span class="line">obj = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在程序设计中一般很少使用弱引用与虚引用，使用软引用的情况较多，这是因为<strong>软引用可以加速 JVM 对垃圾内存的回收速度，可以维护系统的运行安全，防止内存溢出（OutOfMemory）等问题的产生</strong>。</p>
</blockquote>
<br>

<h4 id="回收方法区"><a href="#回收方法区" class="headerlink" title="回收方法区"></a>回收方法区</h4><p>《 Java虚拟机规范 》中并没有强制要求虚拟机必须实现方法区（HotSpot中的元空间或永久代）的垃圾收集，而且方法区中进行垃圾收集的“性价比”比较低。</p>
<p><strong>方法区的垃圾收集主要回收两部分内容：废弃常量和不再使用的类（即无用的类）</strong>。回收废弃常量与回收 Java 堆中的对象非常类似。如果没有任何地方引用这些常量便会被系统清理。</p>
<p>判断一个常量是否 “废弃” 相对简单，而要判定一个类是否属于 “不再被使用的类” 的条件就比较苛刻。需要同时满足下面三个条件：</p>
<ul>
<li>该类的所有实例都已经被回收，也就是 Java 堆中不存在该类及派生子类的任何实例。</li>
<li>加载该类的类加载器已经被回收了。</li>
<li>该类对应的 java.lang.Class 对象没有在被任何地方被引用，无法在任何地方通过反射访问该类的方法。</li>
</ul>
<br>

<h2 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h2><h4 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记 - 清除算法"></a>标记 - 清除算法</h4><p><strong>首先标记出所有需要回收的对象，在标记完成后，统一回收掉所有被标记的对象</strong>（也可以反过来）。标记过程就是对象是否属于垃圾的判定过程（即引用计数与可达性分析算法）。</p>
<img src="https://gitee.com/KIMTOU/img/raw/master/20211024194350.png" style="zoom:80%;" />

<h5 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h5><ul>
<li>执行效率不稳定：如果 Java 堆中包含大量可回收对象，这时必须进行大量标记和清除动作，导致标记和清除两个过程的效率都不高。同时需要扫描两次。</li>
<li>空间问题：标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后再程序运行过程中需要分配较大的对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。</li>
</ul>
<blockquote>
<p>通过可达性分析算法从Root根节点出发递归遍历可达对象，进行标记。然后一一遍历内存，将可回收的对象进行清除。</p>
</blockquote>
<br>

<h4 id="标记-复制算法"><a href="#标记-复制算法" class="headerlink" title="标记 - 复制算法"></a>标记 - 复制算法</h4><p>为了解决标记 - 清除算法面对大量可回收对象时执行效率低问题而诞生。<strong>将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另一块上面，然后再把已使用过的内存空间一次清理掉</strong>。这样使得每次都是对整个半区进行内存回收，内存分配时也就不用考虑空间碎片的复杂情况，只要移动堆顶指针，按顺序分配内存即可，且只需要扫描一次，实现简单，运行高效。</p>
<p>缺点是：</p>
<ul>
<li>将可用内存缩小为了原来的一半，空间浪费未免太多了一点。</li>
<li>移动时，需要复制对象，并调整对象引用。</li>
</ul>
<img src="https://gitee.com/KIMTOU/img/raw/master/20211024194354.png" style="zoom:80%;" />

<blockquote>
<p>为什么说执行效率更高？</p>
<p>从Root根节点递归遍历可达对象时，遍历到时不进行标记，直接复制到另一块内存上。而且也不需要一一遍历进行清除，直接整个清理掉就行。</p>
</blockquote>
<p>现在的商业虚拟机都采用这种收集算法来回收新生代，IBM公司的专门研究表明，新生代中的对象98%是“朝生夕死”的，所以并不需要按照1:1的比例来划分新生代的内存空间，<strong>而是将内存分为一块较大的Eden空间和两块较小的Survivor空间，每次分配内存只使用Eden和其中一块Survivor</strong>。</p>
<p><strong>发生垃圾收集时，将Eden和Survivor中仍然存活的对象一次性地复制到另外一块Survivor空间上，然后直接清理掉Eden和刚才用过的那块Survivor空间。</strong></p>
<p>HotSpot虚拟机默认Eden和Survivor的大小比例是8:1，也就是每次新生代中可用内存空间为整个新生代容量的90%（Eden的80% + 一个Survivor的10%），只有10%的新生代内存会被“浪费”。</p>
<p>当然，98%的对象可被回收仅仅是普通场景下测得的数据，任何人都没办法保证每次回收都只有不多于10%的对象存活，<strong>因此当Survivor空间不足以容纳依次Minor GC之后存活的对象时，就需要依赖其他内存（指老年代）进行分配担保（Handle Promotion）</strong>。</p>
<br>

<h4 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记 - 整理算法"></a>标记 - 整理算法</h4><p><strong>复制收集算法在对象存活率较高时就要进行较多的复制操作</strong>，效率将会变低。更关键的是，如果不想浪费50%的空间，就需要有额外的空间进行分配担保，以应对被使用的内存中所有对象都100%存活的极端情况，所以在老年代一般不能直接选用这种算法。</p>
<p>针对老年代对象的存亡特征，提出了标记 - 整理算法。标记过程仍然与 “标记 - 清除” 算法一样，但后续步骤不是直接对可回收对象进行清理，<strong>而是让所有存活的对象都向内存空间一端移动，然后直接清理掉边界以外的内存</strong>。</p>
<img src="https://gitee.com/KIMTOU/img/raw/master/20211024194358.png" style="zoom:80%;" />

<ul>
<li><p>优点：不会产生内存碎片</p>
</li>
<li><p>不足：需要扫描两次；需要移动大量对象，处理效率比较低。</p>
</li>
</ul>
<blockquote>
<p>标记 - 清除算法内存不连续，只能使用空闲列表来为对象分配内存；复制和整理算法都可用使用指针碰撞。</p>
</blockquote>
<hr>
<h4 id="分代收集理论"><a href="#分代收集理论" class="headerlink" title="分代收集理论"></a>分代收集理论</h4><p>弱分代假说（Weak Generational Hypothesis）：绝大多数对象都是朝生夕灭的。<br>强分代假说（Strong Generational Hypothesis）：熬过越多次垃圾收集过程的对象就越难以消亡。<br>跨代引用假说（Intergenerational Reference Hypothesis）：跨代引用相对于同代引用来说仅占极少数。</p>
<h4 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h4><p>当前虚拟机的垃圾收集都采用分代收集算法，这种算法只是根据对象存活周期的不同将内存分为几块。一般将 Java 堆分为新生代和老年代，这样我们就可以根据各个年代的特点选择合适的垃圾收集算法。</p>
<p><strong>比如在新生代中，每次收集都会有大量对象死去，所以可以选择 ”标记-复制“ 算法，只需要付出少量对象的复制成本就可以完成每次垃圾收集。而老年代的对象存活几率是比较高的，而且没有额外的空间对它进行分配担保，所以我们必须选择 “标记-清除” 或 “标记-整理” 算法进行垃圾收集。</strong></p>
<hr>
<h4 id="GC目标"><a href="#GC目标" class="headerlink" title="GC目标"></a>GC目标</h4><ul>
<li><p>部分收集（ Partial GC ）：指目标不是完整收集整个Java堆的垃圾收集，其中分为：</p>
<ul>
<li><strong>新生代收集（ Minor GC / Young GC ）：指目标只是新生代的垃圾收集。</strong>因为新生代对象存活时间很短，因此 Minor GC 会频繁执行，执行的速度一般也会比较快。</li>
<li>老年代收集（ Major GC / Old GC ）：指目标只是老年代的垃圾收集（目前只有CMS收集器有单独收集老年代的行为）。</li>
<li>混合收集（ Mixed GC ）：指目标是收集整个新生代以及部分老年代的垃圾收集（目前只有C1收集器）。</li>
</ul>
</li>
<li><p><strong>整堆收集（ Full GC ）：收集整个 Java 堆和方法区的垃圾收集。</strong>回收老年代和新生代，老年代对象其存活时间长，因此 Full GC 很少执行，执行速度会比 Minor GC 慢很多。</p>
</li>
</ul>
<br>

<h2 id="堆的内存细分"><a href="#堆的内存细分" class="headerlink" title="堆的内存细分"></a>堆的内存细分</h2><p>Java 的自动内存管理主要是针对对象内存的回收和对象内存的分配。</p>
<p>垃圾收集主要是针对<strong>堆和方法区</strong>进行。程序计数器、虚拟机栈和本地方法栈这三个区域属于线程私有的，只存在于线程的生命周期内，线程结束之后就会消失，因此不需要对这三个区域进行垃圾回收。</p>
<p>Java 堆是垃圾收集器管理的主要区域，因此也被称作<strong>GC 堆（Garbage Collected Heap）</strong>。从垃圾回收的角度，由于现在收集器基本都采用分代垃圾收集算法，所以 Java 堆还可以细分为：新生代和老年代：再细致一点有：Eden 空间、From Survivor、To Survivor 空间等。<strong>进一步划分的目的是更好地回收内存，或者更快地分配内存。</strong></p>
<ul>
<li><strong>堆空间的基本结构：</strong></li>
</ul>
<p>其中Eden 区、From Survivor0(“From”) 区、To Survivor1(“To”) 区都属于新生代，Old Memory 区属于老年代</p>
<p><img src="https://gitee.com/KIMTOU/img/raw/master/20211024194401.png" alt="堆空间的基本结构"></p>
<p>大部分情况，对象都会首先在 Eden 区域分配，在一次新生代垃圾回收后<strong>（当Eden区满时触发YGC/Minor GC），如果对象还存活，则会进入 s0 或者 s1，即将Eden区以及From区还存活的对象转移至To，并且对象的年龄还会加 1 (Eden 区转移至Survivor 区后对象的初始年龄变为 1)，当它的年龄增加到一定程度（默认为大于 15 岁），就会被晋升到老年代中</strong>。对象晋升到老年代的年龄阈值，可以通过参数 <code>-XX:MaxTenuringThreshold</code> 来设置默认值，这个值会在虚拟机运行过程中进行调整，可以通过<code>-XX:+PrintTenuringDistribution</code>来打印出当次GC后的Threshold。</p>
<p>经过这次 GC 后，Eden 区和”From”区已经被清空。这个时候，”From”和”To”会交换他们的角色，也就是新的”To”就是上次 GC 前的“From”，新的”From”就是上次 GC 前的”To”。不管怎样，<strong>都会保证名为 To 的 Survivor 区域是空的</strong>。Minor GC 会一直重复这样的过程，在这个过程中，有可能当次Minor GC后，Survivor 的”From”区域空间不够用，有一些还达不到进入老年代条件的实例放不下，则放不下的部分会提前进入老年代。</p>
<br>

<h2 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h2><p><strong>如果说收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。</strong></p>
<p><img src="https://gitee.com/KIMTOU/img/raw/master/20211024194403.png"></p>
<p>以上是 HotSpot 虚拟机中的 7 种垃圾收集器，连线表示垃圾收集器之间可以搭配使用。</p>
<p>在谈论垃圾收集器的上下文语境中，可用理解为：</p>
<ul>
<li>并行（Parallel）：并行描述的是多个垃圾收集器线程之间的关系，说明同一时间有多个这样的线程在协同工作，通常默认此时用户线程是处于等待状态。</li>
<li>并发（Concurrent）：并发描述的是垃圾收集器线程与用户线程之间的关系，说明同一时间垃圾收集器线程与用户线程都在运行。</li>
</ul>
<br>

<h3 id="Serial-收集器"><a href="#Serial-收集器" class="headerlink" title="Serial 收集器"></a>Serial 收集器</h3><p>Serial（串行）收集器是一个单线程工作的收集器，它的 <strong>“单线程”</strong> 的意义不仅仅说明它只会使用一个处理器或一条垃圾收集线程去完成垃圾收集工作，更重要的是强调在它进行垃圾收集时，必须暂停其他所有的工作线程（ <strong>“Stop The World”</strong> ），直到它收集结束。是虚拟机运行在客户端模式下的默认新生代收集器。</p>
<ul>
<li>作用域：新生代</li>
<li>垃圾收集算法：复制算法</li>
<li>线程数：单线程</li>
<li>特点：进行垃圾收集时，由于是单线程，需要Stop The World，即将其他所有用户线程停止，直到收集结束。但简单高效（避免线程切换的开销），内存消耗小。</li>
</ul>
<p><img src="https://gitee.com/KIMTOU/img/raw/master/20211024194406.jpg"></p>
<br>

<h3 id="ParNew-收集器"><a href="#ParNew-收集器" class="headerlink" title="ParNew 收集器"></a>ParNew 收集器</h3><p>ParNew 收集器其实就是 Serial 收集器的多线程版本，除了使用多线程进行垃圾收集外，其余行为（控制参数、收集算法、回收策略等等）和 Serial 收集器完全一样。</p>
<ul>
<li>作用域：新生代</li>
<li>垃圾收集算法：复制算法</li>
<li>线程数：多线程</li>
<li>特点：多线程，在多核CPU情况下垃圾收集效率较高，Stop The World的时间较短。</li>
</ul>
<p><img src="https://gitee.com/KIMTOU/img/raw/master/20211024194409.jpg"></p>
<br>

<h3 id="Parallel-Scavenge-收集器"><a href="#Parallel-Scavenge-收集器" class="headerlink" title="Parallel Scavenge 收集器"></a>Parallel Scavenge 收集器</h3><p>Parallel Scavenge 收集器也是使用<strong>标记-复制算法</strong>的<strong>多线程</strong>收集器，它看上去几乎和 ParNew 都一样。 那么它有什么特别之处呢？</p>
<p><strong>CMS 等垃圾收集器的关注点是尽可能缩短垃圾收集时用户线程的停顿时间，而 Parallel Scavenge 收集器的目标是达到一个可控制的吞吐量。所谓吞吐量就是 CPU 用于运行用户代码的时间与 CPU 总消耗时间的比值。</strong>停顿时间越短就越适合需要与用户交互的程序，良好的响应速度能提升用户体验；而高吞吐量则可以高效率地利用 CPU 资源，尽快完成程序的运算任务，适合在后台运算而不需要太多交互的分析任务。</p>
<p>垃圾收集停顿时间缩短是以牺牲吞吐量和新生代空间为代价换取的：新生代空间变小，垃圾回收变得频繁，停顿事件下降，但也导致吞吐量下降。</p>
<ul>
<li>作用域：新生代</li>
<li>垃圾收集算法：复制算法</li>
<li>线程数：多线程</li>
<li>特点：目标是提高吞吐量，能够在较短的时间内完成指定任务，适合不需太多交互的后台运算</li>
</ul>
<p>Parallel Scavenge 收集器提供了很多参数供用户找到最合适的停顿时间或最大吞吐量：<br><code>-XX:MaxGCPauseMillis </code>用于控制最大垃圾收集停顿时间<br><code>-XX:GCTimeRatio </code>用于直接设置吞吐量的大小</p>
<p>如果对于收集器运作不太了解，手工优化存在困难的时候，<strong>可以通过一个开关参数打开 GC 自适应的调节策略</strong>（GC Ergonomics），就不需要手工指定新生代的大小（-Xmn）、Eden 和 Survivor 区的比例、晋升老年代对象年龄等细节参数了。虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量。</p>
<p><strong>JDK1.8 默认使用的是 Parallel Scavenge + Parallel Old</strong>，如果指定了-XX:+UseParallelGC 参数，则默认指定了-XX:+UseParallelOldGC，可以使用-XX:-UseParallelOldGC 来禁用该功能</p>
<br>

<h3 id="Serial-Old-收集器"><a href="#Serial-Old-收集器" class="headerlink" title="Serial Old 收集器"></a>Serial Old 收集器</h3><p><strong>Serial 收集器的老年代版本，它同样是一个单线程收集器</strong>。</p>
<ul>
<li>作用域：老年代</li>
<li>垃圾收集算法：标记 - 整理算法</li>
<li>线程数：单线程</li>
<li>特点：与 Serial 收集器相同</li>
</ul>
<p>它主要有两大用途：</p>
<ul>
<li>在 JDK 1.5 以及之前版本（Parallel Old 诞生以前）中与 Parallel Scavenge 收集器搭配使用。</li>
<li>作为 CMS 收集器的后备预案，在并发收集发生 Concurrent Mode Failure 时使用。</li>
</ul>
<br>

<h3 id="Parallel-Old-收集器"><a href="#Parallel-Old-收集器" class="headerlink" title="Parallel Old 收集器"></a>Parallel Old 收集器</h3><p><strong>Parallel Old 收集器是 Parallel Scavenge 收集器的老年代版本，支持多线程并行收集，基于标记 - 整理算法</strong>。</p>
<ul>
<li>作用域：老年代</li>
<li>垃圾收集算法：标记 - 整理算法</li>
<li>线程数：多线程</li>
<li>特点：目标是提高吞吐量</li>
</ul>
<p><img src="https://gitee.com/KIMTOU/img/raw/master/20211024194413.jpg"></p>
<br>

<h3 id="CMS-收集器"><a href="#CMS-收集器" class="headerlink" title="CMS 收集器"></a>CMS 收集器</h3><p><strong>CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。它非常符合在注重用户交互体验的应用上使用。</strong>CMS 收集器是 HotSpot 虚拟机第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程（基本上）同时工作。</p>
<ul>
<li>作用域：老年代</li>
<li>垃圾收集算法：标记 - 清除算法</li>
<li>线程数：并发线程</li>
<li>特点：以缩短停顿时间为目标</li>
</ul>
<p>从名字中的<strong>Mark Sweep</strong>可以看出，CMS 收集器是基于 <strong>“标记-清除”算法</strong>实现的，它的运作过程相比于前面几种垃圾收集器来说更加复杂一些。整个过程分为四个步骤：</p>
<ul>
<li><strong>初始标记： 仅仅只是标记一下 GC Roots 能直接关联到的对象</strong>，速度很快。</li>
<li><strong>并发标记：并发标记阶段从GC Roots的直接关联对象开始遍历整个对象图的过程，这个过程耗时较长但是不需要停顿用户线程，可以与垃圾收集线程一起并发运行</strong>。</li>
<li><strong>重新标记： 重新标记阶段是为了修正并发标记期间因用户程序继续运行而导致标记产生变动的那一部分对象的标记记录</strong>。这个阶段的停顿时间一般会比初始标记阶段的时间稍长，但也远比并发标记阶段的时间短。</li>
<li><strong>并发清除： 清理删除掉标记阶段判断的已经死亡的对象</strong>，对未标记的区域做清扫。由于不需要移动存活对象，所以这个阶段也是可以与用户线程并发执行的。</li>
</ul>
<p>其中初始标记、重新标记这两个步骤仍然需要 “ Stop The World ”，但速度很快。由于在整个过程中耗时最长的并发标记和并发清除阶段中，垃圾收集器线程都可以与用户线程一起工作，所以从总体上 CMS 收集器的内存回收过程是与用户线程一起并发执行的。</p>
<p><img src="https://gitee.com/KIMTOU/img/raw/master/20211024194416.jpg"></p>
<br>

<h3 id="G1-收集器"><a href="#G1-收集器" class="headerlink" title="G1 收集器"></a>G1 收集器</h3><p><strong>G1 (Garbage-First) 是一款面向服务端应用的垃圾收集器，主要针对配备多核CPU及大容量内存的机器，以极高概率满足 GC 停顿时间要求的同时，还兼具高吞吐量的性能特征</strong>。被视为 JDK1.7 中 HotSpot 虚拟机的一个重要进化特征，在 JDK 9 时正式取代 Parallel Scavenge + Parallel Old 组合成为默认垃圾收集器。</p>
<ul>
<li>作用域：新生代与老年代</li>
<li>垃圾收集算法：标记 - 复制算法（局部上看）、标记 - 整理算法（整体上看）</li>
<li>线程数：并发线程</li>
<li>特点：以缩短停顿时间为目标，同时兼顾高吞吐量</li>
</ul>
<p>G1出现之前的垃圾收集器，包括CMS在内，垃圾收集的目标范围要么是整个新生代（Minor GC），要么就是整个老年代（Major GC），再要么就是整个 Java 堆（Full GC）。而 G1 跳出了这个框架，它可以面向堆内存的任何部分来组成<strong>回收集(Collection Set，CSet)<strong>，</strong>衡量标准不再是它属于哪个分代，而是哪块内存中存放的垃圾数量最多</strong>，回收收益最大，这就是 G1 收集器的 <strong>Mixed GC</strong> 模式。</p>
<p><img src="https://gitee.com/KIMTOU/img/raw/master/20211024194419.PNG"></p>
<p>G1 是基于 Region 的堆内存布局来进行回收的，G1不再坚持固定大小以及固定数量的分代区域划分，<strong>而是把连续的 Java 堆划分为多个大小相等的独立区域 Region，每一个 Region 都可以根据需要，扮演新生代的 Eden 空间、Survivor 空间或者老年代空间</strong>，收集器能够对不同角色的 Region 采用不同的策略去处理。</p>
<p><strong>Region 中还有一类特殊的 Humongous 区域，专门用来存储大对象</strong>。G1 认为只要大小超过了一个 Region 容量一半的对象即可判定为大对象。对于超过了整个 Region 容量的超级大对象，将会存放在 N 个连续的 Humongous Region 中，G1 大多数行为都会把 Humongous Region 作为老年代的一部分来看待。</p>
<h4 id="运行过程"><a href="#运行过程" class="headerlink" title="运行过程"></a>运行过程</h4><p>G1收集器的运作过程大致可划分为以下四个步骤：</p>
<ul>
<li><strong>初始标记：仅仅只是标记一下 GC Roots 能直接关联到的对象，并修改 TAMS 指针的值</strong>，让下一阶段用户线程并发运行时，能够在可用的 Region 中分配对象。这个阶段需要暂停用户线程，但是时间很短。而且这个停顿是借用 Minor GC 的时候同步完成的，所以在这个阶段实际没有额外的停顿。</li>
<li><strong>并发标记：从 GC Root 开始对堆中对象进行可达性分析，递归扫描整个堆里的对象图，找出要回收的对象</strong>。当对象图扫描完成后，还要重新处理 SATB 记录下的在并发时有引用变动的对象。</li>
<li><strong>最终标记：对用户线程做另一个短暂的暂停，用于处理并发阶段结束后仍遗留下来的最后那少量的 SATB 记录</strong>（原始快照，用来记录并发标记中某些对象）。</li>
<li><strong>筛选回收：负责更新 Region 的统计数据，对各个 Region 的回收价值和成本进行排序，根据用户所期望的停顿时间来制定回收计划</strong>，可以自由选择任意多个 Region 构成回收集，然后<strong>把决定要回收的那一部分 Region 的存活对象复制到空的 Region 中，再清理掉整个旧 Region 的全部空间</strong>。这里的操作涉及存活对象的移动，所以必须要暂停用户线程，由多条收集器线程并行完成。</li>
</ul>
<p><img src="https://gitee.com/KIMTOU/img/raw/master/20211024194422.jpg"></p>
<br>

<h2 id="内存分配策略"><a href="#内存分配策略" class="headerlink" title="内存分配策略"></a>内存分配策略</h2><h4 id="1、对象优先在-Eden-分配"><a href="#1、对象优先在-Eden-分配" class="headerlink" title="1、对象优先在 Eden 分配"></a>1、对象优先在 Eden 分配</h4><p>大多数情况下，对象在新生代 Eden 区分配，当 Eden 区没有足够空间进行分配时，虚拟机发起一次 Minor GC。</p>
<h4 id="2、大对象直接进入老年代"><a href="#2、大对象直接进入老年代" class="headerlink" title="2、大对象直接进入老年代"></a>2、大对象直接进入老年代</h4><p>大对象是指需要大量连续内存空间的对象（最典型的大对象是那种很长的字符串以及元素数量大的数组）。</p>
<h4 id="3、长期存活的对象将进入老年代"><a href="#3、长期存活的对象将进入老年代" class="headerlink" title="3、长期存活的对象将进入老年代"></a>3、长期存活的对象将进入老年代</h4><p>虚拟机给每个对象定义了一个对象年龄计数器，存储在对象头中。如果对象在 Eden 出生并经过第一次 Minor GC 后仍然能够存活，并且能被 Survivor 容纳的话，将被移动到 Survivor 空间中，并将对象年龄设为 1 岁。对象在 Survivor 区中每熬过一次 MinorGC，年龄就增加 1 岁，当它的年龄增加到一定程度（默认为 15 ），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 <code>-XX:MaxTenuringThreshold</code> 设置。</p>
<h4 id="4、动态对象年龄判定"><a href="#4、动态对象年龄判定" class="headerlink" title="4、动态对象年龄判定"></a>4、动态对象年龄判定</h4><p>虚拟机并不是永远要求对象的年龄必须达到 <code>-XX:MaxTenuringThreshold</code> 才能晋升老年代，如果在 Survivor 空间中低于或等于某年龄的所有对象大小的总和大于 Survivor 空间的一半，则年龄大于或等于该年龄的对象就可以直接进入老年代，无须等到 <code>-XX:MaxTenuringThreshold</code> 中要求的年龄。</p>
<ul>
<li><strong>动态年龄计算策略：</strong></li>
</ul>
<p>Hotspot 遍历所有对象时，按照相同年龄从小到大对其所占用的大小进行累积，当累积的某个年龄大小超过了 survivor 区的一半时，取这个年龄和 MaxTenuringThreshold 中更小的一个值，作为新的晋升年龄阈值。</p>
<ul>
<li><strong>动态年龄计算的代码如下：</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">uint <span class="title">ageTable::compute_tenuring_threshold</span><span class="params">(<span class="keyword">size_t</span> survivor_capacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//survivor_capacity是survivor空间的大小</span></span><br><span class="line">    <span class="keyword">size_t</span> desired_survivor_size = (<span class="keyword">size_t</span>)((((<span class="keyword">double</span>) survivor_capacity)*TargetSurvivorRatio)/<span class="number">100</span>);</span><br><span class="line">    <span class="keyword">size_t</span> total = <span class="number">0</span>;</span><br><span class="line">    uint age = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (age &lt; table_size) &#123;</span><br><span class="line">        total += sizes[age];<span class="comment">//sizes数组是每个年龄段对象大小</span></span><br><span class="line">        <span class="keyword">if</span> (total &gt; desired_survivor_size) <span class="keyword">break</span>;</span><br><span class="line">        age++;</span><br><span class="line">    &#125;</span><br><span class="line">    uint result = age &lt; MaxTenuringThreshold ? age : MaxTenuringThreshold;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5、空间分配担保"><a href="#5、空间分配担保" class="headerlink" title="5、空间分配担保"></a>5、空间分配担保</h4><p><strong>在发生 Minor GC 之前，虚拟机必须先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果条件成立的话，那这一次 Minor GC 可以确保是安全的</strong>。</p>
<blockquote>
<p>为什么说这次 Minor GC 是确保安全的呢？因为我们知道新生代使用复制收集算法，且只使用其中一个 Survivor 空间作为轮换备份，因此当出现大量对象在 Minor GC 后仍然存活的情况（最极端的情况就是内存回收后新生代中所有对象都存活），可能出现 Survivor 空间不够存下这些对象，需要老年代进行分配担保，把 Survivor 无法容纳的对象直接送入老年代。而老年代担保的前提是本身还有容纳这些对象的剩余空间，但有多少对象会再这次回收中活下来在实际完成内存回收之前是无法明确知道的，只能取之前的平均大小作为经验值。</p>
<p><strong>即空间分配担保是为了确保在 Minor GC 之前老年代本身还有容纳新生代所有对象的剩余空间。</strong></p>
</blockquote>
<p>如果不成立的话，虚拟机会先查看 HandlePromotionFailure 参数的值是否允许担保失败。如果允许，那会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次 Minor GC，尽管这次 Minor GC 是有风险的；如果小于，或者 HandlePromotionFailure 设置不允许冒险，那么就要改为进行一次 Full GC。</p>
<p>在 JDK 6 Update 24 之后，-XX:HandlePromotionFailure 参数不会再影响到虚拟机的空间分配担保策略，实际虚拟机中已经不会再使用它。<strong>JDK 6 Update 24 之后的规则变为只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小，就会进行 Minor GC，否则将进行 Full GC</strong>。</p>
<br>

<blockquote>
<p>参考资料</p>
</blockquote>
<p><strong>《深入理解Java虚拟机  第3版》——周志明</strong></p>
<p><a href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/jvm/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6.md">https://github.com/Snailclimb/JavaGuide</a></p>
<p>[<a href="https://github.com/CyC2018]">https://github.com/CyC2018]</a>(<a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java">https://github.com/CyC2018/CS-Notes/blob/master/notes/Java</a> 虚拟机.md)</p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>CMS与G1垃圾收集器详解</title>
    <url>/2021/10/24/CMS%E4%B8%8EG1%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="CMS-收集器"><a href="#CMS-收集器" class="headerlink" title="CMS 收集器"></a>CMS 收集器</h3><p><strong>CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。它非常符合在注重用户交互体验的应用上使用</strong>。CMS 收集器是 HotSpot 虚拟机第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程（基本上）同时工作。</p>
<ul>
<li>作用域：老年代</li>
<li>垃圾收集算法：标记 - 清除算法</li>
<li>线程数：并发线程</li>
<li>特点：以缩短停顿时间为目标</li>
</ul>
<p>从名字中的<strong>Mark Sweep</strong>可以看出，CMS 收集器是基于 <strong>“标记-清除”算法</strong>实现的，它的运作过程相比于前面几种垃圾收集器来说更加复杂一些。整个过程分为四个步骤：</p>
<ul>
<li><strong>初始标记： 仅仅只是标记一下 GC Roots 能直接关联到的对象</strong>，速度很快。</li>
<li><strong>并发标记：并发标记阶段从GC Roots的直接关联对象开始遍历整个对象图的过程，这个过程耗时较长但是不需要停顿用户线程，可以与垃圾收集线程一起并发运行</strong>。</li>
<li><strong>重新标记： 重新标记阶段是为了修正并发标记期间因用户程序继续运行而导致标记产生变动的那一部分对象的标记记录</strong>。这个阶段的停顿时间一般会比初始标记阶段的时间稍长，但也远比并发标记阶段的时间短。</li>
<li><strong>并发清除： 清理删除掉标记阶段判断的已经死亡的对象</strong>，对未标记的区域做清扫。由于不需要移动存活对象，所以这个阶段也是可以与用户线程并发执行的。</li>
</ul>
<p>其中初始标记、重新标记这两个步骤仍然需要 “ Stop The World ”，但速度很快。由于在整个过程中耗时最长的并发标记和并发清除阶段中，垃圾收集器线程都可以与用户线程一起工作，所以从总体上 CMS 收集器的内存回收过程是与用户线程一起并发执行的。</p>
<p><img src="https://gitee.com/KIMTOU/img/raw/master/20211024194416.jpg"></p>
<p>CMS 是一款非常优秀的垃圾收集器，有着<strong>并发收集（2，4阶段）、低延迟（1，3阶段）</strong>的优点。但还远没有完美的程度，至少有三个明显缺点：</p>
<ul>
<li>CMS 对处理器资源非常敏感，在并发阶段，虽然不会造成用户线程停顿，但是却会因为占用一部分线程而导致应用程序变慢，降低总吞吐量。</li>
<li><strong>CMS 无法处理 “浮动垃圾” ，有可能出现 Concurrent Mode Failure 失败进而导致另一次完全 Stop The World 的 Full GC 产生</strong>。同样也是由于在垃圾收集阶段用户线程还需要持续运行，那就还需要预留足够内存空间提供给用户线程使用，因此CMS收集器不能像其他收集器那样等待老年代几乎完全被填满了再进行收集，而是当堆内存使用率达到某一阈值时，便开始进行回收。若预留的内存无法满足需要，则会出现一次“并发失败”（Concurrent Mode Failure）。</li>
</ul>
<blockquote>
<p>什么是浮动垃圾？由于并发标记和并发清理阶段，用户线程还是在继续运行的，程序自然就还会伴随有新的垃圾对象不断产生，而且这一部分垃圾对象出现在标记过程结束之后，CMS 无法在当次收集中处理掉这些垃圾，所以只能等到下一次垃圾回收时再进行清理。这一部分垃圾就称为浮动垃圾。</p>
</blockquote>
<ul>
<li>由于使用 “标记-清除” 算法，会导致大量空间碎片产生，可能无法找到足够大连续空间来分配当前对象，不得不提前触发一次 Full GC</li>
</ul>
<blockquote>
<p>但CMS只能使用标记-清除算法，因为当并发清除时，如果用整理算法，对象的移动会使得地址被修改，用户线程则无法正确使用该对象。整理算法更适合 “Stop The World” 的场景下使用。</p>
<p>当然也可通过设置参数设置几次GC之后进行碎片整理。</p>
</blockquote>
<br>

<h3 id="G1-收集器"><a href="#G1-收集器" class="headerlink" title="G1 收集器"></a>G1 收集器</h3><p><strong>G1 (Garbage-First) 是一款面向服务端应用的垃圾收集器，主要针对配备多核CPU及大容量内存的机器，以极高概率满足 GC 停顿时间要求的同时，还兼具高吞吐量的性能特征</strong>。被视为 JDK1.7 中 HotSpot 虚拟机的一个重要进化特征，在 JDK 9 时正式取代 Parallel Scavenge + Parallel Old 组合成为默认垃圾收集器。</p>
<p>G1出现之前的垃圾收集器，包括CMS在内，垃圾收集的目标范围要么是整个新生代（Minor GC），要么就是整个老年代（Major GC），再要么就是整个 Java 堆（Full GC）。而 G1 跳出了这个框架，它可以面向堆内存的任何部分来组成<strong>回收集(Collection Set，CSet)<strong>，</strong>衡量标准不再是它属于哪个分代，而是哪块内存中存放的垃圾数量最多</strong>，回收收益最大，这就是 G1 收集器的 <strong>Mixed GC</strong> 模式。</p>
<p><img src="https://gitee.com/KIMTOU/img/raw/master/20211024194419.PNG"></p>
<p>G1 是基于 Region 的堆内存布局来进行回收的，G1不再坚持固定大小以及固定数量的分代区域划分，<strong>而是把连续的 Java 堆划分为多个大小相等的独立区域 Region，每一个 Region 都可以根据需要，扮演新生代的 Eden 空间、Survivor 空间或者老年代空间</strong>，收集器能够对不同角色的 Region 采用不同的策略去处理。</p>
<p><strong>Region 中还有一类特殊的 Humongous 区域，专门用来存储大对象</strong>。G1 认为只要大小超过了一个 Region 容量一半的对象即可判定为大对象。对于超过了整个 Region 容量的超级大对象，将会存放在 N 个连续的 Humongous Region 中，G1 大多数行为都会把 Humongous Region 作为老年代的一部分来看待。</p>
<h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul>
<li><strong>并行与并发</strong>：<ul>
<li>并行性：G1 能充分利用 CPU、多核环境下的硬件优势，使用多个GC线程同时工作来缩短用户线程 STW 停顿时间。</li>
<li>并发性：部分其他收集器原本需要停顿 Java 线程执行的 GC 动作，G1 收集器仍然可以通过并发的方式让 Java 程序继续执行。</li>
</ul>
</li>
<li><strong>分代收集</strong>：虽然 G1 可以不需要其他收集器配合就能独立管理整个 GC 堆，但是还是保留了分代的概念。它会区分新生代和老年代，新生代依旧有Eden去、Survivor区，但从堆结构上看，它不要求整个Eden区、新生代或老年代都是连续的，也不再坚持固定大小和固定数量。</li>
<li><strong>空间整合</strong>：与 CMS 的“标记-清理”算法不同，G1 从整体来看是基于“标记-整理”算法实现的收集器；从局部上来看是基于“标记-复制”算法实现的，即内存回收是以Region为基本单位，Region之间使用复制算法。这两种算法都能避免内存碎片。</li>
<li><strong>可预测的停顿</strong>：这是 G1 相对于 CMS 的另一个大优势，降低停顿时间是 G1 和 CMS 共同的关注点，但 G1 除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为 M 毫秒的时间片段内，消耗在 GC 上的时间不得超过 N 毫秒。</li>
</ul>
<blockquote>
<p>G1收集器之所以能建立可预测的停顿时间模型，是因为它可以有计划地避免在整个Java堆中进行全区域的垃圾收集。<strong>G1跟踪各个Region里面的垃圾堆积的价值大小</strong>（价值即回收所获得的空间大小以及回收所需时间的经验值），<strong>在后台维护一个优先级列表</strong>，每次根据允许的收集停顿时间（使用参数 -XX:MaxGCPauseMillis 指定，默认值200毫秒），<strong>优先处理回收价值最大的那些Region</strong>。这种<strong>使用Region划分内存空间以及具有优先级的区域回收方式</strong>，保证了G1收集器在有限的时间内获取尽可能高的收集效率。</p>
</blockquote>
<p><strong>优点（与CMS相比）：</strong></p>
<ul>
<li><p>不会产生内存空间碎片（有利于程序长时间运行）</p>
</li>
<li><p>可以指定最大停顿时间</p>
</li>
<li><p>分 Region 的内存布局</p>
</li>
<li><p>按收益动态确定回收集</p>
</li>
</ul>
<p><strong>缺点（与CMS相比）：</strong></p>
<ul>
<li>占用额外的内存空间（每个Region都维护一份卡表）</li>
<li>额外执行负载高（G1与CMS都使用写前屏障更新维护卡表，但G1使用的原始快照需要使用写前屏障来跟踪并发时指针变化情况，负担增大）</li>
</ul>
<h4 id="运行过程"><a href="#运行过程" class="headerlink" title="运行过程"></a>运行过程</h4><p>G1收集器的运作过程大致可划分为以下四个步骤：</p>
<ul>
<li><strong>初始标记：仅仅只是标记一下 GC Roots 能直接关联到的对象，并修改 TAMS 指针的值</strong>，让下一阶段用户线程并发运行时，能够在可用的 Region 中分配对象。这个阶段需要暂停用户线程，但是时间很短。而且这个停顿是借用 Minor GC 的时候同步完成的，所以在这个阶段实际没有额外的停顿。</li>
<li><strong>并发标记：从 GC Root 开始对堆中对象进行可达性分析，递归扫描整个堆里的对象图，找出要回收的对象</strong>。当对象图扫描完成后，还要重新处理 SATB 记录下的在并发时有引用变动的对象。</li>
<li><strong>最终标记：对用户线程做另一个短暂的暂停，用于处理并发阶段结束后仍遗留下来的最后那少量的 SATB 记录</strong>（原始快照，用来记录并发标记中某些对象）。</li>
<li><strong>筛选回收：负责更新 Region 的统计数据，对各个 Region 的回收价值和成本进行排序，根据用户所期望的停顿时间来制定回收计划</strong>，可以自由选择任意多个 Region 构成回收集，然后<strong>把决定要回收的那一部分 Region 的存活对象复制到空的 Region 中，再清理掉整个旧 Region 的全部空间</strong>。这里的操作涉及存活对象的移动，所以必须要暂停用户线程，由多条收集器线程并行完成。</li>
</ul>
<p><img src="https://gitee.com/KIMTOU/img/raw/master/20211024194422.jpg"></p>
<h4 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h4><p><strong>1、将Java堆分成多个独立Region后，Region里面存在的跨Region引用对象怎么解决？</strong></p>
<p>出现该情况可能是老年代Region引用新生代Region等，为了避免进行Minor GC回收新生代时还要扫描老年代对象，解决方案是<strong>使用记忆集避免全堆作为GC Roots扫描</strong>。</p>
<p><strong>每个Region都有一个对应的记忆集，每次Reference类型数据写操作时，都会产生一个写屏障暂时中断操作</strong>；然后检查将要写入的引用指向的对象是否和该Reference类型数据在不同的Region（其他收集器：检查老年代对象是否引用了新生代对象）；如果不同，通过卡表把相关引用信息记录到引用指向对象的所在Region对应的记忆集中；</p>
<p>当进行垃圾收集时，在GC根节点的枚举范围加入记忆集；就可以保证不进行全局扫描，也不会有遗漏。</p>
<p><img src="https://gitee.com/KIMTOU/img/raw/master/20211024194424.png"></p>
<p><strong>2、G1 使用原始快照（SATB）算法来保证收集线程与于户线程互不干扰地运行，即用户线程改变对象引用关系时，必须保证其不能打破原本的对象图结构</strong>。</p>
<p>3、垃圾收集对用户线程的影响还体现在回收过程中新创建对象的内存分配上，程序要继续运行就肯定会持续有新对象被创建，<strong>G1为每个Region设计了两个名为TAMS（Top at Mark Start） 的指针，把Region中的一部分空间划分出来用于并发过程中的新对象分配</strong>，并发回收时新分配的对象地址都必须要在这两个指针位置以上。<br>G1会默认这个地址上的对象是存活的，如果内存回收跟不上内存分配的速度，那么G1收集器也会被迫冻结用户的线程，导致Full GC而产生长时间 Stop The World</p>
<br>

<blockquote>
<p>参考资料</p>
</blockquote>
<p><strong>《深入理解Java虚拟机  第3版》——周志明</strong></p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解Java虚拟机——类加载机制</title>
    <url>/2021/10/24/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E2%80%94%E2%80%94%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h2 id="类加载机制"><a href="#类加载机制" class="headerlink" title="类加载机制"></a>类加载机制</h2><h4 id="类的生命周期"><a href="#类的生命周期" class="headerlink" title="类的生命周期"></a>类的生命周期</h4><p>一个类型从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期将会经历<strong>加载（Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、初始化（Initialization）</strong>、使用（Using）和卸载（Unloading）七个阶段，<strong>其中验证、准备、解析三个部分统称为连接（Linking）</strong>。</p>
<p><img src="https://gitee.com/KIMTOU/img/raw/master/20211024203855.png"></p>
<h4 id="类的加载过程"><a href="#类的加载过程" class="headerlink" title="类的加载过程"></a>类的加载过程</h4><p><img src="https://gitee.com/KIMTOU/img/raw/master/20211024203859.png"></p>
<h5 id="1、加载"><a href="#1、加载" class="headerlink" title="1、加载"></a>1、加载</h5><p>类加载过程的第一步，Java虚拟机需要完成以下三件事情：</p>
<ol>
<li><strong>通过一个类的全限定名来获取定义此类的二进制字节流。</strong></li>
<li><strong>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。</strong></li>
<li><strong>在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。</strong></li>
</ol>
<h5 id="2、验证"><a href="#2、验证" class="headerlink" title="2、验证"></a>2、验证</h5><p><strong>确保 Class 文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。</strong></p>
<p>主要包括四种验证：文件格式验证、元数据验证、字节码验证、符号引用验证</p>
<h5 id="3、准备"><a href="#3、准备" class="headerlink" title="3、准备"></a>3、准备</h5><p><strong>准备阶段是正式为类变量分配内存并设置类变量初始值（零值）的阶段，这些变量所使用的内存都应当在方法区中进行分配</strong>。</p>
<ol>
<li><p>这时候进行内存分配的仅包括类变量（ 即静态变量，被 <code>static</code> 关键字修饰的变量），而不包括实例变量。实例变量会在对象实例化时随着对象一块分配在 Java 堆中。</p>
</li>
<li><p>从概念上讲，类变量所使用的内存都应当在 <strong>方法区</strong> 中进行分配。不过有一点需要注意的是：JDK 7 之前，HotSpot 使用永久代来实现方法区的时候，实现是完全符合这种逻辑概念的。 而在 JDK 7 及之后，HotSpot 已经把原本放在永久代的字符串常量池、静态变量等移动到堆中，这个时候类变量则会随着 Class 对象一起存放在 Java 堆中。</p>
</li>
<li><p>这里所设置的初始值”通常情况”下是数据类型默认的零值（如0、0.0、0L、null、false等），比如我们定义了<code>public static int value = 123</code> ，那么 value 变量在准备阶段的初始值就是 0 而不是123（初始化阶段才会赋值）。</p>
</li>
<li><p>这里不包含用final修饰的static，因为final在编译的时候就会分配了，准备阶段会显示初始化：比如给 value 变量加上了 final 关键字<code>public static final int value = 123</code>使其成为常量 ，那么准备阶段 value 的值就被赋值为 123。</p>
</li>
</ol>
<p><img src="https://gitee.com/KIMTOU/img/raw/master/20211024203906.png"></p>
<h5 id="4、解析"><a href="#4、解析" class="headerlink" title="4、解析"></a>4、解析</h5><p><strong>解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程</strong>。解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用限定符7类符号引用进行。</p>
<h5 id="5、初始化"><a href="#5、初始化" class="headerlink" title="5、初始化"></a>5、初始化</h5><p>类的初始化阶段是类加载的最后一个步骤，此时 Java 虚拟机才真正开始执行类中编写的 Java 程序代码。</p>
<p><strong>初始化阶段就是执行类构造器<code>&lt;clinit&gt;()</code>方法的过程。</strong><code>&lt;clinit&gt; ()</code>方法是编译之后自动生成的。</p>
<ul>
<li><code>&lt;clinit&gt;()</code>方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块（static{ }块）中的语句合并产生的，编译器收集的顺序是由语句在源文件中出现的顺序决定的，即构造器方法中指令按语句在源文件中出现的顺序执行。</li>
<li><code>&lt;clinit&gt;()</code>方法与类的构造函数（即在虚拟机视角中的实例构造器<code>&lt;init&gt;()</code>方法）不同，它不需要显示地调用父类构造器，Java虚拟机会保证在子类的<code>&lt;clinit&gt;()</code>方法执行前，父类的<code>&lt;clinit&gt;()</code>方法已经执行完毕。</li>
<li>对于<code>&lt;clinit&gt;()</code> 方法的调用，虚拟机会自己确保其在多线程环境中的安全性。因为 <code>&lt;clinit&gt;()</code> 方法是带锁线程安全，所以在多线程环境下进行类初始化的话可能会引起死锁，并且这种死锁很难被发现。</li>
</ul>
<h4 id="类的初始化时机"><a href="#类的初始化时机" class="headerlink" title="类的初始化时机"></a>类的初始化时机</h4><p>对于初始化阶段，虚拟机严格规范了有且只有5种情况下，必须对类进行初始化(只有主动去使用类才会初始化类)：</p>
<ol>
<li>当遇到 <code>new</code> 、<code>getstatic</code>、<code>putstatic</code> 或 <code>invokestatic</code> 这4条直接码指令时，比如 new 一个类，读取一个静态字段(未被 final 修饰)、或调用一个类的静态方法时。<ul>
<li>当 jvm 执行 <code>new</code> 指令时会初始化类。即当程序创建一个类的实例对象。</li>
<li>当 jvm 执行 <code>getstatic</code> 指令时会初始化类。即程序访问类的静态变量(不是静态常量，常量会被加载到运行时常量池)。</li>
<li>当 jvm 执行 <code>putstatic</code> 指令时会初始化类。即程序给类的静态变量赋值。</li>
<li>当 jvm 执行 <code>invokestatic</code> 指令时会初始化类。即程序调用类的静态方法。</li>
</ul>
</li>
<li>使用 <code>java.lang.reflect</code> 包的方法对类进行反射调用时如 <code>Class.forName(&quot;...&quot;)</code>, <code>newInstance()</code> 等等。如果类没初始化，需要触发其初始化。</li>
<li>初始化一个类，如果其父类还未初始化，则先触发该父类的初始化。</li>
<li>当虚拟机启动时，用户需要定义一个要执行的主类 (包含 <code>main</code> 方法的那个类)，虚拟机会先初始化这个类。</li>
<li><code>MethodHandle</code> 和 <code>VarHandle</code> 可以看作是轻量级的反射调用机制，而要想使用这 2 个调用， 就必须先使用 <code>findStaticVarHandle</code> 来初始化要调用的类。</li>
<li>当一个接口中定义了JDK8新加入的默认方法（被default关键字修饰的接口方法）时，如果有这个接口的实现类发生了初始化，那该接口要在其之前被初始化。</li>
</ol>
<br>

<h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><h4 id="类与类加载器"><a href="#类与类加载器" class="headerlink" title="类与类加载器"></a>类与类加载器</h4><p><strong>比较两个类是否 “相等” ，首先需要这两个类来源于同一个Class文件，并且使用同一个类加载器进行加载</strong>。这是因为每一个类加载器都拥有一个独立的类名称空间。</p>
<p>这里的 “相等” ，包括类的 Class 对象的 equals() 方法、isAssignableFrom() 方法、isInstance() 方法的返回结果为 true，也包括使用 instanceof 关键字做对象所属关系判定结果为 true。</p>
<br>

<h4 id="类加载器分类"><a href="#类加载器分类" class="headerlink" title="类加载器分类"></a>类加载器分类</h4><p>从 Java 虚拟机的角度来讲，只存在以下两种不同的类加载器：</p>
<ul>
<li>启动类加载器（Bootstrap ClassLoader），使用 C++ 实现，是虚拟机自身的一部分；</li>
<li>其它所有的类加载器，使用 Java 实现，独立存在于虚拟机外部，全都继承自抽象类 java.lang.ClassLoader。</li>
</ul>
<p>从 Java 开发人员的角度看，类加载器可以划分得更细致一些：</p>
<ul>
<li><strong>启动类加载器（Bootstrap ClassLoader）</strong>：此类加载器负责加载 <code>%JAVA_HOME%/lib</code>目录下的 jar 包和类或者被 <code>-Xbootclasspath</code>参数指定的路径中的所有类。（String等核心类库）</li>
<li><strong>扩展类加载器（Extension ClassLoader）</strong>：主要负责加载 <code>%JRE_HOME%/lib/ext</code> 目录下的 jar 包和类，或被 <code>java.ext.dirs</code> 系统变量所指定的路径下的 jar 包。</li>
<li><strong>应用程序类加载器（Application ClassLoader）</strong>：<strong>由于这个类加载器是 ClassLoader 中的 getSystemClassLoader() 方法的返回值，因此一般称为系统类加载器。它负责加载用户类路径（ClassPath）上所指定的类库</strong>。如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。</li>
</ul>
<blockquote>
<p>如果想要自定义加载器，需要继承 <code>java.lang.ClassLoader</code>类，且为了满足双亲委派机制，需要指定父加载器为拓展类加载器</p>
</blockquote>
<br>

<h2 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h2><p>下图展示了各种类加载器之间的层次关系，称为双亲委派模型（Parents Delegation Model）。<strong>该模型要求除了顶层的启动类加载器外，其它的类加载器都要有自己的父类加载器。不过这里类加载器之间的父子关系一般不是以继承关系（Inheritance）来实现的，而是通常使用组合关系（Composition）来复用父加载器的代码</strong>。</p>
<p><img src="https://gitee.com/KIMTOU/img/raw/master/20211024203910.png"></p>
<h4 id="工作过程"><a href="#工作过程" class="headerlink" title="工作过程"></a>工作过程</h4><p>每一个类都有一个对应它的类加载器。系统中的 ClassLoader 在协同工作的时候会默认使用 <strong>双亲委派模型</strong> 。即在类加载的时候，系统会首先判断当前类是否被加载过。已经被加载的类会直接返回，否则才会尝试加载。加载的时候，<strong>首先会把该请求委派给父类加载器的 <code>loadClass()</code> 处理</strong>，因此所有的加载请求最终都应该传送到最顶层的启动类加载器 <code>BootstrapClassLoader</code> 中。<strong>当父类加载器无法处理这个加载请求时，子加载才会尝试自己去完成加载</strong>。当父类加载器为 null 时，会使用启动类加载器 <code>BootstrapClassLoader</code> 作为父类加载器。</p>
<blockquote>
<p>当一个 .class 文件要被加载时，不考虑我们自定义类加载器类，首先会在AppClassLoader中检查是否加载过，如果有那就无需再加载；如果没有会交到父加载器，然后调用父加载器的loadClass方法。父加载器同样也会先检查自己是否已经加载过，如果没有再往上，直到到达BootstrapClassLoader之前，都是在检查是否加载过，并不会选择自己去加载。到了根加载器时，才会开始检查是否能够加载当前类，能加载就结束，使用当前的加载器；否则就通知子加载器进行加载；子加载器重复该步骤。如果到最底层还不能加载，就抛出异常<code>ClassNotFoundException</code></p>
</blockquote>
<p><strong>总结：所有的加载请求都会传送到根加载器去加载，只有当父加载器无法加载时，子类加载器才会去加载</strong></p>
<br>

<h4 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h4><p>核心方法为 java.lang.ClassLoader 的 loadClass() </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve)</span><br><span class="line">    <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">        <span class="comment">// 首先，检查请求的类是否已经被加载过了</span></span><br><span class="line">        Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">long</span> t0 = System.nanoTime();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;	<span class="comment">// 父加载器不为空，调用父加载器loadClass()方法处理</span></span><br><span class="line">                    c = parent.loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;	<span class="comment">// 父加载器为空，使用启动类加载器 BootstrapClassLoader 加载</span></span><br><span class="line">                    c = findBootstrapClassOrNull(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                <span class="comment">// 如果父类加载器抛出ClassNotFoundException，说明父类加载器无法完成加载请求</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">long</span> t1 = System.nanoTime();</span><br><span class="line">                <span class="comment">// 在父类加载器无法加载时，再调用本身的findClass方法来进行类加载</span></span><br><span class="line">                c = findClass(name);</span><br><span class="line"></span><br><span class="line">                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">            resolveClass(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<h4 id="双亲委派机制的好处"><a href="#双亲委派机制的好处" class="headerlink" title="双亲委派机制的好处"></a>双亲委派机制的好处</h4><p>双亲委派模型<strong>保证了 Java 程序的稳定运行，可以避免类的重复加载</strong>（JVM 区分不同类的方式不仅仅根据类名，相同的类文件被不同的类加载器加载产生的是两个不同的类），<strong>也保证了 Java 的核心 API 不被篡改</strong>（沙箱安全机制）。如果没有使用双亲委派模型，而是每个类加载器加载自己的话就会出现一些问题，比如我们编写一个称为 <code>java.lang.Object</code> 类的话，那么程序运行的时候，系统就会出现多个不同的 <code>Object</code> 类。</p>
<ul>
<li>避免类的重复加载</li>
<li>保证Java核心类库的安全</li>
</ul>
<br>

<blockquote>
<p>参考资料</p>
</blockquote>
<p><strong>《深入理解Java虚拟机  第3版》——周志明</strong></p>
<p><a href="https://github.com/Snailclimb/JavaGuide/tree/master/docs/java/jvm">https://github.com/Snailclimb/JavaGuide</a></p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>二分查找算法——Java实现</title>
    <url>/2021/11/10/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94Java%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h4 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h4><p>使用二分查找的场景：数组有序</p>
<ul>
<li>非递归版</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>; <span class="comment">//防止溢出 </span></span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>递归版</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binSearch</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>; <span class="comment">//防止溢出 </span></span><br><span class="line">    <span class="keyword">if</span> (left &gt; right) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">        <span class="keyword">return</span> mid;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">        <span class="keyword">return</span> binSearch(nums, target, left, mid - <span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> binSearch(nums, target, mid + <span class="number">1</span>, right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>源码分析Arrays.sort中使用的排序算法</title>
    <url>/2021/11/10/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90Arrays-sort%E4%B8%AD%E4%BD%BF%E7%94%A8%E7%9A%84%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>Java 主要排序方法为 <code>java.util.Arrays.sort()</code>，粗略的来讲，<strong>对于基本数据类型使用双轴快排，对于引用类型使用归并排序</strong>。接下来我们深入 <code>Arrays.sort </code> 的源码，更具体的分析其中所使用的排序算法。</p>
<h4 id="Arrays-sort底层"><a href="#Arrays-sort底层" class="headerlink" title="Arrays.sort底层"></a>Arrays.sort底层</h4><p>一开始会判断数组是否是小数组（元素个数小于286），是则使用<strong>快速排序</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> left, <span class="keyword">int</span> right,</span></span></span><br><span class="line"><span class="function"><span class="params">                 <span class="keyword">int</span>[] work, <span class="keyword">int</span> workBase, <span class="keyword">int</span> workLen)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Use Quicksort on small arrays 对小数组使用快速排序</span></span><br><span class="line">    <span class="keyword">if</span> (right - left &lt; QUICKSORT_THRESHOLD) &#123;</span><br><span class="line">        sort(a, left, right, <span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>但其实也并不是直接就开始使用快速排序，点进 <code>sort(a, left, right, true)</code> 看，会发现元素个数小于47的极小数组，会使用<strong>插入排序</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">boolean</span> leftmost)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> length = right - left + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// Use insertion sort on tiny arrays 对极小数组使用插入排</span></span><br><span class="line">    <span class="keyword">if</span> (length &lt; INSERTION_SORT_THRESHOLD) &#123;</span><br><span class="line">        <span class="keyword">if</span> (leftmost) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = left, j = i; i &lt; right; j = ++i) &#123;</span><br><span class="line">                <span class="keyword">int</span> ai = a[i + <span class="number">1</span>];</span><br><span class="line">                <span class="keyword">while</span> (ai &lt; a[j]) &#123;</span><br><span class="line">                    a[j + <span class="number">1</span>] = a[j];</span><br><span class="line">                    <span class="keyword">if</span> (j-- == left) &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                a[j + <span class="number">1</span>] = ai;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>

<p>如果元素个数小于286，同时又大于47，则使用<strong>双轴快排</strong>。</p>
<p><strong>双轴快排的基本思想是</strong>：</p>
<ol>
<li>从数组中选取 5 个均匀间隔的元素，并将这 5 个元素进行插入排序。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Sort five evenly spaced elements around (and including) the</span></span><br><span class="line"><span class="comment"> * center element in the range. These elements will be used for</span></span><br><span class="line"><span class="comment"> * pivot selection as described below. The choice for spacing</span></span><br><span class="line"><span class="comment"> * these elements was empirically determined to work well on</span></span><br><span class="line"><span class="comment"> * a wide variety of inputs.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">int</span> e3 = (left + right) &gt;&gt;&gt; <span class="number">1</span>; <span class="comment">// The midpoint</span></span><br><span class="line"><span class="keyword">int</span> e2 = e3 - seventh;</span><br><span class="line"><span class="keyword">int</span> e1 = e2 - seventh;</span><br><span class="line"><span class="keyword">int</span> e4 = e3 + seventh;</span><br><span class="line"><span class="keyword">int</span> e5 = e4 + seventh;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>使用五个排序元素中的第二个和第四个作为枢轴，且 pivot1 &lt;= pivot2。</p>
</li>
<li><p>定义两个指针 <code>less</code> 与 <code>great</code> ，<code>less</code> 从数组最左端向右遍历，直到找到第一个不小于枢纽1的元素，<code>great</code> 从数组最右端向左遍历，直到找到第一个不大于枢纽2的元素。</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 指针</span></span><br><span class="line"><span class="keyword">int</span> less  = left;  <span class="comment">// The index of the first element of center part</span></span><br><span class="line"><span class="keyword">int</span> great = right; <span class="comment">// The index before the first element of right part</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//......</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (a[++less] &lt; pivot1);</span><br><span class="line"><span class="keyword">while</span> (a[--great] &gt; pivot2);</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>此时再将 <code>less</code> 与 <code>great</code> 中间的元素进行移动，将小于枢纽1的元素移至枢纽1左边，将大于枢纽2的元素移至枢纽2右边，最后位于两个枢纽之间的元素就是 <code> pivot1 &lt;= &amp;&amp; &lt;= pivot2</code> 的元素了。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Partitioning:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   left part           center part                   right part</span></span><br><span class="line"><span class="comment"> * +--------------------------------------------------------------+</span></span><br><span class="line"><span class="comment"> * |  &lt; pivot1  |  pivot1 &lt;= &amp;&amp; &lt;= pivot2  |    ?    |  &gt; pivot2  |</span></span><br><span class="line"><span class="comment"> * +--------------------------------------------------------------+</span></span><br><span class="line"><span class="comment"> *               ^                          ^       ^</span></span><br><span class="line"><span class="comment"> *               |                          |       |</span></span><br><span class="line"><span class="comment"> *              less                        k     great</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Invariants:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *              all in (left, less)   &lt; pivot1</span></span><br><span class="line"><span class="comment"> *    pivot1 &lt;= all in [less, k)     &lt;= pivot2</span></span><br><span class="line"><span class="comment"> *              all in (great, right) &gt; pivot2</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Pointer k is the first index of ?-part.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">outer:</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = less - <span class="number">1</span>; ++k &lt;= great; ) &#123;</span><br><span class="line">    <span class="keyword">int</span> ak = a[k];</span><br><span class="line">    <span class="keyword">if</span> (ak &lt; pivot1) &#123; <span class="comment">// Move a[k] to left part</span></span><br><span class="line">        a[k] = a[less];</span><br><span class="line">        a[less] = ak;</span><br><span class="line">        ++less;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ak &gt; pivot2) &#123; <span class="comment">// Move a[k] to right part</span></span><br><span class="line">        <span class="keyword">while</span> (a[great] &gt; pivot2) &#123;</span><br><span class="line">            <span class="keyword">if</span> (great-- == k) &#123;</span><br><span class="line">                <span class="keyword">break</span> outer;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (a[great] &lt; pivot1) &#123; <span class="comment">// a[great] &lt;= pivot2</span></span><br><span class="line">            a[k] = a[less];</span><br><span class="line">            a[less] = a[great];</span><br><span class="line">            ++less;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// pivot1 &lt;= a[great] &lt;= pivot2</span></span><br><span class="line">            a[k] = a[great];</span><br><span class="line">        &#125;</span><br><span class="line">        a[great] = ak;</span><br><span class="line">        --great;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Swap pivots into their final positions</span></span><br><span class="line">a[left]  = a[less  - <span class="number">1</span>]; a[less  - <span class="number">1</span>] = pivot1;</span><br><span class="line">a[right] = a[great + <span class="number">1</span>]; a[great + <span class="number">1</span>] = pivot2;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>再对枢纽左中右三部分进行递归快排（中间部分右特殊处理）。同样的，如果这些部分的数组长度小于47，又会改为插入排序。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Sort left and right parts recursively, excluding known pivots</span></span><br><span class="line">sort(a, left, less - <span class="number">2</span>, leftmost);</span><br><span class="line">sort(a, great + <span class="number">2</span>, right, <span class="keyword">false</span>);</span><br></pre></td></tr></table></figure>

<p>我们再回到第一个分支，即判断数组元素个数是否小于286，如果小于，则使用快速排序；若大于等于286，则使用<strong>归并排序</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 检查数组是否接近有序</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = left; k &lt; right; run[count] = k) &#123;</span><br><span class="line">    <span class="keyword">if</span> (a[k] &lt; a[k + <span class="number">1</span>]) &#123; <span class="comment">// ascending</span></span><br><span class="line">        <span class="keyword">while</span> (++k &lt;= right &amp;&amp; a[k - <span class="number">1</span>] &lt;= a[k]);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a[k] &gt; a[k + <span class="number">1</span>]) &#123; <span class="comment">// descending</span></span><br><span class="line">        <span class="keyword">while</span> (++k &lt;= right &amp;&amp; a[k - <span class="number">1</span>] &gt;= a[k]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> lo = run[count] - <span class="number">1</span>, hi = k; ++lo &lt; --hi; ) &#123;</span><br><span class="line">            <span class="keyword">int</span> t = a[lo]; a[lo] = a[hi]; a[hi] = t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// equal</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> m = MAX_RUN_LENGTH; ++k &lt;= right &amp;&amp; a[k - <span class="number">1</span>] == a[k]; ) &#123;</span><br><span class="line">            <span class="keyword">if</span> (--m == <span class="number">0</span>) &#123;</span><br><span class="line">                sort(a, left, right, <span class="keyword">true</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 降序组太多，数组被认为没有结构，使用快速排序代替归并排序</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (++count == MAX_RUN_COUNT) &#123;</span><br><span class="line">        sort(a, left, right, <span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后再进行合并操作。</p>
<hr>
<p>需要注意的是，以上的Arrays.sort是针对基本数据类型进行的排序，<strong>若是对Object类进行排序，则是使用归并排序，而不是用快速排序</strong>。</p>
<blockquote>
<p>1.如果数组元素个数小于MIN_MERGE(32)，那么就会调用二分插入排序binarySort方法进行排序，所谓二分排序，是指在插入的过程中，使用二分查找的方法查找待插入的位置，这种查找方法会比线性查找快一点。</p>
<p>2.如果大于MIN_MERGE，则将数组划分成多个有序块进行归并排序。</p>
</blockquote>
<p>为什么使用归并排序，而不是用快速排序？应当从稳定性的角度出发：</p>
<p><strong>快速排序不是稳定的，而归并排序是稳定的</strong>。</p>
<blockquote>
<p>对于基本数据类型，稳定性没有意义，而对于对象类型，稳定性是比较重要的，因为对象相等的判断可能只是判断关键属性，最好保持相等对象的非关键属性的顺序与排序前一直；另外一个原因是由于合并排序相对而言比较次数比快速排序少，移动（对象引用的移动）次数比快速排序多，而对于对象来说，比较一般比移动耗时。</p>
</blockquote>
<hr>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ol>
<li><p><strong>数组元素个数小于47，使用插入排序；数组元素个数大于等于47，小于286，使用快速排序；数组元素个数大于等于286，使用归并排序，当然，若数组降序组太多，又会使用快速排序（快排数据越无序越快）；</strong></p>
</li>
<li><p><strong>对于小数组来说，插入排序效率更高，每次递归到小于47的大小时，用插入排序代替快排，明显提升了性能。</strong></p>
</li>
<li><p><strong>双轴快排使用两个pivot，每轮把数组分成3段，在没有明显增加比较次数的情况下巧妙地减少了递归次数。</strong></p>
</li>
</ol>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>十大排序算法——Java实现</title>
    <url>/2021/11/10/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94Java%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<p><img src="https://gitee.com/KIMTOU/img/raw/master/20211110232247.png" alt="sort"></p>
<h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>从要排序序列的第一个元素开始，不断比较相邻元素的值，发现逆序则交换，将值较大的元素逐渐从前向后移动。</p>
<p>每找到待排序序列的最大值时，就将该最大值固定在待排序序列的尾部，且每找到一个待排序序列最大值需要循环一次，n 个值则需要循环 n 次，但最后一个值无需比较，则实际需循环 n-1 次，即 <code>i &lt; arr.length - 1</code> 。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bubbleSort</span> <span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; arr.length - i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">int</span> temp = arr[j];</span><br><span class="line">                arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">                arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然，该方法还可以进行优化。</p>
<p>定义一个布尔变量 <code>flag</code>，用来标记每轮是否进行了交换。在每轮遍历开始时，将 <code>flag</code> 设置为 false。若当轮没有发生交换，即此时 <code>flag</code> 依然为 false，说明此时数组已经按照升序排列。此时外层循环直接退出，排序结束。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bubbleSort</span> <span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        flag = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; arr.length - i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">int</span> temp = arr[j];</span><br><span class="line">                arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">                arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">                flag = <span class="keyword">true</span>; <span class="comment">//该轮发生交换</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">            <span class="keyword">break</span>; <span class="comment">//数组已有序</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong>：</p>
<ul>
<li>时间复杂度 O(n^2)</li>
<li>空间复杂度 O(1)</li>
<li>稳定</li>
</ul>
<h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p>选择排序每次会从未排序区间中找到最小的元素，将其放到已排序区间的末尾。同样，选择排序也需要比较 <code>n - 1</code>轮，最后一轮无需比较。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">selectSort</span> <span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> minIndex = i; <span class="comment">//初始化最小值索引</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &lt; arr[minIndex]) &#123;</span><br><span class="line">                minIndex = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (minIndex != i) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">            arr[i] = arr[minIndex];</span><br><span class="line">            arr[minIndex] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong>：</p>
<ul>
<li>时间复杂度 O(n^2)</li>
<li>空间复杂度 O(1)</li>
<li>不稳定</li>
</ul>
<h2 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h2><p>把 n 个待排序的元素看成为一个<code>有序表</code>和一个<code>无序表</code>，开始时 有序表 中只包含一个元素，无序表中包含有 n-1 个元素，排序过程中每次从无序表中取出第一个元素，与有序表中的元素进行比较，将它插入到有序表中的适当位置，使之成为新的有序表。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertSort</span> <span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> temp = arr[i]; <span class="comment">//记录待排序的数值</span></span><br><span class="line">        <span class="keyword">int</span> j = i;</span><br><span class="line">        <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; arr[j - <span class="number">1</span>] &gt; temp) &#123;</span><br><span class="line">            arr[j] = arr[j - <span class="number">1</span>];</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (j != i) &#123;</span><br><span class="line">            arr[j] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong>：</p>
<ul>
<li>时间复杂度 O(n^2)</li>
<li>空间复杂度 O(1)</li>
<li>稳定</li>
</ul>
<h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><p>希尔排序，也被称为递减增量排序，是直接插入排序的一种改进版本。简单插入排序可能存在的问题：当需要插入的数是较小的数时，后移的次数明显增多，对效率有影响。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shellSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> length = arr.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> step = length / <span class="number">2</span>; step &gt;= <span class="number">1</span>; step /= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = step; i &lt; length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">            <span class="keyword">int</span> j = i - step;</span><br><span class="line">            <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; arr[j] &gt; temp) &#123;</span><br><span class="line">                arr[j + step] = arr[j];</span><br><span class="line">                j -= step;</span><br><span class="line">            &#125;</span><br><span class="line">            arr[j + step] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong>：</p>
<ul>
<li>时间复杂度 O(nlogn)</li>
<li>空间复杂度 O(1)</li>
<li>不稳定</li>
</ul>
<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>归并排序的核心思想是分治法，把一个复杂问题拆分成若干个子问题来求解。</p>
<p>归并排序的算法思想是：把数组从中间划分为两个子数组，一直递归地把子数组划分成更小的数组。长度为 1 序列是有序的，因此应递归分解直到子数组里面只有一个元素的时候开始排序。排序的方法就是按照大小顺序合并两个元素。接着依次按照递归的顺序返回，不断合并排好序的数组，直到把整个数组排好序。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] source, <span class="keyword">int</span>[] temp, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left &gt;= right) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">    mergeSort(source, temp, left, mid);</span><br><span class="line">    mergeSort(source, temp, mid + <span class="number">1</span>, right);</span><br><span class="line">    <span class="keyword">int</span> i = left, j = mid + <span class="number">1</span>, k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">if</span> (source[i] &lt;= source[j]) &#123;</span><br><span class="line">            temp[k++] = source[i++];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            temp[k++] = source[j++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid) &#123;</span><br><span class="line">        temp[k++] = source[i++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (j &lt;= right) &#123;</span><br><span class="line">        temp[k++] = source[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = left, j = <span class="number">0</span>; i &lt;= right; i++, j++) &#123;</span><br><span class="line">        source[i] = temp[j];  <span class="comment">//复制回原数组</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] arr = &#123;<span class="number">12</span>, <span class="number">3</span>, <span class="number">15</span>, <span class="number">55</span>, <span class="number">97</span>, <span class="number">6</span>, <span class="number">11</span>, <span class="number">41</span>, <span class="number">88</span>, <span class="number">12</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span>[] temp = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length];</span><br><span class="line">    mergeSort(arr, temp, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        System.out.println(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong>：</p>
<ul>
<li>时间复杂度 O(nlogn)</li>
<li>空间复杂度 O(logn)</li>
<li>稳定</li>
</ul>
<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>快速排序也采用了分治的思想，如果说归并排序是先拆分再排序，那么快速排序就是先排序再划分。</p>
<p>快速排序的基本思想是：首先从待排序列中选定一个记录，称之为 <strong><code>枢纽</code></strong> ，通过关键字与枢纽的比较将待排序列的序列划分成位于枢纽前后的两个子序列，其中<strong>枢纽之前的子序列的所有关键字都不大于枢纽，枢纽之后的子序列的所有关键字都不小于枢纽</strong>；此时枢纽已到位，再按同样方法对这两个子序列分别递归进行快速排序，最终使得整个序列有序。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left &gt;= right) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> pivot = arr[left];</span><br><span class="line">    <span class="keyword">int</span> i = left, j = right;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j &amp;&amp; arr[j] &gt;= pivot)</span><br><span class="line">            j--;</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j &amp;&amp; arr[i] &lt;= pivot)</span><br><span class="line">            i++;</span><br><span class="line">        arr[j] = arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    arr[i] = pivot;</span><br><span class="line">    quickSort(arr, left, i - <span class="number">1</span>);</span><br><span class="line">    quickSort(arr, j + <span class="number">1</span>, right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong>：</p>
<ul>
<li>时间复杂度 O(nlogn)</li>
<li>空间复杂度 O(n)</li>
<li>不稳定</li>
</ul>
<h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><p>堆排序是指利用堆这种数据结构所设计的一种排序算法。堆是一类完全二叉树，具有以下特性：</p>
<p><strong>大顶堆：每个结点的值都大于或等于其左右孩子结点的值</strong></p>
<p><strong>小顶堆：每个结点的值都小于或等于其左右孩子结点的值</strong></p>
<p><img src="D:\技术书籍与笔记图片\笔记图片\数据结构与算法\大小顶堆.png"></p>
<p><strong>堆排序基本步骤</strong>：</p>
<ol>
<li>将待排序数组构造成一个大顶堆，<strong>即从右至左、从下至上进行下沉操作</strong>。此时，整个序列的最大值就是堆顶的根节点。<strong>一般升序采用大顶堆，降序采用小顶堆</strong></li>
<li>将其与末尾元素进行交换，此时末尾就为最大值。</li>
<li>然后将剩余n-1个元素进行调整重新构造成一个堆。再将堆顶元素与末尾元素交换，如此反复执行，便能得到一个有序序列了。</li>
</ol>
<p>以数组首元素索引是0还是1区分，算法有以下两个版本：</p>
<ul>
<li>数组首元素索引是1</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//数组第 0 个位置不能有元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N = arr.length - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//构建大顶堆</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = N / <span class="number">2</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">        sink(arr, i, N);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (N &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        swap(arr, <span class="number">1</span>, N--);  <span class="comment">//堆顶与堆尾结点交换，堆长度减1</span></span><br><span class="line">        sink(arr, <span class="number">1</span>, N);  <span class="comment">//筛选新的堆顶结点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sink</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> pos, <span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (pos &lt;= N / <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">2</span> * pos;</span><br><span class="line">        <span class="keyword">if</span> (j &lt; N &amp;&amp; arr[j] &lt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">            j++;    <span class="comment">// j 为左、右孩子中优先者的位置</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (arr[j] &lt; arr[pos])&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(arr, pos, j);</span><br><span class="line">        pos = j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">    arr[i] = arr[j];</span><br><span class="line">    arr[j] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>数组首元素索引是0</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//数组第 0 个位置有元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N = arr.length;</span><br><span class="line">    <span class="comment">//构建大顶堆</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = N / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        sink(arr, i, N);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (N &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        swap(arr, <span class="number">0</span>, --N);  <span class="comment">//堆顶与堆尾结点交换，堆长度减1</span></span><br><span class="line">        sink(arr, <span class="number">0</span>, N);  <span class="comment">//筛选新的堆顶结点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//下沉</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sink</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> pos, <span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (pos &lt;= N / <span class="number">2</span> - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">2</span> * pos + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (j &lt; N - <span class="number">1</span> &amp;&amp; arr[j] &lt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">            j++;    <span class="comment">// j 为左、右孩子中优先者的位置</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (arr[j] &lt; arr[pos])&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(arr, pos, j);</span><br><span class="line">        pos = j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">    arr[i] = arr[j];</span><br><span class="line">    arr[j] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong>：</p>
<ul>
<li>时间复杂度 O(nlogn)</li>
<li>空间复杂度 O(1)</li>
<li>不稳定</li>
</ul>
<p>堆排序是一种原地排序，没有利用额外的空间。</p>
<blockquote>
<p>快速排序是最快的通用排序算法，它的内循环的指令很少，而且它还能利用缓存，因为它总是顺序地访问数据。现代操作系统很少使用堆排序，因为它无法利用局部性原理进行缓存，也就是数组元素很少和相邻的元素进行比较和交换。使用三向切分快速排序，实际应用中可能出现的某些分布的输入能够达到线性级别，而其它排序算法仍然需要线性对数时间。</p>
</blockquote>
<h2 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h2><blockquote>
<h5 id="比较和非比较的区别"><a href="#比较和非比较的区别" class="headerlink" title="比较和非比较的区别"></a>比较和非比较的区别</h5><p>常见的快速排序、归并排序、堆排序、冒泡排序等属于比较排序。在排序的最终结果里，元素之间的次序依赖于它们之间的比较。每个数都必须和其他数进行比较，才能确定自己的位置。<br>在<strong>冒泡排序</strong>之类的排序中，问题规模为n，又因为需要比较n次，所以平均时间复杂度为O(n²)。在<strong>归并排序、快速排序</strong>之类的排序中，问题规模通过分治法消减为logN次，所以时间复杂度平均**O(nlogn)**。<br>比较排序的优势是，适用于各种规模的数据，也不在乎数据的分布，都能进行排序。可以说，比较排序适用于一切需要排序的情况。</p>
<p>计数排序、基数排序、桶排序则属于非比较排序。非比较排序是通过确定每个元素之前，应该有多少个元素来排序。针对数组arr，计算arr[i]之前有多少个元素，则唯一确定了arr[i]在排序后数组中的位置。<br>非比较排序只要确定每个元素之前的已有的元素个数即可，所有一次遍历即可解决。算法时间复杂度**O(n)**。<br>非比较排序时间复杂度低，但由于非比较排序需要占用空间来确定唯一位置。所以对数据规模和数据分布有一定的要求。</p>
</blockquote>
<p>计数排序的核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。</p>
<p><strong>适用条件</strong>：计数排序需要占用大量空间，它仅适用于数据比较集中的情况，如[0,100]，高考学生成绩。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//当输入的元素是 n 个 0 到 k 之间的整数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">countSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> maxValue = arr[<span class="number">0</span>];</span><br><span class="line">    <span class="comment">//获取最大值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : arr) &#123;</span><br><span class="line">        <span class="keyword">if</span> (maxValue &lt; num) &#123;</span><br><span class="line">            maxValue = num;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span>[] bucket = <span class="keyword">new</span> <span class="keyword">int</span>[maxValue + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : arr) &#123;</span><br><span class="line">        bucket[num]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt;= maxValue; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (bucket[i]-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            arr[j++] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然，上面是最基本的计数排序，还可以有优化的地方。比如开辟的bucket数组的长度可以是最大值与最小值的差值+1，不一定要求数据必须从0开始。</p>
<p><strong>复杂度分析</strong>：</p>
<ul>
<li>时间复杂度 O(N+k)</li>
<li>空间复杂度 O(k)</li>
<li>稳定</li>
</ul>
<h2 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h2><blockquote>
<p>桶排序是计数排序的升级版。<strong>它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定</strong>。为了使桶排序更加高效，我们需要做到这两点：</p>
<ol>
<li>在额外空间充足的情况下，尽量增大桶的数量</li>
<li>使用的映射函数能够将输入的 N 个数据均匀的分配到 K 个桶中</li>
</ol>
<p>同时，对于桶中元素的排序，选择何种比较排序算法对于性能的影响至关重要。</p>
<p><strong>什么时候最快</strong>：</p>
<p><strong>当输入的数据可以均匀的分配到每一个桶中</strong>。</p>
<p><strong>什么时候最慢</strong>：</p>
<p>当输入的数据被分配到了同一个桶中。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bucketSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 计算最大值与最小值</span></span><br><span class="line">    <span class="keyword">int</span> max = arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> min = arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> num : arr)&#123;</span><br><span class="line">       <span class="keyword">if</span> (num &gt; max) &#123;</span><br><span class="line">           max = num;</span><br><span class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (num &lt; min) &#123;</span><br><span class="line">           min = num;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算桶的数量</span></span><br><span class="line">    <span class="keyword">int</span> bucketNum = (max - min) / arr.length + <span class="number">1</span>;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; bucketArr = <span class="keyword">new</span> ArrayList&lt;&gt;(bucketNum);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bucketNum; i++)&#123;</span><br><span class="line">        bucketArr.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 利用映射函数将数据分配到各个桶中</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> hash = (arr[i] - min) / (arr.length);</span><br><span class="line">        bucketArr.get(hash).add(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 对每个桶进行排序</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bucketArr.size(); i++)&#123;</span><br><span class="line">        Collections.sort(bucketArr.get(i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将桶中的元素赋值到原序列</span></span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bucketArr.size(); i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; bucketArr.get(i).size(); j++)&#123;</span><br><span class="line">            arr[index++] = bucketArr.get(i).get(j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong>：</p>
<ul>
<li>时间复杂度 O(N)</li>
<li>空间复杂度 O(N)</li>
<li>稳定</li>
</ul>
<h2 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h2><p>基数排序是一种非比较型排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。</p>
<p>将所有待比较数值统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。 这样从最低位排序一直到最高位排序完成以后，数列就变成一个有序序列。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">radixSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//定义桶数组，共10个桶，每个桶是一个一维数组</span></span><br><span class="line">    <span class="keyword">int</span>[][] bucket = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>][arr.length];</span><br><span class="line">    <span class="comment">//每个桶放入元素的个数</span></span><br><span class="line">    <span class="keyword">int</span>[] bucketCount = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">int</span> maxValue = arr[<span class="number">0</span>];</span><br><span class="line">    <span class="comment">//获取最大值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : arr) &#123;</span><br><span class="line">        <span class="keyword">if</span> (num &gt; maxValue) &#123;</span><br><span class="line">            maxValue = num;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取最大位数</span></span><br><span class="line">    <span class="keyword">int</span> maxLength = (maxValue + <span class="string">&quot;&quot;</span>).length();</span><br><span class="line">    <span class="comment">//在对应位上进行排序</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> digit = <span class="number">0</span>, n = <span class="number">1</span>; digit &lt; maxLength; digit++, n*= <span class="number">10</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="comment">//获取元素对应位的值</span></span><br><span class="line">            <span class="keyword">int</span> value = arr[i] / n % <span class="number">10</span>;</span><br><span class="line">            bucket[value][bucketCount[value]++] = arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//将桶中数据放回原数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; bucketCount[j]; k++) &#123;</span><br><span class="line">                arr[index++] = bucket[j][k];</span><br><span class="line">            &#125;</span><br><span class="line">            bucketCount[j] = <span class="number">0</span>; <span class="comment">// 清0</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong>：</p>
<ul>
<li>时间复杂度 O(N)</li>
<li>空间复杂度 O(N)</li>
<li>稳定</li>
</ul>
<h4 id="基数排序-vs-计数排序-vs-桶排序"><a href="#基数排序-vs-计数排序-vs-桶排序" class="headerlink" title="基数排序 vs 计数排序 vs 桶排序"></a>基数排序 vs 计数排序 vs 桶排序</h4><p>这三种排序算法都利用了桶的概念，但对桶的使用方法上有明显差异：</p>
<ul>
<li>计数排序：每个桶只存储单一键值；</li>
<li>桶排序：每个桶存储一定范围的数值；</li>
<li>基数排序：<strong>根据键值的每位数字来分配桶</strong>；</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>当数据规模较小时，可以使用直接插入排序。</li>
<li>当数组初始时已经基本有序，可以用直接插入排序和冒泡排序。</li>
<li>当数据规模较大时，可以考虑使用快速排序，速度最快。当记录随机分布的时候，快速排序平均时间最短。</li>
<li>堆排序所需的辅助空间少于快速排序，并且不会出现快速排序可能出现的最坏情况。这两种排序都是不稳定的。</li>
<li>若要求排序稳定，则可选用归并排序。</li>
</ul>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Java中的阻塞队列BlockingQueue</title>
    <url>/2021/11/22/Java%E4%B8%AD%E7%9A%84%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97BlockingQueue/</url>
    <content><![CDATA[<p>阻塞队列（BlockingQueue）是一个支持两个附加操作的队列。这两个附加的操作支持阻塞的插入和移除方法。</p>
<ul>
<li><strong>支持阻塞的插入方法：当队列满时，队列会阻塞插入元素的线程，直到队列不满，如 <code>put()</code> 方法。</strong></li>
<li><strong>支持阻塞的移除方法：在队列为空时，获取元素的线程会等待队列变为非空，如 <code>take()</code> 方法。</strong></li>
</ul>
<p>BlockingQueue 常用于生产者-消费者场景，生产者是往队列里添加元素的线程，消费者是从队列里取元素的线程。<strong>BlockingQueue就是存放元素的容器</strong>。</p>
<p>阻塞队列提供了四组不同的方法用于插入、移除、检查元素：</p>
<table>
<thead>
<tr>
<th align="center">方法/处理方式</th>
<th align="center">抛出异常</th>
<th align="center">返回特殊值</th>
<th align="center">一直阻塞</th>
<th align="center">超时退出</th>
</tr>
</thead>
<tbody><tr>
<td align="center">插入方法</td>
<td align="center">add(e)</td>
<td align="center">offer(e)</td>
<td align="center"><strong>put(e)</strong></td>
<td align="center">offer(e,time,unit)</td>
</tr>
<tr>
<td align="center">移除方法</td>
<td align="center">remove()</td>
<td align="center">poll()</td>
<td align="center"><strong>take()</strong></td>
<td align="center">poll(time,unit)</td>
</tr>
<tr>
<td align="center">检查方法</td>
<td align="center">element()</td>
<td align="center">peek()</td>
<td align="center">-</td>
<td align="center">-</td>
</tr>
</tbody></table>
<ul>
<li>抛出异常：如果试图的操作无法立即执行则抛出异常。当阻塞队列满时候，再往队列里插入元素，会抛出<code>IllegalStateException(“Queue full”) </code>异常。当队列为空时，从队列里获取元素时会抛出<code>NoSuchElementException</code> 异常 。</li>
<li>返回特殊值：当往队列插入元素时，会返回元素是否插入成功，成功返回 true。如果是移除方法，队列为空时返回 null。</li>
<li>一直阻塞：如果试图的操作无法立即执行，则一直阻塞或者响应中断。</li>
<li>超时退出：如果试图的操作无法立即执行，该方法调用将会发生阻塞，直到能够执行，但等待时间不会超过给定值。返回一个特定值以告知该操作是否成功，通常是 true / false。</li>
</ul>
<br>

<h2 id="BlockingQueue-的实现类"><a href="#BlockingQueue-的实现类" class="headerlink" title="BlockingQueue 的实现类"></a>BlockingQueue 的实现类</h2><p>以下是 7 种阻塞队列：</p>
<ul>
<li>ArrayBlockingQueue：由数组结构组成的有界阻塞队列</li>
<li>LinkedBlockingQueue：由链表结构组成的阻塞队列（可无界、可有界）</li>
<li>PriorityBlockingQueue：支持优先级排序的无界阻塞队列</li>
<li>DelayQueue：使用优先级队列实现的无界阻塞队列</li>
<li>SynchronousQueue：不存储元素的阻塞队列</li>
<li>LinkedTransferQueue：由链表结构组成的无界阻塞队列</li>
<li>LinkedBlockingDeque：由链表结构组成的双向阻塞队列</li>
</ul>
<p><strong>FIFO 队列 ：LinkedBlockingQueue、ArrayBlockingQueue（固定长度）</strong></p>
<p><strong>优先级队列 ：PriorityBlockingQueue</strong></p>
<br>

<h4 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a>ArrayBlockingQueue</h4><p>ArrayBlockingQueue 是一个用数组实现的有界阻塞队列。按照先进先出（FIFO）的原则对元素进行排序。</p>
<p><strong>可以初始化队列大小， 且一旦初始化，容量不能改变。构造方法中的 fair 表示控制对象的内部锁是否采用公平锁，默认是非公平锁。并发控制以及访问者的公平性是使用可重入锁 ReentrantLock 实现的</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayBlockingQueue</span><span class="params">(<span class="keyword">int</span> capacity, <span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (capacity &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">this</span>.items = <span class="keyword">new</span> Object[capacity];</span><br><span class="line">    lock = <span class="keyword">new</span> ReentrantLock(fair);</span><br><span class="line">    notEmpty = lock.newCondition();</span><br><span class="line">    notFull =  lock.newCondition();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><code>ArrayBlockingQueue</code> 默认情况下不保证线程访问队列的公平性</strong>，所谓公平性是指严格按照线程等待的绝对时间顺序，即最先等待的线程能够最先访问到 <code>ArrayBlockingQueue</code>。而非公平性则是指访问的顺序不是遵守严格的时间顺序，有可能导致饥饿现象。如果保证公平性，通常会降低吞吐量。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> ReentrantLock lock;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notFull;</span><br></pre></td></tr></table></figure>

<p><code>ArrayBlockingQueue</code> 实现并发同步的原理就是，读操作和写操作都需要获取到 AQS 独占锁才能进行操作。如果队列为空，这个时候读操作的线程进入到<strong>读线程队列</strong>排队，等待写线程写入新的元素，然后唤醒读线程队列的第一个等待线程。如果队列已满，这个时候写操作的线程进入到<strong>写线程队列</strong>排队，等待读线程将队列元素移除腾出空间，然后唤醒写线程队列的第一个等待线程。</p>
<br>

<h4 id="LinkedBlockingQueue"><a href="#LinkedBlockingQueue" class="headerlink" title="LinkedBlockingQueue"></a>LinkedBlockingQueue</h4><p>LinkedBlockingQueue 底层是基于<strong>单链表</strong>实现的阻塞队列，<strong>可以是无界队列也可以是有界队列</strong>。可以通过构造方法指定容量大小来创建有界队列，也可以不指定容量大小，默认队列的大小是<code>Integer.MAX_VALUE</code>，此时创建的就是无界队列。我们可以通过查看源码来验证：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    E item;</span><br><span class="line">   	<span class="comment">// 只有后驱指针，说明是单链表</span></span><br><span class="line">    Node&lt;E&gt; next;</span><br><span class="line">    Node(E x) &#123; item = x; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 容量限制，如果没有设置，则为 Integer.MAX_VALUE</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> capacity;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 无界队列</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedBlockingQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(Integer.MAX_VALUE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 有界队列</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedBlockingQueue</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (capacity &lt;= <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">    last = head = <span class="keyword">new</span> Node&lt;E&gt;(<span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>LinkedBlockingQueue</code> 实现的队列中的锁是分离的，<strong>其添加采用的是putLock，移除采用的则是takeLock</strong>，这样能<strong>大大提高队列的吞吐量，也意味着在高并发的情况下生产者和消费者可以并行地操作队列中的数据，以此来提高整个队列的并发性能。</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 由 take、poll 等持有的锁</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock takeLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"><span class="comment">// 由 put、offer 等持有的锁</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock putLock = <span class="keyword">new</span> ReentrantLock();</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/KIMTOU/img/raw/master/20211122233047.png"></p>
<blockquote>
<p>图源：<a href="https://javadoop.com/post/java-concurrent-queue">https://javadoop.com/post/java-concurrent-queue</a></p>
</blockquote>
<br>

<h4 id="PriorityBlockingQueue"><a href="#PriorityBlockingQueue" class="headerlink" title="PriorityBlockingQueue"></a>PriorityBlockingQueue</h4><p><strong><code>PriorityBlockingQueue</code> 是一个支持优先级的无界阻塞队列，底层是基于数组的二叉堆实现的，默认情况下元素采用自然顺序升序排序</strong>。也可以通过自定义类实现 <code>compareTo()</code> 方法来指定元素排序规则，或者初始化时通过构造器参数 <code>Comparator</code> 来指定排序规则。**并发控制采用的是可重入锁 <code>ReentrantLock</code>**。</p>
<p><code>PriorityBlockingQueue</code>  是无界队列，初始化时指定的队列大小。无界体现在后面插入元素的时候，<strong>如果空间不够的话会自动扩容</strong>。</p>
<blockquote>
<p>简单地说，它就是 <strong><code>PriorityQueue</code> 的线程安全版本</strong>。不可以插入 null 值。同时，插入队列的对象必须是可比较大小的（comparable），否则报 <code>ClassCastException</code> 异常。<strong>它的插入操作 put 方法不会阻塞，因为它是无界队列，take 方法在队列为空的时候会阻塞</strong>。</p>
</blockquote>
<br>

<h2 id="阻塞队列实现原理"><a href="#阻塞队列实现原理" class="headerlink" title="阻塞队列实现原理"></a>阻塞队列实现原理</h2><p>如果队列为空，消费者会阻塞一直等待，当生产者添加元素时，便需要通知消费者当前队列有元素；而队列满时，生产者需要阻塞，消费者消费了队列一个元素后，又需要通知生产者当前队列可用。所以阻塞队列需要让生产者与消费者进行通信，核心是：<strong>利用 Condition 实现等待 / 通知机制</strong>。</p>
<p>下列我们通过 <code>ArrayBlockingQueue</code> 源码来探究如果利用 Condition 实现等待 / 通知机制：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//数据元素数组</span></span><br><span class="line"><span class="keyword">final</span> Object[] items;</span><br><span class="line"><span class="comment">//内部锁</span></span><br><span class="line"><span class="keyword">final</span> ReentrantLock lock;</span><br><span class="line"><span class="comment">//消费者监视器</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty;</span><br><span class="line"><span class="comment">//生产者监视器</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notFull;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayBlockingQueue</span><span class="params">(<span class="keyword">int</span> capacity, <span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">    lock = <span class="keyword">new</span> ReentrantLock(fair);</span><br><span class="line">    notEmpty = lock.newCondition();</span><br><span class="line">    notFull =  lock.newCondition();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行 <code>put</code> 的线程首先需要竞争 lock 锁，没有获取到锁则自旋竞争锁。当往队列里插入一个元素时，如果队列不可用，<strong>会调用 <code>Condition</code> 的 <code>await</code> 方法阻塞当前线程，直到被消费者唤醒</strong>。可以看到 <code>await</code> 方法阻塞生产者主要通过 <code>LockSupport.park(this)</code> 来实现，而 <code>park</code> 方法又是通过调用 <code>unsafe.park</code> 方法来阻塞当前线程，这是一个 native 方法，需要等到 <code>unpark</code> 执行或者线程被中断该方法才会返回。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ArrayBlockingQueue.put(E e)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    checkNotNull(e);</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lockInterruptibly(); <span class="comment">// 自旋获取锁</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (count == items.length)</span><br><span class="line">            notFull.await(); <span class="comment">// 阻塞生产者</span></span><br><span class="line">        enqueue(e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ArrayBlockingQueue.enqueue(E e)</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(E x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Object[] items = <span class="keyword">this</span>.items;</span><br><span class="line">    items[putIndex] = x;</span><br><span class="line">    <span class="keyword">if</span> (++putIndex == items.length)</span><br><span class="line">        putIndex = <span class="number">0</span>;</span><br><span class="line">    count++;</span><br><span class="line">    notEmpty.signal(); <span class="comment">// 唤醒一个消费者</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ConditionObject.await()</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    Node node = addConditionWaiter();</span><br><span class="line">    <span class="keyword">long</span> savedState = fullyRelease(node);</span><br><span class="line">    <span class="keyword">int</span> interruptMode = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line">        LockSupport.park(<span class="keyword">this</span>); <span class="comment">// 阻塞当前线程</span></span><br><span class="line">        <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// LockSupport.park()</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">park</span><span class="params">(Object blocker)</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    setBlocker(t, blocker);</span><br><span class="line">    UNSAFE.park(<span class="keyword">false</span>, <span class="number">0L</span>); <span class="comment">// 阻塞当前线程</span></span><br><span class="line">    setBlocker(t, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>消费者从队列中获取元素时，若队列为空，会阻塞当前线程；而成功获取元素后，又会唤醒生产者（如果生产者因为队列满而阻塞的话）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lockInterruptibly(); <span class="comment">// 自旋获取锁</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (count == <span class="number">0</span>)</span><br><span class="line">            notEmpty.await(); <span class="comment">// 阻塞消费者</span></span><br><span class="line">        <span class="keyword">return</span> dequeue();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">dequeue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Object[] items = <span class="keyword">this</span>.items;</span><br><span class="line">    E x = (E) items[takeIndex];</span><br><span class="line">    items[takeIndex] = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (++takeIndex == items.length)</span><br><span class="line">        takeIndex = <span class="number">0</span>;</span><br><span class="line">    count--;</span><br><span class="line">    <span class="keyword">if</span> (itrs != <span class="keyword">null</span>)</span><br><span class="line">        itrs.elementDequeued();</span><br><span class="line">    notFull.signal(); <span class="comment">// 唤醒一个生产者</span></span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<blockquote>
<p>参考资料</p>
</blockquote>
<p><strong>《Java 并发编程的艺术》</strong></p>
]]></content>
      <categories>
        <category>并发编程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>Java线程池实现原理与ThreadPoolExector详解</title>
    <url>/2021/11/23/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E4%B8%8EThreadPoolExector%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<p>线程池（Thread Pool）是一种基于池化思想管理线程的工具。</p>
<p><strong>为什么要使用线程池？</strong></p>
<ul>
<li><strong>降低资源消耗</strong>：通过池化技术重复利用已创建的线程降低线程创建和销毁造成的消耗。</li>
<li><strong>提高响应速度</strong>：当任务到达时，任务可以不需要等到线程创建就能立即执行。</li>
<li><strong>提高线程的可管理性</strong>：线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会因为线程的不合理分布导致资源调度失衡，降低系统的稳定性，使用线程池可以进行统一分配、调优和监控。</li>
<li><strong>提供更多更强大的功能</strong>：线程池具备可拓展性，允许开发人员向其中增加更多的功能。比如延时定时线程池ScheduledThreadPoolExecutor，就允许任务延期执行或定期执行。</li>
</ul>
<h2 id="线程池参数"><a href="#线程池参数" class="headerlink" title="线程池参数"></a>线程池参数</h2><p>核心构造方法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                          TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                          ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                          RejectedExecutionHandler handler)</span> </span>&#123;</span><br></pre></td></tr></table></figure>

<p><strong><code>ThreadPoolExecutor</code> 7 大参数：</strong></p>
<ul>
<li><strong>corePoolSize</strong> ：<strong>核心线程数。当提交一个任务到线程池时，线程池会创建一个线程来执行任务，即使其他空闲的核心线程能够执行新任务也会创建线程，直到需要执行的任务数大于核心线程数时就不再创建</strong>。这些线程创建后并不会销毁，而是一种常驻线程。</li>
<li><strong>maximumPoolSize</strong>：<strong>线程池允许创建的最大线程数。如果队列满了，并且已创建的线程数小于最大线程数，则线程池会再创建新的线程执行任务</strong>。但线程池内的总线程数不会超过最大线程数，且如果使用了无界任务队列则该参数不起效果。</li>
<li><strong>workQueue</strong>：<strong>任务队列。用于存放等待执行的任务的阻塞队列</strong>。如果核心线程都在执行任务，并且任务队列没有满，则将新任务存储在这个任务队列。<ul>
<li><strong>ArrayBlockingQueue</strong>：一个基于数组结构的有界阻塞队列，按 FIFO 排序任务。</li>
<li><strong>LinkedBlockingQueue</strong>： 一个基于链表结构的阻塞队列，可有界也可无界，按 FIFO 排序任务，吞吐量通常要高于<code>ArrayBlockingQueue</code>。静态工厂方法 <code>Executors.newFixedThreadPool()</code> 使用了这个队列。</li>
<li><strong>SynchronousQueue</strong>：一个不存储元素的阻塞队列。每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于 <code>LinkedBlockingQueue</code>。静态工厂方法 <code>Executors.newCachedThreadPool()</code> 使用了这个队列。</li>
<li><strong>PriorityBlockingQueue</strong>：一个具有优先级的无界阻塞队列。</li>
</ul>
</li>
</ul>
<ul>
<li><p><strong>keepAliveTime</strong>：<strong>表示核心线程外的线程的空闲存活时间，也就是工作线程空闲后，核心线程外的线程不会立即销毁，而是会等到时间超过<code>keepAliveTime</code>时才会被销毁</strong>。</p>
</li>
<li><p><strong>unit</strong> ：<code>keepAliveTime</code> 参数的时间单位。 </p>
</li>
<li><p><strong>threadFactory</strong>：为线程池提供创建新线程的线程工厂，可以用来设置线程名、是否为守护线程等等。 </p>
</li>
<li><p><strong>handler ：拒绝 / 饱和策略。当队列和线程池都满了，则采取饱和策略处理提交的新任务</strong>。当 <code>ThreadPoolExector</code> 已经关闭时，<code>execute()</code> 方法会调用 Handler。这个策略默认情况下是 <code>AbortPolicy</code>，表示无法处理新任务时抛出异常。</p>
<ul>
<li><p><strong>AbortPolicy ：直接抛出异常</strong> <code>RejectedExecutionException</code> 来拒绝新任务的处理。</p>
</li>
<li><p><strong>CallerRunsPolicy</strong> ：调用执行自己的线程运行任务，也就是直接在调用 <code>execute</code> 方法的线程中运行被拒绝的任务，如果执行程序已关闭，则会丢弃该任务。这种策略会降低对于新任务提交速度，影响程序的整体性能。</p>
</li>
<li><p><strong>DiscardPolicy</strong> ：不处理新任务，直接丢弃掉。</p>
</li>
<li><p><strong>DiscardOldestPolicy</strong> ： 丢弃队列里头部（最早）的任务，并执行当前任务。</p>
</li>
</ul>
</li>
</ul>
<h4 id="线程池中阻塞队列的作用"><a href="#线程池中阻塞队列的作用" class="headerlink" title="线程池中阻塞队列的作用"></a>线程池中阻塞队列的作用</h4><ol>
<li>普通队列只能保证作为一个有限长度的缓冲区，如果超出了缓冲长度，就无法保留当前要入队的任务；而阻塞队列可以通过阻塞保留住当前想要继续入队的任务。</li>
<li>阻塞队列自带阻塞和唤醒的功能，当任务队列中没有任务时，阻塞队列可以阻塞要获取任务的线程，线程池利用阻塞队列的take方法将线程挂起，让其进入wait状态，让核心线程不占用cpu资源。</li>
</ol>
<br>

<h2 id="线程池工作流程"><a href="#线程池工作流程" class="headerlink" title="线程池工作流程"></a>线程池工作流程</h2><p>当向线程池提交一个任务后的处理流程：</p>
<ol>
<li><strong>如果当前运行的线程数小于 corePoolSize，无论线程是否空闲，都会新建一个核心线程来执行任务。（注意，执行这一步需要获得全局锁）。</strong></li>
<li><strong>如果当前运行的线程数 &gt;= corePoolSize 时，则将任务加入任务队列。</strong></li>
<li><strong>当任务队列已满，则创建新的线程（非核心线程）来处理任务（注意，执行这一步需要获得全局锁）。</strong></li>
<li><strong>当任务队列已满， 且当前运行总线程数达到了 maximumPoolSize，则会采取拒绝策略进行处理</strong>。</li>
</ol>
<p><img src="https://gitee.com/KIMTOU/img/raw/master/20211123234325.png"></p>
<p>以下是 <code>ThreadPoolExecute</code> 的 <code>execute</code> 方法的执行流程的源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (command == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">    <span class="comment">// 1.当前线程数小于corePoolSize, 则调用addWorker方法创建核心线程执行任务</span></span><br><span class="line">    <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">        <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        c = ctl.get();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2.如果线程数大于等于corePoolSize, 则将任务加入workQueue工作队列中</span></span><br><span class="line">    <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">        <span class="keyword">int</span> recheck = ctl.get(); <span class="comment">// 再次获取线程池状态，判断线程池状态是否改变，防止任务永远不会执行</span></span><br><span class="line">        <span class="comment">// 如果线程池不处于running状态，则remove这个任务，然后执行拒绝策略</span></span><br><span class="line">        <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">            reject(command);</span><br><span class="line">        <span class="comment">// 如果当前线程池为空就新创建一个线程并执行。</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">            addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3.如果放入workQueue失败（任务队列已满），则创建非核心线程执行任务</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))</span><br><span class="line">        <span class="comment">// 4.如果创建非核心线程失败(当前线程总数不小于maximumPoolSize时)，就会执行拒绝策略</span></span><br><span class="line">        reject(command);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="线程复用原理"><a href="#线程复用原理" class="headerlink" title="线程复用原理"></a>线程复用原理</h4><p><strong>线程池创建线程时，会调用 <code>addWorker</code> 方法将线程封装成工作线程 Worker，Worker 在执行完任务后，还会循环获取任务队列里的任务来执行，从而达到线程复用的目的</strong>。</p>
<br>

<h4 id="为什么先添加队列而不是先创建最大线程？"><a href="#为什么先添加队列而不是先创建最大线程？" class="headerlink" title="为什么先添加队列而不是先创建最大线程？"></a>为什么先添加队列而不是先创建最大线程？</h4><p><strong>为了在执行 execute 方法时，尽可能地避免获取全局锁</strong>。因为创建新线程时，需要获取全局锁，会阻塞其他的线程，十分耗费资源，影响了整体的效率。在 ThreadPoolExecutor 完成预热之后（当前运行的线程数大于等于 corePoolSize），几乎所有的 execute 方法调用都是执行加入任务队列，而这一步不需要获取全局锁。</p>
<br>

<h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><h4 id="execute-方法和submit-方法的区别"><a href="#execute-方法和submit-方法的区别" class="headerlink" title="execute()方法和submit()方法的区别"></a>execute()方法和submit()方法的区别</h4><ul>
<li><code>execute()</code>方法只能接收<code>Runnable</code> 对象。<code>submit()</code>方法可以接收<code>Runnable</code>和 <code>Callable</code>类型的对象。 </li>
<li><code>submit()</code> 方法可以返回持有计算结果的 <code>Future</code> 对象，可以判断任务是否执行成功，而 <code>execute()</code> 方法不可以。 </li>
</ul>
<p>换句话说就是，**<code>execute()</code>方法用于提交不需要返回值的任务，<code>submit()</code>方法用于需要提交返回值的任务**。</p>
<h4 id="shutdown-和shutdownNow"><a href="#shutdown-和shutdownNow" class="headerlink" title="shutdown()和shutdownNow()"></a>shutdown()和shutdownNow()</h4><p><code>shutdown()</code>和<code>shutdownNow()</code>的原理是遍历线程池中的工作线程，逐个调用线程的 interrupt 方法去中断线程。</p>
<p>但不同之处在于<code>shutdown()</code>只是将线程池状态设置成 SHUTDOWN 状态，中断没有在执行任务的线程；<code>shutdownNow()</code>则会将线程池状态设置成 STOP 状态，尝试停止所有正在执行或暂停任务的线程。</p>
<h4 id="isTerminated-和isShutdown"><a href="#isTerminated-和isShutdown" class="headerlink" title="isTerminated()和isShutdown()"></a>isTerminated()和isShutdown()</h4><p><code>isTerminated()</code>：当线程池中所有任务都已经关闭时，返回 true。<br><code>isShutdown()</code>：当线程池调用<code>shutdown()</code>或<code>shutdownNow()</code>方法时，返回true。</p>
<br>

<h2 id="Exector-框架"><a href="#Exector-框架" class="headerlink" title="Exector 框架"></a>Exector 框架</h2><p>由 3 大部分组成：</p>
<ul>
<li>任务：包括被执行任务需要实现的接口 <code>Runnable</code> 或 <code>Callable</code></li>
<li>任务的执行：包括任务执行机制的核心接口 <strong><code>Executor</code></strong> ，以及继承自 <code>Executor</code> 接口的 <strong><code>ExecutorService</code> 接口。<code>ThreadPoolExecutor</code></strong> 和 <strong><code>ScheduledThreadPoolExecutor</code></strong> 这两个关键类实现了 <strong>ExecutorService 接口</strong>。</li>
<li>异步计算的结果：**<code>Future</code>** 接口以及 <code>Future</code> 接口的实现类 <strong><code>FutureTask</code></strong> 类都可以代表异步计算的结果。</li>
</ul>
<h4 id="Executor-框架的使用示意图"><a href="#Executor-框架的使用示意图" class="headerlink" title="Executor 框架的使用示意图"></a>Executor 框架的使用示意图</h4><p><img src="https://gitee.com/KIMTOU/img/raw/master/20211123234346.png"></p>
<ol>
<li><strong>主线程首先要创建实现 <code>Runnable</code> 或者 <code>Callable</code> 接口的任务对象。</strong></li>
<li><strong>把创建完成的实现 <code>Runnable</code>/<code>Callable</code>接口的对象直接交给 <code>ExecutorService</code> 执行</strong>: <code>ExecutorService.execute（Runnable command）</code>）或者也可以把 <code>Runnable</code> 对象或<code>Callable</code> 对象提交给 <code>ExecutorService</code> 执行（<code>ExecutorService.submit（Runnable task）</code>或 <code>ExecutorService.submit（Callable &lt;T&gt; task）</code>）。</li>
<li><strong>如果执行 <code>ExecutorService.submit（…）</code>，<code>ExecutorService</code> 将返回一个实现<code>Future</code>接口的对象</strong>（返回的是 <code>FutureTask</code> 对象）。由于 <code>FutureTask</code> 实现了 <code>Runnable</code>，我们也可以创建 <code>FutureTask</code>，然后直接交给 <code>ExecutorService</code> 执行。</li>
<li><strong>最后，主线程可以执行 <code>FutureTask.get()</code>方法来等待任务执行完成。主线程也可以执行 <code>FutureTask.cancel（boolean mayInterruptIfRunning）</code>来取消此任务的执行。</strong></li>
</ol>
<br>

<h2 id="ThreadPoolExector"><a href="#ThreadPoolExector" class="headerlink" title="ThreadPoolExector"></a>ThreadPoolExector</h2><p>Java中的线程池核心实现类是ThreadPoolExecutor，UML 类图如下：</p>
<img src="https://gitee.com/KIMTOU/img/raw/master/20211123234354.PNG" style="zoom: 67%;" />

<p>ThreadPoolExecutor实现的顶层接口是Executor，顶层接口Executor提供了一种思想：<strong>将任务提交和任务执行分离开来进行解耦</strong>。用户无需关注如何创建线程，如何调度线程来执行任务，用户只需提供Runnable对象，将任务的运行逻辑提交到执行器（Executor）中，<strong>由Executor框架完成线程的调配和任务的执行部分</strong>。</p>
<p>ExecutorService接口增加了一些能力：</p>
<ul>
<li>扩充执行任务的能力，补充可以为一个或一批异步任务生成Future的方法；</li>
<li>提供了管控线程池的方法，比如停止线程池的运行，如 <code>shutdown()</code>。</li>
</ul>
<p>AbstractExecutorService则是上层的抽象类，将执行任务的流程串联了起来，保证下层的实现只需关注一个执行任务的方法即可。最下层的实现类ThreadPoolExecutor实现最复杂的运行部分，ThreadPoolExecutor将会一方面维护自身的生命周期，另一方面同时管理线程和任务，使两者良好的结合从而执行并行任务。</p>
<h4 id="ScheduledThreadPoolExecutor"><a href="#ScheduledThreadPoolExecutor" class="headerlink" title="ScheduledThreadPoolExecutor"></a>ScheduledThreadPoolExecutor</h4><p><strong><code>ScheduledThreadPoolExecutor</code> 主要用来在给定的延迟后运行任务，或者定期执行任务。</strong>使用 DelayQueue 无界队列作为任务队列。</p>
<br>

<h2 id="常见线程池"><a href="#常见线程池" class="headerlink" title="常见线程池"></a>常见线程池</h2><p>通过 Executor 框架的工具类 Exectors，可以常见 3 种类型的 ThreadPoolExector。</p>
<ul>
<li>FixedThreadPool</li>
<li>SingleThreadExector</li>
<li>CachedThreadPool</li>
</ul>
<h4 id="FixedThreadPool"><a href="#FixedThreadPool" class="headerlink" title="FixedThreadPool"></a>FixedThreadPool</h4><p><strong><code>FixedThreadPool</code> 被称为可重用固定线程数的线程池</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                  <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><code>FixedThreadPool</code> 的 <code>corePoolSize</code> 和 <code>maximumPoolSize</code> 都被设置为 nThreads，这个 nThreads 参数是我们使用时指定的线程数。</strong><code>keepAliveTime</code> 设置为 0L，意味着多余的空闲线程会被立即终止。使用无界队列 <code>LinkedBlockingQueue</code>（队列的容量为 Integer.MAX_VALUE）作为线程池的工作队列。</p>
<img src="https://gitee.com/KIMTOU/img/raw/master/20211123234427.png" style="zoom:67%;" />

<p>FixedThreadPool 的 execute() 运行流程如下：</p>
<ol>
<li>如果当前运行的线程数小于 corePoolSize，如果再来新任务的话，就创建新线程来执行任务；</li>
<li>当前运行的线程数等于 corePoolSize 后， 如果再来新任务的话，会将任务加入 <code>LinkedBlockingQueue</code>；</li>
<li>线程执行完任务后，会在循环中反复从 <code>LinkedBlockingQueue</code> 中获取任务来执行；</li>
</ol>
<h4 id="SingleThreadExecutor"><a href="#SingleThreadExecutor" class="headerlink" title="SingleThreadExecutor"></a>SingleThreadExecutor</h4><p><strong><code>SingleThreadExecutor</code> 是使用单个 worker 线程的线程池</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">        (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>SingleThreadExecutor</code> 的 <code>corePoolSize</code> 和 <code>maximumPoolSize</code> 都被设置为 1。其他参数和 <code>FixedThreadPool</code> 相同。使用无界队列 <code>LinkedBlockingQueue</code>（队列的容量为 Integer.MAX_VALUE）作为线程池的工作队列。</p>
<h4 id="CachedThreadPool"><a href="#CachedThreadPool" class="headerlink" title="CachedThreadPool"></a>CachedThreadPool</h4><p><strong><code>CachedThreadPool</code> 是一个会根据需要创建新线程的线程池</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                  <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>CachedThreadPool</code> 的<code>corePoolSize</code> 被设置为 0，即 corePool 为空；<code>maximumPoolSize</code>被设置为 <code>Integer.MAX.VALUE</code>，即它是无界的，这意味着如果主线程提交任务的速度高于 <code>maximumPool</code> 中线程处理任务的速度时，<code>CachedThreadPool</code> 会不断创建新线程。极端情况下，这样会导致耗尽 CPU 和内存资源。</p>
<p>CachedThreadPool 的 execute() 运行流程如下：</p>
<ol>
<li>首先执行 <code>SynchronousQueue.offer(Runnable task)</code> 提交任务到任务队列。如果当前 <code>maximumPool</code> 中有闲线程正在执行 <code>SynchronousQueue.poll(keepAliveTime,TimeUnit.NANOSECONDS)</code>，那么主线程执行 offer 操作与空闲线程执行的 <code>poll</code> 操作配对成功，主线程把任务交给空闲线程执行，<code>execute()</code>方法执行完成，否则执行下面的步骤 2；</li>
<li>当初始 <code>maximumPool</code> 为空，或者 <code>maximumPool</code> 中没有空闲线程时，将没有线程执行 <code>SynchronousQueue.poll(keepAliveTime,TimeUnit.NANOSECONDS)</code>。这种情况下，步骤 1 将失败，此时 <code>CachedThreadPool</code> 会创建新线程执行任务，execute 方法执行完成；</li>
<li>新创建的线程将任务执行完后，会继续执行 poll 操作，这个 poll 操作会让空闲线程最多在 <code>SynchronousQueue</code> 中等待 60 秒。</li>
</ol>
<h4 id="ScheduledThreadPool"><a href="#ScheduledThreadPool" class="headerlink" title="ScheduledThreadPool"></a>ScheduledThreadPool</h4><p>创建一个支持可延迟或定期执行任务的线程池。</p>
<br>

<h4 id="推荐使用-ThreadPoolExecutor-构造函数创建线程池"><a href="#推荐使用-ThreadPoolExecutor-构造函数创建线程池" class="headerlink" title="推荐使用 ThreadPoolExecutor 构造函数创建线程池"></a>推荐使用 ThreadPoolExecutor 构造函数创建线程池</h4><p>通过 <code>ThreadPoolExecutor</code> 构造函数的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。</p>
<p><code>Executors</code> 返回线程池对象的弊端如下：</p>
<ul>
<li><strong><code>FixedThreadPool</code> 和 <code>SingleThreadExecutor</code></strong> ： 允许请求的队列长度为 <code>Integer.MAX_VALUE</code>，可能堆积大量的请求，从而导致 OOM。</li>
<li><strong><code>CachedThreadPool</code> 和 <code>ScheduledThreadPool</code></strong> ： 允许创建的线程数量为 <code>Integer.MAX_VALUE</code> ，可能会创建大量线程，从而导致 OOM。</li>
</ul>
<br>

<blockquote>
<p>参考资料</p>
</blockquote>
<p><strong>《Java 并发编程的艺术》</strong></p>
]]></content>
      <categories>
        <category>并发编程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式基础——CAP理论与BASE理论</title>
    <url>/2021/11/27/%E5%88%86%E5%B8%83%E5%BC%8F%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94CAP%E7%90%86%E8%AE%BA%E4%B8%8EBASE%E7%90%86%E8%AE%BA/</url>
    <content><![CDATA[<blockquote>
<p>本文内容整理自：<a href="https://blog.csdn.net/qq_34337272/article/details/80444032%EF%BC%8C%E5%B9%B6%E9%99%84%E4%B8%8A%E8%87%AA%E5%B7%B1%E7%9A%84%E7%90%86%E8%A7%A3">https://blog.csdn.net/qq_34337272/article/details/80444032，并附上自己的理解</a></p>
</blockquote>
<h1 id="CAP理论"><a href="#CAP理论" class="headerlink" title="CAP理论"></a>CAP理论</h1><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p><strong>CAP</strong> 也就是 <strong>Consistency（一致性）</strong>、<strong>Availability（可用性）</strong>、<strong>Partition Tolerance（分区容错性）</strong> 这三个单词首字母组合。</p>
<p><img src="https://gitee.com/KIMTOU/img/raw/master/20211127225448.png"></p>
<p>在理论计算机科学中，CAP 定理（CAP theorem）指出对于一个分布式系统来说，当设计读写操作时，只能同时满足以下三点中的两个：</p>
<ul>
<li><strong>一致性（Consistency）</strong> : 所有节点访问同一份最新的数据副本</li>
<li><strong>可用性（Availability）</strong>: 非故障的节点在合理的时间内返回合理的响应（不是错误或者超时的响应）。</li>
<li><strong>分区容错性（Partition tolerance）</strong> : 分布式系统出现网络分区的时候，仍然能够对外提供服务。</li>
</ul>
<p><strong>什么是网络分区？</strong></p>
<blockquote>
<p>分布式系统中，多个节点之前的网络本来是连通的，但是因为某些故障（比如部分节点网络出了问题）某些节点之间不连通了，整个网络就分成了几块区域，这就叫网络分区。</p>
</blockquote>
<h3 id="权衡"><a href="#权衡" class="headerlink" title="权衡"></a>权衡</h3><p>当发生网络分区的时候，如果我们要继续服务，那么强一致性和可用性只能 2 选 1。也就是说当网络分区之后 P 是前提，决定了 P 之后才有 C 和 A 的选择。也就是说分区容错性（Partition tolerance）我们是必须要实现的。</p>
<p>简而言之就是：<strong>CAP 理论中分区容错性 P 是一定要满足的，在此基础上，只能满足可用性 A 或者一致性 C</strong>。</p>
<p><strong>因此，分布式系统理论上不可能选择 CA 架构，只能选择 CP 或者 AP 架构</strong>。为啥不可能选择 CA 架构呢？ 举个例子：<strong>若系统出现“分区”，系统中的某个节点在进行写操作。为了保证 C， 必须要禁止其他节点的读写操作，这就和 A 发生冲突了。如果为了保证 A，其他节点的读写操作正常的话，那就和 C 发生冲突了</strong>。</p>
<p>选择 CP 还是 AP 的关键在于当前的业务场景，没有定论，比如对于需要确保强一致性的场景如银行一般会选择保证 CP ，而Redis 则是 AP 架构。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在分布式系统中，分区容忍性必不可少，因为需要总是假设网络是不可靠的。因此，CAP 理论实际上是要在可用性和一致性之间做权衡。</p>
<p>可用性和一致性往往是冲突的，很难使它们同时满足。在多个节点之间进行数据同步时：</p>
<ul>
<li>为了保证一致性（CP），不能访问未同步完成的节点，也就失去了部分可用性；</li>
<li>为了保证可用性（AP），允许读取所有节点的数据，但是数据可能不一致。</li>
</ul>
<h1 id="BASE理论"><a href="#BASE理论" class="headerlink" title="BASE理论"></a>BASE理论</h1><p><strong>BASE</strong> 是 <strong>Basically Available（基本可用）</strong> 、<strong>Soft-state（软状态）</strong> 和 <strong>Eventually Consistent（最终一致性）</strong> 三个短语的缩写。BASE 理论是对 CAP 中一致性 C 和可用性 A 权衡的结果，是基于 CAP 定理逐步演化而来的。</p>
<h3 id="BASE-理论的核心思想"><a href="#BASE-理论的核心思想" class="headerlink" title="BASE 理论的核心思想"></a>BASE 理论的核心思想</h3><p>即使无法做到强一致性，但每个应用都可以根据自身业务特点，采用适当的方式来使系统达到最终一致性。</p>
<blockquote>
<p>也就是牺牲数据的一致性来满足系统的高可用性，系统中一部分数据不可用或者不一致时，仍需要保持系统整体“主要可用”。</p>
</blockquote>
<p><strong>BASE 理论本质上是对 CAP 的延伸和补充，更具体地说，是对 CAP 中 AP 方案的一个补充</strong>。AP 方案只是在系统发生分区的时候放弃一致性，而不是永远放弃一致性。在分区故障恢复后，系统应该达到最终一致性。这一点其实就是 BASE 理论延伸的地方。</p>
<h4 id="1-基本可用"><a href="#1-基本可用" class="headerlink" title="1. 基本可用"></a>1. 基本可用</h4><p><strong>基本可用</strong>是指分布式系统在出现不可预知故障的时候，允许损失部分可用性。但是，这绝不等价于系统不可用。</p>
<p><strong>什么叫允许损失部分可用性呢？</strong></p>
<ul>
<li><strong>响应时间上的损失</strong>: 正常情况下，处理用户请求需要 0.5s 返回结果，但是由于系统出现故障，处理用户请求的时间变为 3 s。</li>
<li><strong>系统功能上的损失</strong>：正常情况下，用户可以使用系统的全部功能，但是由于系统访问量突然剧增，系统的部分非核心功能无法使用。</li>
</ul>
<h4 id="2-软状态"><a href="#2-软状态" class="headerlink" title="2. 软状态"></a>2. 软状态</h4><p>软状态指允许系统中的数据存在中间状态（<strong>CAP 理论中的数据不一致</strong>），并认为该中间状态的存在不会影响系统的整体可用性，即允许系统在不同节点的数据副本之间进行数据同步的过程存在延时。</p>
<h4 id="3-最终一致性"><a href="#3-最终一致性" class="headerlink" title="3. 最终一致性"></a>3. 最终一致性</h4><p>最终一致性强调的是系统中所有的数据副本，在经过一段时间的同步后，最终能够达到一个一致的状态。因此，最终一致性的本质是需要系统保证最终数据能够达到一致，而不需要实时保证系统数据的强一致性。</p>
<p>分布式一致性的 3 种级别：</p>
<ol>
<li><strong>强一致性</strong> ：系统写入了什么，读出来的就是什么。但对性能影响比较大。</li>
<li><strong>弱一致性</strong> ：不一定可以读取到最新写入的值，也不保证多少时间之后数据能达到一致，只是会尽量保证某个时刻达到数据一致的状态。</li>
<li><strong>最终一致性</strong> ：弱一致性的升级版，系统会保证在一定时间内达到数据一致的状态。</li>
</ol>
<p><strong>业界比较推崇是最终一致性级别，但是某些对数据一致要求十分严格的场景比如银行转账还是要保证强一致性。</strong></p>
<p>那实现最终一致性的具体方式是什么呢？</p>
<blockquote>
<ul>
<li><strong>读时修复</strong> : 在读取数据时，检测数据的不一致，进行修复。比如 Cassandra 的 Read Repair 实现，具体来说，在向 Cassandra 系统查询数据的时候，如果检测到不同节点 的副本数据不一致，系统就自动修复数据。</li>
<li><strong>写时修复</strong> : 在写入数据，检测数据的不一致时，进行修复。比如 Cassandra 的 Hinted Handoff 实现。具体来说，Cassandra 集群的节点之间远程写数据的时候，如果写失败 就将数据缓存下来，然后定时重传，修复数据的不一致性。</li>
<li><strong>异步修复</strong> : 这个是最常用的方式，通过定时对账检测副本数据的一致性，并修复。</li>
</ul>
</blockquote>
<p>比较推荐 <strong>写时修复</strong>，这种方式对性能消耗比较低。</p>
<p>异步修复则可以通过定时任务，比如在凌晨这个流量低谷的时候进行数据同步。</p>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p><strong>ACID 是数据库事务完整性的理论，CAP 是分布式系统设计理论，BASE 是 CAP 理论中 AP 方案的延伸。</strong></p>
]]></content>
      <categories>
        <category>分布式</category>
      </categories>
      <tags>
        <tag>分布式</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式基础——几种常见的分布式锁</title>
    <url>/2021/11/27/%E5%88%86%E5%B8%83%E5%BC%8F%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94%E5%87%A0%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/</url>
    <content><![CDATA[<h1 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h1><p>在单机场景下，可以使用语言的内置锁来实现进程同步，如 <code>synchronized</code>、<code>Lock</code>等。但是在分布式场景下，需要同步的进程可能位于不同的节点上，那么就需要使用分布式锁。</p>
<p><strong>分布式锁</strong>：是控制分布式系统不同进程共同访问共享资源的一种锁的实现。</p>
<h3 id="数据库的唯一索引"><a href="#数据库的唯一索引" class="headerlink" title="数据库的唯一索引"></a>数据库的唯一索引</h3><p>向表中插入一条唯一索引的记录，此时相当于加锁，释放锁时删除这条记录。唯一索引可以保证该记录只被插入一次，那么就可以用这个记录是否存在来判断是否处于锁定状态。</p>
<p>存在以下几个问题：</p>
<ul>
<li>锁没有失效时间，解锁失败的话其它进程无法再获得该锁；</li>
<li>只能是非阻塞锁，插入失败直接就报错了，无法重试；</li>
<li>不可重入，已经获得锁的进程也必须重新获取锁。</li>
</ul>
<h3 id="Redis-的-SETNX-指令"><a href="#Redis-的-SETNX-指令" class="headerlink" title="Redis 的 SETNX 指令"></a>Redis 的 SETNX 指令</h3><p>使用 SETNX（set if not exist）指令插入一个键值对，如果 Key 已经存在，那么会返回 False，否则插入成功并返回 True。</p>
<p>SETNX 指令和数据库的唯一索引类似，保证了只存在一个 Key 的键值对，那么可以用一个 Key 的键值对是否存在来判断是否存于锁定状态。</p>
<p>EXPIRE 指令可以为一个键值对设置一个过期时间，从而避免了数据库唯一索引实现方式中释放锁失败的问题。</p>
<p>缺点：</p>
<ul>
<li>setnx和expire分两步执行，非原子操作；若setnx执行成功，但expire执行失败，就可能出现死锁。如果执行完<code>setnx</code>加锁，正要执行expire设置过期时间时，进程crash掉或者要重启维护了，那这个锁就一直存在了，<strong>别的线程永远获取不到锁</strong>了。</li>
<li>不支持阻塞等待、不可重入</li>
</ul>
<h3 id="Redis-set的扩展命令（set-ex-px-nx）"><a href="#Redis-set的扩展命令（set-ex-px-nx）" class="headerlink" title="Redis set的扩展命令（set ex px nx）"></a>Redis set的扩展命令（set ex px nx）</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 一条命令保证原子性执行</span></span><br><span class="line">127.0.0.1:6379&gt; SET lock value EX 10 NX</span><br><span class="line">OK</span><br><span class="line"><span class="meta">#</span><span class="bash"> 加锁与设置过期时间原子性执行</span></span><br></pre></td></tr></table></figure>

<p>存在问题：</p>
<ul>
<li>锁过期释放了，业务还没执行完。</li>
<li>锁被其他线程误释放。（可以使用lua脚本释放，但第一个问题依旧无法解决）</li>
</ul>
<h3 id="Redisson"><a href="#Redisson" class="headerlink" title="Redisson"></a>Redisson</h3><p>以上的方案可能存在锁过期释放，业务没执行完的问题。其实我们可以给获得锁的线程<strong>开启一个定时守护线程，每隔一段时间检查锁是否还存在，存在就自动对锁的过期时间延长，防止锁过期提前释放</strong>。</p>
<p><strong>Redisson 实现的原理就是基于看门狗机制</strong>：</p>
<p>只要线程一加锁成功，就会启动一个<code>watch dog</code>看门狗，它是一个后台线程，会每隔10秒检查一下，如果线程1还持有锁，那么就会不断的延长锁key的生存时间。因此使用Redisson能够解决<strong>锁过期释放，业务没执行完</strong>问题。并且 Redisson 还是可重入锁，底层依靠 lua 脚本支持。</p>
<h3 id="Redis-的-RedLock-算法"><a href="#Redis-的-RedLock-算法" class="headerlink" title="Redis 的 RedLock 算法"></a>Redis 的 RedLock 算法</h3><p>Redis一般都是集群部署的，假设数据在主从同步过程，主节点挂了，Redisson 使用看门狗（守护线程）“续命”的方案可能会出现问题。</p>
<blockquote>
<ol>
<li>如果线程一在Redis的master节点上拿到了锁，将键值对写入 redis 的 master 节点</li>
<li>但是加锁的key还没同步到slave节点。恰好这时，master节点发生故障</li>
<li>Redis 触发故障转移，一个slave节点就会升级为master节点，此时新的 master 并不包含线程1写key</li>
<li>因此线程2尝试获取同个key的锁也可以成功拿到锁，但线程一也已经拿到锁了，锁的安全性就没了。</li>
</ol>
</blockquote>
<p>上述问题的根本原因主要是由于 redis 异步复制带来的数据不一致问题导致的，因此解决的方向就是保证数据的一致。为了解决这个问题，Redis作者提出一种高级的分布式锁算法：<strong>Redlock</strong>。Redlock核心思想是这样的：</p>
<p>使用了多个 Redis master 实例来实现分布式锁，这是为了保证在发生单点故障时仍然可用。</p>
<ul>
<li>尝试从 N 个互相独立 Redis master 实例获取锁；</li>
<li>计算获取锁消耗的时间，只有时间小于锁的过期时间，并且从大多数（N / 2 + 1）实例上获取了锁，才认为获取锁成功；</li>
<li>如果获取锁失败，就到每个实例上释放锁。</li>
</ul>
<p>也就是说，该方案为了解决数据不一致的问题，直接舍弃了异步复制，只使用 master 节点，同时由于舍弃了 slave，为了保证高可用性，引入了 N 个节点，官方建议是 5。</p>
<br>

<blockquote>
<p>参考资料</p>
</blockquote>
<p><a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E5%88%86%E5%B8%83%E5%BC%8F.md#%E4%B8%80%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81">CS-Notes/分布式.md at master · CyC2018/CS-Notes (github.com)</a></p>
]]></content>
      <categories>
        <category>分布式</category>
      </categories>
      <tags>
        <tag>分布式</tag>
      </tags>
  </entry>
  <entry>
    <title>ThreadLocal原理以及内存泄漏问题</title>
    <url>/2021/11/27/ThreadLocal%E5%8E%9F%E7%90%86%E4%BB%A5%E5%8F%8A%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h4 id="什么是ThreadLocal？有哪些应用场景？"><a href="#什么是ThreadLocal？有哪些应用场景？" class="headerlink" title="什么是ThreadLocal？有哪些应用场景？"></a>什么是ThreadLocal？有哪些应用场景？</h4><p><strong><code>ThreadLocal</code>类可以让每个线程绑定自己的值，也就是拥有自己的专属本地变量</strong>。</p>
<p><code>ThreadLocal</code>为变量在每个线程中都创建了一个副本，那么每个线程可以访问自己内部的副本变量，并且不会和其他线程的变量冲突，实现了线程间的数据隔离，避免了线程安全问题。</p>
<p><strong><code>ThreadLocal</code>的应用场景主要有以下几个方面</strong>：</p>
<ul>
<li>保存线程上下文信息，避免参数的显示传递，在需要的地方可以直接获取</li>
<li>线程间数据隔离 </li>
<li>进行事务操作时存储线程事务信息，因为事务和线程绑定在一起（Spring在事务开始时会给当前线程绑定一个Jdbc Connection对象，放在ThreadLocal中存储，这样在整个事务执行过程中都是使用该线程绑定的connection来执行数据库操作，实现了事务的隔离性）</li>
<li>数据库连接（经典的使用场景是为每个线程分配一个JDBC Connection连接对象，这样可以保证每个线程的都在各自的Connection上进行数据库的操作，不会出现A线程关了B线程正在使用的Connection）</li>
<li>session会话等线程级别的操作（Session 的特性很适合 ThreadLocal ，因为 Session 之前当前会话周期内有效，会话结束便销毁）</li>
</ul>
<br>

<h4 id="ThreadLocal-原理"><a href="#ThreadLocal-原理" class="headerlink" title="ThreadLocal 原理"></a>ThreadLocal 原理</h4><p>从<code>Thread</code>类的源代码可以看出<code>Thread</code> 类中有一个 <code>threadLocals</code> 和一个 <code>inheritableThreadLocals</code> 变量，它们都是 <code>ThreadLocalMap</code> 类型的变量，实际上当前线程调用 <code>ThreadLocal</code> 类的 <code>set</code>或<code>get</code>方法时，我们调用的是当前线程的<code>ThreadLocalMap</code>类对应的 <code>get()</code>、<code>set()</code>方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * ThreadLocal 能为线程设置线程私有变量 就是通过下面这个threadLocals变量完成的，</span></span><br><span class="line"><span class="comment">	 * ThreadLocal的get/set方法就是通过操作 各个线程的 threadLocals 变量实现的。</span></span><br><span class="line"><span class="comment">	 * 1、线程A持有一个 ThreadLocalMap 变量；</span></span><br><span class="line"><span class="comment">	 * 2、线程A调用一个类的 ThreadLocal变量 tlA 的 get/set方法；</span></span><br><span class="line"><span class="comment">	 * 3、tlA（ThreadLocal）的 get/set方法 获取当前线程A，</span></span><br><span class="line"><span class="comment">	 				调用 线程A 的 ThreadLocalMap变量 的get/put方法；</span></span><br><span class="line"><span class="comment">	 * 4、其它线程 调用 tlA（ThreadLocal）的 get/set方法 同理。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="comment">//与此线程有关的ThreadLocal值。由ThreadLocal类维护</span></span><br><span class="line">    ThreadLocal.ThreadLocalMap threadLocals = <span class="keyword">null</span>;</span><br><span class="line">    ThreadLocal.ThreadLocalMap inheritableThreadLocals = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>ThreadLocal 是线程本地存储，每个线程中都具备一个<code>ThreadLocalMap</code>，<code>ThreadLocalMap</code>可以存储以<code>ThreadLocal</code>为 key ，Object 对象为 value 的键值对</strong>。<code>ThreadLocalMap</code>是<code>ThreadLocal</code>的内部类，可以理解为一个Map容器，其维护了一个 Entry 数组，由一个个key-value对象<code>Entry</code>构成。</p>
<p><strong>由于每一条线程都含有线程私有的ThreadLocalMap容器，这些容器间相互独立不影响，因此不会存在线程安全的问题，从而无需使用同步机制来保证多条线程访问容器的互斥性</strong>。</p>
<ul>
<li>使用set方法时：<code>ThrealLocal</code> 类中可以通过<code>Thread.currentThread()</code>获取到当前线程对象后，直接通过<code>getMap(Thread t)</code>可以访问到该线程的<code>ThreadLocalMap</code>对象，再以当前的ThreadLocal对象为key，将值存入ThreadLocalMap对象中。</li>
</ul>
<ul>
<li>get方法执行过程类似，首先ThreadLocal获取当前线程对象，然后获取当前线程的ThreadLocalMap对象，再以当前的ThreadLocal对象为key，获取对应的value。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">        map.set(<span class="keyword">this</span>, value); <span class="comment">//key为当前ThreadLocal对象，value为set的值</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>); <span class="comment">//key为当前ThreadLocal对象，获取绑定的值</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            T result = (T)e.value;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<h4 id="ThreadLocal-内存泄漏问题"><a href="#ThreadLocal-内存泄漏问题" class="headerlink" title="ThreadLocal 内存泄漏问题"></a>ThreadLocal 内存泄漏问题</h4><blockquote>
<p><strong>内存泄露 <strong>：</strong>指的是为程序在申请内存后，无法释放已申请的内存空间</strong>。一次内存泄露危害可以忽略，但内存泄露堆积后果很严重，无论多少内存迟早会被占光。简单来说，不再会被使用的对象或者变量占用的内存不能被回收，就是内存泄露。</p>
<p>与OOM的区别：内存泄漏是内存占用无法释放，而OOM是内存不够，内存泄漏会导致OOM。</p>
</blockquote>
<p><strong><code>ThreadLocalMap</code> 中使用的 key 为 <code>ThreadLocal</code> 的弱引用，而 value 是强引用</strong>。所以，如果 <code>ThreadLocal</code> 没有被外部强引用的情况下，在垃圾回收的时候，key 会被清理掉，而 value 不会被清理掉。这样一来，<code>ThreadLocalMap</code> 中就会出现 key 为 null 的 Entry，而value还存在着强引用。假如我们不做任何措施的话，value 永远无法被 GC 回收，这个时候就可能会产生内存泄露。<code>ThreadLocalMap</code> 实现中已经考虑了这种情况，在调用 <code>set()</code>、<code>get()</code>、<code>remove()</code> 方法的时候，会清理掉 key 为 null 的记录。使用完 <code>ThreadLocal</code>方法后最好手动调用<code>remove()</code>方法。</p>
<p><img src="https://gitee.com/KIMTOU/img/raw/master/20211127232429.png"></p>
<p>看到Entry继承自 <code>WeakReferencr&lt;ThreadLocal&lt;?&gt;&gt;</code>，就是一个 key-value 形式的对象。它的 key 就是 ThreadLocal 对象，并且是一个弱引用，如果没有指向 key 的强引用后，该 key 就会被垃圾回收器回收；Entry 的 value 就是存储 Object 对象，是强引用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalMap</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line">        <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">        Object value;</span><br><span class="line"></span><br><span class="line">        Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">            <span class="keyword">super</span>(k);</span><br><span class="line">            value = v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>强引用：</strong></p>
<p>指在代码之中普遍存在的引用赋值，即使用 <code>new</code> 对象创建强引用。无论任何情况下，<strong>只要强引用关系还存在，垃圾收集器就永远不会对被引用的对象进行回收</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object obj = <span class="keyword">new</span> Object();</span><br></pre></td></tr></table></figure>

<p>如果想要取消强引用和某个对象之间的关联，<strong>可以显示将引用赋值为null，或者超过了引用的作用域时</strong>，如方法结束，就可以当作垃圾回收，这样JVM就可以在合适的时间对其回收。</p>
<p><strong>弱引用：</strong></p>
<p>也是用来描述那些非必须对象，<strong>但被弱引用关联的对象不管内存是否足够都一定会被回收，也就是说它只能存活到下一次垃圾回收发生为止</strong>，比起软引用，只具有弱引用的对象拥有更短暂的生命周期。可以使用 <code>WeakReference</code> 类来创建弱引用。</p>
</blockquote>
<br>

<h4 id="为什么要将key设计成ThreadLocal的弱引用？"><a href="#为什么要将key设计成ThreadLocal的弱引用？" class="headerlink" title="为什么要将key设计成ThreadLocal的弱引用？"></a>为什么要将key设计成ThreadLocal的弱引用？</h4><p><strong>如果<code>key</code>是强引用，同样会发生内存泄漏的</strong>。引用ThreadLocal的对象被回收了，但是ThreadLocalMap还持有ThreadLocal的强引用，如果没有手动删除，ThreadLocal不会被回收，导致Entry内存泄漏。</p>
<p>如果是弱引用的话，引用ThreadLocal的对象被回收了，由于ThreadLocalMap持有ThreadLocal的弱引用，即使没有手动删除，ThreadLocal也会被回收，此时的key为null，但在下一次调用ThreadLocalMap的set()、get()、remove()方法时，会清除 key 为 null 的 value 值，避免内存泄漏。</p>
<p>因此，ThreadLocal内存泄漏的根本原因是：由于ThreadLocalMap的生命周期跟Thread一样长，如果没有手动删除对应key就会导致内存泄漏，而不是因为弱引用。</p>
<p>所以两种方案比较下来，还是<code>ThreadLoacl</code>的<code>key</code>为弱引用好一些。</p>
<p><strong>ThreadLocal的正确使用方法：</strong></p>
<ul>
<li>当ThreadLocal作为局部变量时，<strong>每次使用完（方法结束）都调用其 remove() 方法清除数据</strong>（生命周期不需要和项目的生存周期一样长的）。</li>
<li><strong>将ThreadLocal变量定义成为private static</strong>，这样就一直存在ThreadLocal的强引用，ThreadLocal就不会轻易被回收，可以保证任何时候都能通过ThreadLocal的弱引用访问到Entry的value值，进而清除掉无用的value。</li>
</ul>
]]></content>
      <categories>
        <category>并发编程</category>
      </categories>
      <tags>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>AQS原理与ReentrantLock源码分析</title>
    <url>/2021/11/28/AQS%E5%8E%9F%E7%90%86%E4%B8%8EReentrantLock%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p><strong>AQS 的全称为 <code>AbstractQueuedSynchronizer</code>，即抽象队列同步器</strong>，这个类在<code>java.util.concurrent.locks</code>包下面。</p>
<p><strong>AQS 是一个用来构建锁和同步器的框架</strong>，使用 AQS 能简单且高效地构造出大量应用广泛的同步器，比如我们提到的 <code>ReentrantLock</code>，<code>Semaphore</code>，其他的诸如 <code>ReentrantReadWriteLock</code>，<code>SynchronousQueue</code>，<code>FutureTask</code> 等等皆是基于 AQS 的。</p>
<h2 id="AQS-原理"><a href="#AQS-原理" class="headerlink" title="AQS 原理"></a>AQS 原理</h2><p><strong>AQS 核心思想 / 工作流程是：如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制 AQS 是用 CLH 队列锁实现的，即将暂时获取不到锁的线程加入到队列中。</strong></p>
<blockquote>
<p>CLH(Craig,Landin and Hagersten)队列是一个虚拟的双向队列（虚拟的双向队列即不存在队列实例，仅存在结点之间的关联关系）。AQS 是将每条请求共享资源的线程封装成一个 CLH 锁队列的一个结点（Node）来实现锁的分配。</p>
<p>这个队列是通过CLH队列实现的，从图可以看出，该队列是一个双向队列，有Node结点组成，每个Node结点维护一个prev引用和next引用，这两个引用分别指向自己结点的前驱结点和后继结点，同时AQS还维护两个指针Head和Tail，分别指向队列的头部和尾部。</p>
</blockquote>
<p><img src="https://gitee.com/KIMTOU/img/raw/master/20211128203029.png"></p>
<p><strong>AQS 使用一个 int 成员变量来表示同步状态，通过内置的 FIFO 队列来完成获取资源线程的排队工作</strong>。</p>
<p>AQS 使用 CAS 对该同步状态进行原子操作实现对其值的修改。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state; <span class="comment">//共享变量，使用volatile修饰保证线程可见性</span></span><br></pre></td></tr></table></figure>

<p>状态信息通过 protected 类型的 getState，setState，compareAndSetState 进行操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//返回同步状态的当前值</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> state;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//设置同步状态的值</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(<span class="keyword">int</span> newState)</span> </span>&#123;</span><br><span class="line">    state = newState;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//原子地（CAS操作）将同步状态值设置为给定值update如果当前同步状态的值等于expect（期望值）</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSetState</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="keyword">this</span>, stateOffset, expect, update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<h2 id="资源共享方式"><a href="#资源共享方式" class="headerlink" title="资源共享方式"></a>资源共享方式</h2><p><strong>AQS 定义两种资源共享方式</strong></p>
<ul>
<li><strong>独占模式（Exclusive）</strong>：资源是独占的，一次只能一个线程获取。如 <code>ReentrantLock</code>。<ul>
<li>又可分为公平锁和非公平锁：<ul>
<li>公平锁：按照线程在队列中的排队顺序，先到者先拿到锁</li>
<li>非公平锁：当线程要获取锁时，无视队列顺序直接去抢锁，谁抢到就是谁的</li>
</ul>
</li>
</ul>
</li>
<li><strong>共享模式（Share）</strong>：同时可以被多个线程获取，具体的资源个数可以通过参数指定。如<code> CountDownLatch</code>、<code>Semaphore</code>、 <code>CyclicBarrier</code>、<code>ReadWriteLock</code> 。</li>
</ul>
<blockquote>
<p>相对来说，非公平锁会有更好的性能，因为它的吞吐量比较大。当然，非公平锁让获取锁的时间变得更加不确定，可能会导致在阻塞队列中的线程长期处于饥饿状态。</p>
</blockquote>
<br>

<h2 id="AQS-底层基于模板方法模式"><a href="#AQS-底层基于模板方法模式" class="headerlink" title="AQS 底层基于模板方法模式"></a>AQS 底层基于模板方法模式</h2><p><strong>AQS 的设计基于模板方法模式，自定义同步器时需要重写下面几个 AQS 提供的模板方法</strong>：</p>
<ul>
<li><p><code>isHeldExclusively()</code>：该线程是否正在独占资源。只有用到condition才需要去实现它。</p>
</li>
<li><p><code>tryAcquire(int)</code>：独占方式。尝试获取资源，成功则返回true，失败则返回false。</p>
</li>
<li><p><code>tryRelease(int)</code>：独占方式。尝试释放资源，成功则返回true，失败则返回false。</p>
</li>
<li><p><code>tryAcquireShared(int)</code>：共享方式，尝试获取资源。负数表示失败，0表示成功，但没有剩余可用资源，正数表示成功并且有剩余资源。</p>
</li>
<li><p><code>tryReleaseShared(int)</code>：共享方式。尝试释放资源，如果释放后允许唤醒后续等待结点返回true，否则返回false。</p>
</li>
</ul>
<blockquote>
<p>这些方法虽然都是<code>protected</code>方法，但是它们并没有在AQS具体实现，而是直接抛出异常（这里不使用抽象方法的目的是：避免强迫子类中把所有的抽象方法都实现一遍，减少无用功，这样子类只需要实现自己关心的抽象方法即可，比如 Semaphore 只需要实现 tryAcquire 方法而不用实现其余不需要用到的模版方法）。AQS 类中的其他方法都是 final ，所以无法被其他类使用，只有这几个方法可以被其他类使用。</p>
</blockquote>
<br>

<h2 id="AQS-源码分析"><a href="#AQS-源码分析" class="headerlink" title="AQS 源码分析"></a>AQS 源码分析</h2><h4 id="获取资源"><a href="#获取资源" class="headerlink" title="获取资源"></a>获取资源</h4><p>先来看下 AQS 提供的获取资源方法 <code>acquire</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//尝试获得许可， arg为许可的个数。对于重入锁来说，每次请求1个。</span></span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">    <span class="comment">// 如果tryAcquire 失败，则先使用addWaiter()将当前线程加入同步等待队列</span></span><br><span class="line">    <span class="comment">// 然后继续尝试获得锁</span></span><br><span class="line">    acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">    selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>进入一步看一下tryAcquire()函数。该函数的作用是尝试获得一个许可（资源）。对于 AbstractQueuedSynchronizer 来说，这是一个未实现的抽象函数，默认直接抛出异常。具体实现在子类中。在重入锁，读写锁，信号量等实现中， 都有各自的实现。</p>
<p>如果tryAcquire()成功，则acquire()直接返回成功。如果获取资源失败，就通过 <code>addWaiter(Node.EXCLUSIVE)</code> 方法把这个线程加入同步等待队列中。其中传入的参数代表要插入的Node是独占式的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 生成该线程对应的Node节点</span></span><br><span class="line">    Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line">    Node pred = tail;</span><br><span class="line">    <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line">        node.prev = pred;</span><br><span class="line">        <span class="comment">// 使用CAS尝试将节点插入等待队列尾部 </span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">            pred.next = node;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果等待队列为空或者上述CAS失败，再自旋CAS插入</span></span><br><span class="line">    enq(node);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>由于AQS中会存在多个线程同时争夺资源的情况，因此肯定会出现多个线程同时插入节点的操作，在这里是通过CAS自旋的方式保证了操作的线程安全性。</p>
</blockquote>
<p>将 Node 节点加入等待队列尾部后，处于等待队列的节点是从头结点一个一个去获取资源，具体实现在方法 <code>acquireQueued</code> 中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 以独占的方式不间断地获取已在队列中的线程。</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// 自旋获取锁</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">// 获取前驱节点</span></span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="comment">// 检测当前节点的前驱节点是否为head</span></span><br><span class="line">            <span class="comment">// 也就是说只有等待队列的第二个节点才能获取资源，因为第一个节点已经在运行了，请求锁已成功</span></span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                <span class="comment">// 请求锁成功，会将自己设置为头结点</span></span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="keyword">false</span>; <span class="comment">// 标记请求成功</span></span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 获取锁失败，判断是否要阻塞，直到被unpark</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="keyword">true</span>; <span class="comment">//阻塞中断</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以<strong>结点进入等待队列后，是调用park使它进入阻塞状态的。只有头结点的线程是处于活跃状态的</strong>。</p>
<h4 id="释放资源"><a href="#释放资源" class="headerlink" title="释放资源"></a>释放资源</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">            <span class="comment">// 从队列中唤醒一个等待中的线程（遇到CANCEL节点直接跳过）</span></span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ws = node.waitStatus;</span><br><span class="line">    <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">        compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 得到头结点的后继结点head.next</span></span><br><span class="line">    Node s = node.next;</span><br><span class="line">    <span class="comment">// 如果这个后继结点为空或者状态大于0（节点被取消）</span></span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        s = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 等待队列中所有还有用的结点，都向前移动</span></span><br><span class="line">        <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">            <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                s = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果后继结点不为空，unpark唤醒</span></span><br><span class="line">    <span class="keyword">if</span> (s != <span class="keyword">null</span>)</span><br><span class="line">        LockSupport.unpark(s.thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="以-ReentrantLock-为例"><a href="#以-ReentrantLock-为例" class="headerlink" title="以 ReentrantLock 为例"></a>以 ReentrantLock 为例</h4><p><code>ReentrantLock</code> 默认采用非公平锁，因为考虑获得更好的性能，通过 <code>boolean</code> 来决定是否用公平锁（传入 true 用公平锁）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** Synchronizer providing all implementation mechanics */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Sync sync;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 默认非公平锁</span></span><br><span class="line">    sync = <span class="keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    sync = fair ? <span class="keyword">new</span> FairSync() : <span class="keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>非公平锁在调用 lock 后，首先就会调用 CAS 进行一次抢锁，如果这个时候恰巧锁没有被占用，那么直接就获取到锁返回了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">7316153563782823691L</span>;</span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// CAS抢锁</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">            setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>而公平锁则会直接进行非抢占获取锁资源</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">3000897897090466540L</span>;</span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>非公平锁在 CAS 失败后，和公平锁一样都会调用 AQS 的模板方法 <code>acquire</code> 方法。</p>
<blockquote>
<p>获取资源的入口是acquire(int arg)方法。arg是要获取的资源的个数，在独占模式下始终为1。我们先来看看这个方法的逻辑：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后模板方法会调用使用者（自定义同步器）重写的方法 <code>tryAcquire </code>尝试去获取资源， 如果发现锁这个时候被释放了（state == 0），非公平锁会直接 CAS 抢锁，但是公平锁会判断等待队列是否有线程处于等待状态，如果有则不去抢锁，按顺序排到后面。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// if (!hasQueuedPredecessors() &amp;&amp; compareAndSetState(0, acquires)) &#123; 公平锁实现</span></span><br><span class="line">        <span class="comment">// 公平锁会判断是否有排在自己前面且在等待的线程，而非公平锁继续直接CAS抢锁</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123; <span class="comment">//如果获得锁的是当前线程，则可重入</span></span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="获取资源流程图"><a href="#获取资源流程图" class="headerlink" title="获取资源流程图"></a>获取资源流程图</h4><img src="https://gitee.com/KIMTOU/img/raw/master/20211128203117.jpg" style="zoom: 80%;" />

<blockquote>
<p>state 初始化为 0，表示未锁定状态。A 线程 lock() 时，会调用 tryAcquire()独占该锁并将 state+1。此后，其他线程再 tryAcquire()时就会失败，直到 A 线程 unlock()到 state=0（即释放锁）为止，其它线程才有机会获取该锁。当然，释放锁之前，A 线程自己是可以重复获取此锁的（state 会累加），这就是可重入的概念。但要注意，获取多少次就要释放多少次，这样才能保证 state 是能回到零态的。</p>
</blockquote>
<br>

<blockquote>
<p>参考资料</p>
</blockquote>
<p><a href="http://concurrent.redspider.group/article/02/11.html">11 AQS · 深入浅出Java多线程 (redspider.group)</a></p>
]]></content>
      <categories>
        <category>并发编程</category>
      </categories>
      <tags>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>并发编程的艺术——Java内存模型（指令重排序、happens-before）</title>
    <url>/2021/11/28/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E2%80%94%E2%80%94Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%EF%BC%88%E6%8C%87%E4%BB%A4%E9%87%8D%E6%8E%92%E5%BA%8F%E3%80%81happens-before%EF%BC%89/</url>
    <content><![CDATA[<h3 id="什么是-Java-内存模型"><a href="#什么是-Java-内存模型" class="headerlink" title="什么是 Java 内存模型"></a>什么是 Java 内存模型</h3><p><strong>Java 内存模型<code>Java Memory Model</code>是一种抽象的概念，并不真实存在，它描述了一组规则或规范，通过这组规范定义了程序中共享变量（包括实例字段、静态字段和数组元素）的访问方式</strong>。在 Java 中，所有实例字段、静态字段和数组元素（称为共享变量）都存储在堆内存中，堆内存在线程之间共享。栈中的变量（局部变量、方法定义参数、异常处理器参数）不会在线程之间共享，也就不会有内存可见性的问题，也不受内存模型的影响。</p>
<p><strong>Java 线程之间的通信由 Java 内存模型（JMM）控制，JMM 决定了一个线程对共享变量的写入何时对另一个线程可见</strong>。</p>
<h4 id="Java-内存模型的组成部分"><a href="#Java-内存模型的组成部分" class="headerlink" title="Java 内存模型的组成部分"></a>Java 内存模型的组成部分</h4><p>JMM 定义了线程和主内存之间的抽象关系：</p>
<p><strong>线程之间的共享变量存储在主内存（Main Memoery）中，每个线程都有一个私有的本地内存（Local Memoery），存储了该线程以读 / 写共享变量的副本</strong>。线程对共享变量的所有操作都必须在本地内存中进行，而不能直接对主内存进行操作。并且每个线程不能访问其他线程的工作内存。<strong>JMM 通过控制主内存与每个线程的本地内存之间的交互，来提供内存可见性保证</strong>。</p>
<img src="https://gitee.com/KIMTOU/img/raw/master/20211128203510.jpg" style="zoom: 50%;" />

<blockquote>
<p>本地内存是 JMM 的一个抽象概念，并不真实存在。它涵盖了缓存、写缓冲区、寄存器等。</p>
</blockquote>
<p>Java 中的 <code>volatile</code> 关键字可以保证多线程操作共享变量的可见性以及禁止指令重排序，<code>synchronized</code> 关键字不仅保证可见性，同时也保证了原子性（互斥性）。在更底层，JMM 通过内存屏障来实现内存的可见性以及禁止重排序。</p>
<br>

<h4 id="JMM-与-Java-内存区域划分的区别与联系"><a href="#JMM-与-Java-内存区域划分的区别与联系" class="headerlink" title="JMM 与 Java 内存区域划分的区别与联系"></a>JMM 与 Java 内存区域划分的区别与联系</h4><ul>
<li><p>区别：</p>
<p>两者是不同的概念层次。<strong>JMM 是抽象的，它描述了一组规则，通过这个规则来控制各个变量的访问方式，围绕原子性、有序性、可见性等展开的</strong>。而 Java 运行时内存的划分是具体的，是 JVM 运行 Java 程序时，必要的内存划分。</p>
</li>
<li><p>联系：</p>
<p><strong>都存在私有数据区域和共享数据区域</strong>。一般来说，JMM 中的主内存属于共享数据区域，它是包含了堆和方法区；同样，JMM 中的本地内存属于私有数据区域，包含了程序计数器、本地方法栈、虚拟机栈。</p>
</li>
</ul>
<blockquote>
<p><a href="http://concurrent.redspider.group/article/02/6.html">Java内存模型基础知识</a></p>
</blockquote>
<br>

<h3 id="指令重排序"><a href="#指令重排序" class="headerlink" title="指令重排序"></a>指令重排序</h3><p>在执行程序时，为了提高性能，编译器和处理器常常会对指令序列进行重新排序。即只要程序的最终结果与它顺序化情况的结果相等，那么指令的执行顺序可以与代码顺序不一致。</p>
<p>指令重排一般分为以下三种：</p>
<ul>
<li><strong>编译器优化重排序</strong>：编译器在<strong>不改变单线程程序语义</strong>的前提下，可以重新安排语句的执行顺序。</li>
<li><strong>指令级并行重排序</strong>：现代处理器采用了指令级并行技术来将多条指令重叠执行。如果<strong>不存在数据依赖性</strong>(即后一个执行的语句无需依赖前面执行的语句的结果)，处理器可以改变语句对应的机器指令的执行顺序。</li>
<li><strong>内存系统重排序</strong>：由于处理器使用缓存和读写缓冲区，这使得加载(load)和存储(store)操作看上去可能是在乱序执行。</li>
</ul>
<p>编译器优化重排序属于编译器重排序，指令并行重排序和内存系统重排序属于处理器重排序。</p>
<p><strong>指令重排序可以保证单个线程串行语义一致，但是没有义务保证多线程间的语义也一致</strong>。这些重排序可能会导致多线程程序出现内存可见性问题。</p>
<h4 id="指令重排序必须满足什么条件"><a href="#指令重排序必须满足什么条件" class="headerlink" title="指令重排序必须满足什么条件"></a>指令重排序必须满足什么条件</h4><ul>
<li><strong>as-if-serial语义：即无论怎么重排序，都不能够改变单线程程序运行的结果</strong>。</li>
<li><strong>遵守数据依赖性：即无论怎么重排序，都不能够改变存在数据依赖性的两个操作的执行顺序</strong>。</li>
</ul>
<h5 id="as-if-serial-语义"><a href="#as-if-serial-语义" class="headerlink" title="as-if-serial 语义"></a>as-if-serial 语义</h5><p>无论编译器和处理器如何进行重排序，单线程程序的执行结果不能被改变。</p>
<h5 id="数据依赖性"><a href="#数据依赖性" class="headerlink" title="数据依赖性"></a>数据依赖性</h5><p><strong>如果两个操作访问同一个变量，且这两个操作中有一个为写操作，此时这两个操作之间就存在数据依赖性</strong>。只要重排序这两个操作的执行顺序，程序的执行结果就会被改变。编译器和处理器在重排序时，会遵守数据依赖性，编译器和处理器不会改变存在数据依赖关系的两个操作的执行顺序，因为这种重排序会改变执行结果。</p>
<p>数据依赖性仅针对单个处理器中执行的指令序列和单个线程中执行的操作。多线程之间的数据依赖性不被编译器和处理器考虑。</p>
<hr>
<br>

<h3 id="happens-before"><a href="#happens-before" class="headerlink" title="happens-before"></a>happens-before</h3><p><strong>happens-before 关系的定义如下</strong>：</p>
<ol>
<li>如果一个操作 happens-before 另一个操作，那么第一个操作的执行结果将对第二个操作可见，并且第一个操作的执行顺序排在第二个操作之前。</li>
<li><strong>两个操作之间存在happens-before关系，并不意味着Java平台的具体实现必须要按照happens-before关系指定的顺序来执行。如果重排序之后的执行结果，与按happens-before关系来执行的结果一致，那么JMM也允许这样的重排序。</strong></li>
</ol>
<p><strong>在 JMM 中，如果一个操作执行的结果需要对另一个操作可见，那么这两个操作之间必须要存在 happens-before 关系</strong>。如果操作A的执行结果不需要对操作B可见，而且重排序之后的执行结果与按happens-before关系来执行的结果一致，那么 JMM 允许这种重排序。</p>
<p>happens-before 关系本质上和 as-if-serial 语义是一回事：</p>
<ul>
<li>as-if-serial 语义保证单线程内程序的执行结果不被重排序改变，happens-before 关系保证正确同步的多线程程序的执行结果不被重排序改变。</li>
<li>happens-before 和 as-if-serial 的作用都是在不改变程序执行结果的前提下，提高程序执行的并行度。</li>
</ul>
<h4 id="happens-before规则（先行发生原则）"><a href="#happens-before规则（先行发生原则）" class="headerlink" title="happens-before规则（先行发生原则）"></a>happens-before规则（先行发生原则）</h4><ul>
<li>程序顺序规则：一个线程中的每一个操作，happens-before于该线程中的任意后续操作（按照代码顺序）。</li>
<li>监视器锁规则：对一个锁的解锁，happens-before于随后对这个锁的加锁。即一个unlock操作先行发生于后面对同一个锁的lock操作。</li>
<li>volatile变量规则：对一个volatile域的写，happens-before于任意后续对这个volatile域的读。</li>
<li>传递性：如果A happens-before B，且 B happens-before C，那么 A happens-before C。</li>
<li>start() 规则：如果线程A执行操作ThreadB.start() 启动线程B，那么A线程的ThreadB.start() 操作happens-before于线程B中的任意操作。</li>
<li>join() 规则：如果线程A执行操作ThreadB.join() 并成功返回，那么线程B中的任意操作happens-before于线程A从ThreadB.join()操作成功返回。</li>
</ul>
<br>

<blockquote>
<p>参考资料</p>
</blockquote>
<p><strong>《Java 并发编程的艺术》</strong></p>
]]></content>
      <categories>
        <category>并发编程</category>
      </categories>
      <tags>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解volatile底层原理</title>
    <url>/2021/11/28/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3volatile%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<p>volatile 是轻量级的 synchronized，一般作用于变量。相比于<code>synchronized</code>关键字，<code>volatile</code>关键字的执行成本更低，因为它不会引起线程上下文的切换和调度。</p>
<p><strong>volatile主要有以下两个功能</strong>：</p>
<ul>
<li>保证共享变量的<strong>内存可见性（即当一个线程修改一个共享变量时，另一个线程能读到这个修改的值）</strong>。</li>
<li><strong>禁止指令重排序</strong></li>
</ul>
<p><strong>volatile 的用途</strong>：</p>
<p>从volatile的内存语义上来看，volatile可以保证内存可见性且禁止重排序。</p>
<p>在保证内存可见性这一点上，volatile有着与锁相同的内存语义，所以可以作为一个“轻量级”的锁来使用。但由于<strong>volatile仅仅保证对单个volatile变量的读/写具有原子性</strong>，而锁可以保证整个<strong>临界区代码</strong>的执行具有原子性。所以<strong>在功能上，锁比volatile更强大；在性能上，volatile更有优势</strong>。</p>
<br>

<h3 id="volatile的特性"><a href="#volatile的特性" class="headerlink" title="volatile的特性"></a>volatile的特性</h3><p><strong><code>volatile</code>可以保证可见性和有序性</strong>。</p>
<ul>
<li><p>可见性：<code>volatile</code>可以保证不同线程对共享变量进行操作时的可见性。即当一个线程修改了共享变量时，另一个线程可以读取到共享变量被修改后的值。 </p>
</li>
<li><p>有序性：<code>volatile</code>会通过禁止指令重排序进而保证有序性。 </p>
</li>
<li><p>原子性：对于单个的<code>volatile</code>修饰的变量的读/写是可以保证原子性的，但对于<code>v++</code>这种复合操作并不能保证原子性。所以说<code>volatile</code>不具备原子性。</p>
<blockquote>
<p><strong>为什么说 volatile 不保证原子性？</strong></p>
<p>Java中只有对基本类型变量的赋值和读取是原子操作，如 i = 1的赋值操作，但是像 j = i 或者 i++ 这样的操作都不是原子操作，因为他们都进行了多次原子操作，比如先读取 i 的值，再将 i 的值赋值给 j，两个原子操作加起来就不是原子操作了。</p>
<p>比如 i++ ，i = i + 1 分为三个操作</p>
<ul>
<li>读取 i 的值</li>
<li>自增 i 的值</li>
<li>把 i 的值写回内存</li>
</ul>
<p>这个过程中可能线程A读取了 i 的值，然后线程切换，即使是被volatile修饰，主存中变量的值也还没变化，所以另一个线程B也读取了 i 未被修改的值，之后线程切换回A，进行 + 1 操作，写回内存；而线程B写回内存会把线程A修改的值覆盖。</p>
<p>所以即便是volatile具有可见性，也不能保证对它修饰的变量具有原子性。</p>
<p>可以通过 synchronized和Lock实现原子性。因为synchronized和Lock能够保证任一时刻只有一个线程访问该代码块。</p>
</blockquote>
</li>
</ul>
<br>

<h3 id="volatile实现内存可见性原理"><a href="#volatile实现内存可见性原理" class="headerlink" title="volatile实现内存可见性原理"></a>volatile实现内存可见性原理</h3><p><code>volatile</code>可以保证内存可见性的关键是<code>volatile</code>的读/写实现了缓存一致性。</p>
<p><strong>缓存一致性协议 MESI</strong> 的主要内容为： </p>
<p>多个CPU从主内存读取同一个数据到各自的高速缓存，当其中某个CPU修改了缓存里的数据，该数据会<strong>马上同步会主内存</strong>，其他CPU通过<strong>总线嗅探机制</strong>可以感知到数据的变化从而将自己缓存里的数据失效，然后重新从主内存读取最新数据。</p>
<p>那 volatile 是如何实现缓存一致性的呢？可以发现通过<code>volatile</code>修饰的变量，生成汇编指令时会比普通的变量多出一个 <strong><code>Lock</code> 前缀指令</strong>，这个<code>Lock</code>指令就是<code>volatile</code>关键字可以保证内存可见性的关键，它主要有两个作用：</p>
<ul>
<li>将当前处理器缓存的数据刷新到主内存。 </li>
<li>刷新到主内存时会使得其他处理器缓存的该内存地址的数据无效。 </li>
</ul>
<br>

<h3 id="volatile实现有序性原理"><a href="#volatile实现有序性原理" class="headerlink" title="volatile实现有序性原理"></a>volatile实现有序性原理</h3><blockquote>
<p>重排序可以提高代码的执行效率，但在多线程程序中可能导致程序的运行结果不正确，那<code>volatile</code>是如何解决这一问题的呢？</p>
</blockquote>
<p><strong>为了实现<code>volatile</code>的内存语义，编译器在生成字节码时会通过插入内存屏障来禁止指令重排序</strong>。</p>
<p>内存屏障：内存屏障是一种CPU指令，它的作用是对该指令前和指令后的一些操作产生一定的约束，保证一些操作按顺序执行。</p>
<br>

<h3 id="volatile-内存语义的实现"><a href="#volatile-内存语义的实现" class="headerlink" title="volatile 内存语义的实现"></a>volatile 内存语义的实现</h3><p>Java内存模型对编译器指定的<code>volatile</code>重排序规则为：</p>
<ul>
<li>当第一个操作是<code>volatile</code>读时，无论第二个操作是什么都不能进行重排序。 </li>
<li>当第二个操作是<code>volatile</code>写时，无论第一个操作是什么都不能进行重排序。 </li>
<li>当第一个操作是<code>volatile</code>写，第二个操作为<code>volatile</code>读时，不能进行重排序。</li>
</ul>
<p>为了实现 volatile 的内存语义，编译器在<strong>生成字节码时</strong>，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序。编译器选择了一个<strong>比较保守的 JMM 内存屏障插入策略</strong>，这样可以保证在任何处理器平台，任何程序中都能得到正确的volatile内存语义。这个策略是：</p>
<ul>
<li>在每个 volatile 写操作的前面插入一个 StoreStore 屏障。</li>
<li>在每个 volatile 写操作的后面插入一个 StoreLoad 屏障。</li>
<li>在每个 volatile 读操作的后面插入一个 LoadLoad 屏障。</li>
<li>在每个 volatile 读操作的后面插入一个 LoadStore 屏障。</li>
</ul>
<p><img src="https://gitee.com/KIMTOU/img/raw/master/20211128203926.png"></p>
<h4 id="什么是内存屏障"><a href="#什么是内存屏障" class="headerlink" title="什么是内存屏障"></a>什么是内存屏障</h4><p>JVM是怎么限制处理器的重排序的呢？它是通过<strong>内存屏障</strong>来实现的。</p>
<p>什么是内存屏障？硬件层面，内存屏障分两种：读屏障（Load Barrier）和写屏障（Store Barrier）。</p>
<p>内存屏障有两个作用：</p>
<ol>
<li>阻止屏障两侧的指令重排序；</li>
<li>强制把写缓冲区/高速缓存中的脏数据等写回主内存，或者让缓存中相应的数据失效。</li>
</ol>
<blockquote>
<p>注意这里的缓存主要指的是CPU缓存，如L1，L2等</p>
</blockquote>
<p>JMM 把内存屏障指令分为4类，如下表所示：</p>
<table>
<thead>
<tr>
<th>屏障类型</th>
<th>指令示例</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>LoadLoad Barriers</td>
<td>Load1;LoadLoad;Load2</td>
<td>保证Load1数据的读取先于Load2及后续所有读取指令的执行</td>
</tr>
<tr>
<td>StoreStore Barriers</td>
<td>Store1;StoreStore;Store2</td>
<td>保证Store1数据刷新到主内存先于Store2及后续所有存储指令</td>
</tr>
<tr>
<td>LoadStore Barriers</td>
<td>Load1;LoadStore;Store2</td>
<td>保证Load1数据的读取先于Store2及后续的所有存储指令刷新到主内存</td>
</tr>
<tr>
<td>StoreLoad Barriers</td>
<td>Store1;StoreLoad;Load2</td>
<td>保证Store1数据刷新到主内存先于Load2及后续所有读取指令的执行。StoreLoad Barriers同时具备其他三个屏障的作用，它会使得该屏障之前的所有内存访问指令完成之后，才会执行该屏障之后的内存访问命令。</td>
</tr>
</tbody></table>
<p>StoreLoad Barriers 的开销是四种屏障中最大的，因为处理器通常要把写缓冲区中的数据全部刷新到内存中。这个屏障是个万能屏障，兼具其它三种内存屏障的功能</p>
<br>

<h3 id="双重检查锁下的重排序问题"><a href="#双重检查锁下的重排序问题" class="headerlink" title="双重检查锁下的重排序问题"></a>双重检查锁下的重排序问题</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 双重校验锁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DoubleLock</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> DoubleLock instance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">DoubleLock</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DoubleLock <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 由于 as-if-serial 语义没有规定这两行代码不能重排序</span></span><br><span class="line"><span class="comment">             * 21 invokespecial #4 &lt;cn/tojintao/singleton/DoubleLock.&lt;init&gt; : ()V&gt;</span></span><br><span class="line"><span class="comment">             * 24 putstatic #2 &lt;cn/tojintao/singleton/DoubleLock.instance : Lcn/tojintao/singleton/DoubleLock;&gt;</span></span><br><span class="line"><span class="comment">             *</span></span><br><span class="line"><span class="comment">             * 使用 volatile后，由于插入内存屏障禁止了指令重排序，避免了对象半初始化问题</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">synchronized</span> (DoubleLock.class)&#123;</span><br><span class="line">                <span class="keyword">if</span>(instance == <span class="keyword">null</span>)</span><br><span class="line">                    instance = <span class="keyword">new</span> DoubleLock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        DoubleLock instance = DoubleLock.getInstance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>为什么使用两次 if 检查？</strong></p>
<p>假如有两个线程，线程A在进入到 synchronized 同步代码块之后，在还没有生成 Singleton 对象前发生线程切换，此时线程B判断 instance == null 为 true，然后获取不到锁阻塞发生线程切换，切换到线程A，线程A将变量初始化后，退出同步代码块，线程切换，线程B进入同步代码块后，会再判断一下 instance 的值，否则会再次进行new 初始化，这就是双重检查锁的必要所在。</p>
<p><strong>为什么使用<code>volatile</code>？</strong></p>
<p>采用 volatile 关键字修饰也是很有必要的，singleton = new Singleton()，<code>new</code>对象时并不是一个完整的<strong>原子性操作</strong>，而是分为三步执行： </p>
<ol>
<li>为 singleton 分配内存空间 </li>
<li>执行构造方法，初始化 singleton </li>
<li>将 singleton 指向分配的内存地址 </li>
</ol>
<p>但是由于 JVM 具有指令重排的特性，执行顺序有可能变成 1-3-2。指令重排在单线程环境下不会出现问题，但是在多线程环境下会导致一个线程获得还没有初始化的实例。例如，线程 T1 执行了 1 和 3，此时线程 T2 调用 getInstance() 后发现 singleton 不为空，因此返回 singleton ，但此时 singleton 还未被初始化，就会导致线程 T2 使用了未初始化的对象。</p>
<p>使用 volatile 可以禁止 JVM 的指令重排，保证在多线程环境下也能正常运行。</p>
<br>

<blockquote>
<p>参考资料</p>
</blockquote>
<p><a href="http://concurrent.redspider.group/article/02/8.html">8 volatile · 深入浅出Java多线程 (redspider.group)</a></p>
]]></content>
      <categories>
        <category>并发编程</category>
      </categories>
      <tags>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>synchronized底层原理与锁升级</title>
    <url>/2021/11/28/synchronized%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E4%B8%8E%E9%94%81%E5%8D%87%E7%BA%A7/</url>
    <content><![CDATA[<p><strong><code>synchronized</code> 关键字解决的是多个线程之间访问资源的同步性，即保证线程同步，<code>synchronized</code>关键字可以保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行。</strong></p>
<p>另外，在 Java 早期版本中，<code>synchronized</code> 属于 <strong>重量级锁</strong>，效率低下。<strong>为什么呢？</strong></p>
<p>因为监视器锁（monitor）是依赖于底层的操作系统的 <code>Mutex Lock</code> 来实现的，Java 的线程是映射到操作系统的原生线程之上的。如果要挂起或者唤醒一个线程，都需要操作系统帮忙完成，而操作系统实现线程之间的切换时需要从用户态转换到内核态，这个状态之间的转换需要相对比较长的时间，时间成本相对较高。</p>
<p>在 Java 6 之后 Java 官方对从 JVM 层面对 <code>synchronized</code> 较大优化，所以现在的 <code>synchronized</code> 锁效率也优化得很不错了。JDK1.6 对锁的实现引入了大量的优化，如自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁等技术来减少锁操作的开销。</p>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>synchronized 实现同步的基础：<strong>Java中的每一个对象都可以作为锁</strong>。具体表现为以下 3 种形式：</p>
<ol>
<li><strong>修饰实例方法</strong>，锁是当前实例对象</li>
<li><strong>修饰静态方法</strong>，锁是当前类的Class对象</li>
<li><strong>修饰代码块</strong>，锁是 synchronized 括号里配置的对象</li>
</ol>
<p>当一个线程试图访问同步代码块时，它首先必须获得锁，退出或抛出异常时必须释放锁。</p>
<br>

<h3 id="底层原理"><a href="#底层原理" class="headerlink" title="底层原理"></a>底层原理</h3><p><strong>JVM 基于进入和退出 Monitor 对象来实现方法同步和代码块同步</strong>，但两者实现细节不一样。<strong>代码块同步是使用 monitorenter 和 monitorexit 指令实现的，而方法同步是通过方法 flags 标志</strong>，方法同步同样可以使用这两个指令来实现。</p>
<h4 id="修饰代码块"><a href="#修饰代码块" class="headerlink" title="修饰代码块"></a>修饰代码块</h4><p><strong>monitorenter 指令是在编译后插入到同步代码块的开始位置，而 monitorexit 是插入到方法结束处和异常处</strong>。</p>
<blockquote>
<p><strong>为什么会有两个monitorexit呢？</strong></p>
<p>这个主要是防止在同步代码块中线程因异常退出，而锁没有得到释放，这必然会造成死锁（等待的线程永远获取不到锁）。因此最后一个monitorexit是保证在异常情况下，锁也可以得到释放，避免死锁。</p>
</blockquote>
<p>任何对象都内置了一个 monitor 对象，当且一个 monitor 被持有后，它将处于锁定状态。<strong>线程执行到 monitorenter 指令时，将会尝试获取对象所对应的 monitor 的所有权，即尝试获得对象的锁</strong>。</p>
<p>在执行 <code>monitorenter</code> 时，会尝试获取对象的锁，如果锁的计数器为 0，则表示锁可以被获取，获取后将锁计数器设为 1，也就是 +1。在执行 <code>monitorexit</code> 指令后，将锁计数器设为 0，表明锁被释放。如果获取对象锁失败，那当前线程就要阻塞等待，直到锁被另外一个线程释放为止。</p>
<h4 id="修饰方法"><a href="#修饰方法" class="headerlink" title="修饰方法"></a>修饰方法</h4><p><strong>方法同步是通过在方法 flags 上添加  <code>ACC_SYNCHRONIZED</code> 标识</strong>，该标识指明了该方法是一个同步方法。 <code>ACC_SYNCHRONIZED</code> 会去隐式调用刚才的两个指令：monitorenter 和 monitorexit 。该标记表明线程进入该方法时，需要 monitorenter，退出该方法时需要 monitorexit 。</p>
<p><strong>不过两者的本质都是对对象监视器 monitor 的争夺。</strong></p>
<h4 id="Monitor-对象"><a href="#Monitor-对象" class="headerlink" title="Monitor 对象"></a>Monitor 对象</h4><blockquote>
<p>在 Java 虚拟机(HotSpot)中，Monitor 是基于 C++实现的，由ObjectMonitor实现的。每个对象中都内置了一个 <code>ObjectMonitor</code>对象。</p>
<p>另外，**<code>wait/notify</code>等方法也依赖于<code>monitor</code>对象，这就是为什么只有在同步代码块或同步方法中才能调用<code>wait/notify</code>等方法，否则会抛出<code>java.lang.IllegalMonitorStateException</code>的异常的原因**。</p>
</blockquote>
<p>Monitor 可以理解为一个同步工具或一种同步机制，通常被描述为一个对象。每一个 Java 对象就有一把看不见的锁，称为内部锁或者 Monitor 锁。</p>
<h4 id="Java-对象头"><a href="#Java-对象头" class="headerlink" title="Java 对象头"></a>Java 对象头</h4><p>在HotSpot虚拟机中，Java对象在内存中的布局大致可以分为三部分：<strong>对象头</strong>、<strong>实例数据</strong>、<strong>填充对齐</strong>。 </p>
<p><strong>synchronized 用的锁是存在 Java 对象头里的，具体来说是存在 Mark Word 中</strong>。如果对象是数组类型，则虚拟机用 3 个字宽（Word）存储对象头，如果对象是非数组类型，则用 2 字宽存储对象头。在32位虚拟机中，1 字宽等于 4 字节，即 32 bit。在64位虚拟机中，1 字宽等于 8 字节，即 64 bit。</p>
<table>
<thead>
<tr>
<th>内容</th>
<th>说明</th>
<th>长度</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Mark Word</strong></td>
<td>存储对象的hashCode、分代年龄和锁标记位</td>
<td>32/64bit</td>
</tr>
<tr>
<td><strong>Class MetadataAddress</strong></td>
<td>存储到对象类型数据的指针</td>
<td>32/64bit</td>
</tr>
<tr>
<td><strong>Array length</strong></td>
<td>数组的长度（如果当前对象是数组）</td>
<td>32/32bit</td>
</tr>
</tbody></table>
<p>Hotspot 对象头主要包括两部分数据：<strong>Mark Word(标记字段)和Klass Pointer(类型指针)</strong></p>
<ul>
<li><strong>Mark Word</strong>：<strong>默认存储对象的 HashCode、分代年龄和锁标志位信息</strong>。这些信息都是与对象自身定义无关的数据，所以Mark Word被设计成一个非固定的数据结构以便在极小的空间内存存储尽量多的数据。它会根据对象的状态复用自己的存储空间，也就是说<strong>在运行期间Mark Word里存储的数据会随着锁标志位的变化而变化</strong>。</li>
<li><strong>Klass Point</strong>：<strong>表示的是类型指针，对象指向它的类元数据的指针</strong>，虚拟机通过这个指针来确定这个对象是哪个类的实例。</li>
</ul>
<p>下面我们以 32 位虚拟机为例，来看一下其 Mark Word 的字节具体是如何分配的。</p>
<p><strong>无锁状态</strong>：对象头开辟 25bit 的空间用来存储对象的 hashcode ，4bit 用于存放对象分代年龄，1bit 用来存放是否偏向锁的标识位，2bit 用来存放锁标识位为01。</p>
<p><strong>偏向锁</strong>： 在偏向锁中划分更细，还是开辟 25bit 的空间，其中23bit 用来存放线程ID，2bit 用来存放 Epoch，4bit 存放对象分代年龄，1bit 存放是否偏向锁标识， 0表示无锁，1表示偏向锁，锁的标识位还是01。</p>
<p><strong>轻量级锁</strong>：在轻量级锁中直接开辟 30bit 的空间存放指向栈中锁记录的指针，2bit 存放锁的标志位，其标志位为00。</p>
<p><strong>重量级锁</strong>： 在重量级锁中和轻量级锁一样，30bit 的空间用来存放指向重量级锁的指针，2bit 存放锁的标识位，为10。</p>
<p><strong>GC 标记</strong>： 开辟30bit 的内存空间却没有占用，2bit 空间存放锁标志位为11。</p>
<blockquote>
<p>其中无锁和偏向锁的锁标志位都是 01，只是在前面的 1 bit 区分了这是无锁状态还是偏向锁状态。</p>
</blockquote>
<br>

<h3 id="锁升级"><a href="#锁升级" class="headerlink" title="锁升级"></a>锁升级</h3><p><strong>Java 1.6 为了减少获得锁和释放锁带来的性能消耗</strong>，引入了 “偏向锁” 和 “轻量级锁“ 。锁的状态总共有 4 种，级别由低到高依次为：<strong>无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态</strong>。这四种状态会随着竞争情况逐渐升级，锁可以升级但不能降级，意味着偏向锁升级成轻量级锁后不能降级成偏向锁。这种锁升级却不能降级的策略，<strong>目的是为了提高获得锁和释放锁的效率</strong>。</p>
<h4 id="无锁"><a href="#无锁" class="headerlink" title="无锁"></a>无锁</h4><p>无锁即没有对资源进行锁定，所有的线程都能访问并修改同一个资源，但同时只有一个线程能修改成功。</p>
<p>无锁的特点就是在循环内进行修改操作，线程会不断的尝试修改共享资源，如果没有冲突就修改成功并退出，否则就会继续循环尝试。CAS 就是无锁的实现。</p>
<h4 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h4><h5 id="为什么引入偏向锁？"><a href="#为什么引入偏向锁？" class="headerlink" title="为什么引入偏向锁？"></a>为什么引入偏向锁？</h5><p>HotSpot的作者经过以往的研究发现大多数情况下<strong>锁不仅不存在多线程竞争，而且总是由同一线程多次获得</strong>，为了让线程获得锁的代价更低而引入了偏向锁。它的出现是为了解决只有在一个线程执行同步时提高性能。</p>
<h5 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h5><p><strong>当一个线程首次访问同步块并获取锁时，会在对象头和栈帧中的锁记录里存储锁偏向的线程ID</strong>。当下次该线程进入这个同步块时，会去检查锁的Mark Word里面是不是放的自己的线程ID。</p>
<p>如果是，表明该线程已经获得了锁，<strong>以后该线程在进入和退出同步块时不需要花费CAS操作来加锁和解锁（轻量级锁需要）</strong> ；如果不是，就代表有另一个线程来竞争这个偏向锁。这个时候会尝试使用CAS来替换Mark Word里面的线程ID为新线程的ID，这个时候要分两种情况：</p>
<ul>
<li>成功，表示之前的线程不存在了， Mark Word里面的线程ID为新线程的ID，锁不会升级，仍然为偏向锁；</li>
<li><strong>失败，表示之前的线程仍然存在，那么暂停之前的线程，设置偏向锁标识为0，并设置锁标志位为00，升级为轻量级锁，会按照轻量级锁的方式进行竞争锁。</strong></li>
</ul>
<h5 id="撤销偏向锁"><a href="#撤销偏向锁" class="headerlink" title="撤销偏向锁"></a>撤销偏向锁</h5><p><strong>偏向锁只有遇到其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁</strong>。偏向锁的撤销，需要等待全局安全点，即在这个时间点上没有正在执行的字节码。它会先暂停拥有偏向锁的线程，然后检查持有偏向锁的线程是否活着。</p>
<p>偏向锁升级成轻量级锁时，会暂停拥有偏向锁的线程，重置偏向锁标识，这个过程看起来容易，实则开销还是很大的，大概的过程如下：</p>
<ol>
<li>在一个安全点（在这个时间点上没有字节码正在执行）停止拥有锁的线程。</li>
<li>遍历线程栈，如果存在锁记录的话，需要修复锁记录和Mark Word，使其变成无锁状态。</li>
<li>唤醒被停止的线程，将当前锁升级成轻量级锁。</li>
</ol>
<img src="https://gitee.com/KIMTOU/img/raw/master/20211128204941.png" style="zoom:80%;" />

<p>如果应用程序里所有的锁通常处于竞争状态，那么偏向锁就会是一种累赘，对于这种情况，我们可以一开始就把偏向锁这个默认功能给关闭，<code>-XX:UseBiasedLocking=false</code>，那么程序默认会进入轻量级锁状态。</p>
<h4 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h4><p>轻量级锁是指当前锁是偏向锁的时候，资源被另外的线程所访问，那么偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，线程不会阻塞，从而提高性能。</p>
<p>线程在执行同步块之前，JVM会先在当前线程的栈帧中创建用于存储锁记录的空间，并将对象头中的 Mark Word 复制到锁记录中，称为Displaced Mark Word。<strong>然后线程尝试使用 CAS 将对象头中的Mark Word替换为指向锁记录的指针。如果成功，当前线程获得锁；如果失败，表示Mark Word已经被替换成了其他线程的锁记录，说明在与其它线程竞争锁，当前线程就尝试使用自旋来获取锁</strong>，若自旋失败，那么这个线程会阻塞。同时这个锁就会<strong>升级成重量级锁</strong>。</p>
<blockquote>
<p>自旋：不断尝试去获取锁，一般用循环来实现。</p>
</blockquote>
<h5 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h5><p>获取轻量级锁失败后，虚拟机为了避免线程真实地在操作系统层面挂起，使用了自旋锁进行优化。</p>
<blockquote>
<p>互斥同步对性能最大的影响就是阻塞的实现，因为挂起线程/恢复线程的操作都需要转入内核态中完成（用户态转换到内核态会耗费时间）。</p>
</blockquote>
<p><strong>一般线程持有锁的时间都不是太长，所以如果直接挂起线程是得不偿失的。 所以让线程不断自旋，即不停地循环判断锁是否能够被成功获取。</strong></p>
<p>自旋是需要消耗CPU的，如果一直获取不到锁的话，那该线程就一直处在自旋状态，白白浪费CPU资源。解决这个问题最简单的办法就是指定自旋的次数，例如让其循环10次，如果还没获取到锁就进入阻塞状态。</p>
<p>但是JDK采用了更聪明的方式——<strong>适应性自旋锁</strong>，简单来说就是线程如果自旋成功了，则下次自旋的次数会更多，如果自旋失败了，则自旋的次数就会减少。</p>
<p>自旋也不是一直进行下去的，如果自旋到一定程度（和JVM、操作系统相关），依然没有获取到锁，称为自旋失败，那么这个线程会阻塞。同时这个锁就会<strong>升级成重量级锁</strong>。</p>
<p><strong>轻量级锁的释放：</strong></p>
<p><strong>在释放轻量级锁时，当前线程会使用CAS操作将Displaced Mark Word的内容复制回锁的Mark Word里面</strong>。如果没有发生竞争，那么这个复制的操作会成功。如果有其他线程因为自旋多次导致轻量级锁升级成了重量级锁，那么CAS操作会失败，此时会释放锁并唤醒被阻塞的线程（其他线程重新争夺锁访问同步块）。</p>
<h4 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h4><p>重量级锁依赖于操作系统的互斥量（mutex） 实现的，而操作系统中线程间状态的转换需要相对比较长的时间，所以重量级锁效率很低，但被阻塞的线程不会消耗CPU。</p>
<p><strong>当锁处在重量级锁状态下，其他线程试图获取锁时，都会被阻塞住，当持有锁的线程释放锁之后会唤醒这些线程，被唤醒的线程就会进行新一轮的夺锁之争。</strong></p>
<h4 id="锁对比"><a href="#锁对比" class="headerlink" title="锁对比"></a>锁对比</h4><table>
<thead>
<tr>
<th>锁</th>
<th>优点</th>
<th>缺点</th>
<th>适用场景</th>
</tr>
</thead>
<tbody><tr>
<td>偏向锁</td>
<td>加锁和解锁不需要额外的消耗，和执行非同步方法相比仅存在纳秒级的差距</td>
<td>如果线程间存在锁竞争，会带来额外的锁撤销的消耗</td>
<td>适用于只有一个线程访问同步块场景</td>
</tr>
<tr>
<td>轻量级锁</td>
<td>竞争的线程不会阻塞，提高了程序的响应速度</td>
<td>如果始终得不到锁竞争的线程，使用自旋会消耗CPU</td>
<td>追求响应时间，同步块执行速度非常快</td>
</tr>
<tr>
<td>重量级锁</td>
<td>线程竞争不使用自旋，不会消耗CPU</td>
<td>线程阻塞，响应时间缓慢</td>
<td>追求吞吐量，同步块执行时间较长</td>
</tr>
</tbody></table>
<h3 id="其他优化"><a href="#其他优化" class="headerlink" title="其他优化"></a>其他优化</h3><ul>
<li><p><strong>锁消除</strong></p>
<p>对于线程的私有变量，不存在并发问题，没有必要加锁，即使加锁编译后，也会去掉。</p>
</li>
<li><p><strong>锁粗化</strong></p>
<p>当一个循环中存在加锁操作时，可以将加锁操作提到循环外面执行，一次加锁代替多次加锁，提升性能。</p>
</li>
</ul>
<br>

<h3 id="synchronized三大特性"><a href="#synchronized三大特性" class="headerlink" title="synchronized三大特性"></a>synchronized三大特性</h3><ul>
<li><strong>原子性</strong>：一个或多个操作要么全部执行成功，要么全部执行失败，过程不会被任何因素打断。synchronized 关键字可以保证只有一个线程拿到锁，访问共享资源。Java内存模型提供了字节码指令<code>monitorenter</code>和<code>monitorexit</code> 来支持。</li>
<li><strong>可见性</strong>：当一个线程对共享变量进行修改后，其他线程可以立刻看到。执行synchronized 时，会对应执行 lock 、unlock原子操作，<strong>并且在解锁之前必须先把共享变量同步回主内存中</strong>，从而保证可见性。 </li>
<li><strong>有序性</strong>：程序的执行顺序会按照代码的先后顺序执行。synchronized 修饰的代码，同一时间只能被同一线程访问，那么可以认为是单线程执行的，由于as-if-serial语义是指不管怎么重排序（编译器和处理器为了提高并行度），单线程程序的执行结果都不能被改变。编译器和处理器无论如何优化，都必须遵守as-if-serial语义。所以synchronized 可以保证有序性。</li>
</ul>
<br>

<h3 id="synchronized-和-volatile-的区别"><a href="#synchronized-和-volatile-的区别" class="headerlink" title="synchronized 和 volatile 的区别"></a>synchronized 和 volatile 的区别</h3><ul>
<li><strong><code>volatile</code>关键字主要用于解决共享变量在多个线程之间的可见性，而 <code>synchronized</code> 关键字解决的是多个线程之间访问资源的同步性。</strong></li>
<li><strong><code>volatile</code> 关键字只能用于变量，而 <code>synchronized</code> 关键字可以修饰方法以及代码块</strong> 。</li>
<li><strong><code>volatile</code> 关键字仅能保证数据的可见性，不能保证数据的原子性。<code>synchronized</code> 关键字两者都能保证。</strong></li>
<li><code>volatile</code>不会造成线程的阻塞，<code>synchronized</code>会造成线程的阻塞。**<code>volatile</code> 关键字<strong>是线程同步的</strong>轻量级实现**，所以 <strong><code>volatile </code>性能比<code>synchronized</code>关键字好</strong> 。</li>
</ul>
<br>

<blockquote>
<p>参考资料</p>
</blockquote>
<p><strong>《Java 并发编程的艺术》</strong></p>
<p><a href="http://concurrent.redspider.group/article/02/9.html">9 synchronized与锁 · 深入浅出Java多线程 (redspider.group)</a></p>
]]></content>
      <categories>
        <category>并发编程</category>
      </categories>
      <tags>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis设计与实现——简单动态字符串SDS</title>
    <url>/2021/11/28/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E2%80%94%E2%80%94%E7%AE%80%E5%8D%95%E5%8A%A8%E6%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2SDS/</url>
    <content><![CDATA[<p>Redis 没有直接使用 C 语言传统的字符串表示（以空字符<code>\0</code>结尾的<code>char</code>类型字符数组，以下简称 C 字符串）， 而是自己构建了一种名为简单动态字符串（simple dynamic string，SDS）的抽象类型， 并将 SDS 用作 Redis 的默认字符串表示。</p>
<p>在 Redis 里面， C 字符串只会作为字符串字面量（string literal）， 用在一些无须对字符串值进行修改的地方，比如打印日志。</p>
<h3 id="SDS-的定义"><a href="#SDS-的定义" class="headerlink" title="SDS 的定义"></a>SDS 的定义</h3><p>每个 sds.h / sdshdr 结构表示一个 SDS 值，在 Redis 3.2 版本以前，SDS 的结构如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> &#123;</span></span><br><span class="line">    <span class="comment">// 记录 buf 数组中已使用字节的数量</span></span><br><span class="line">    <span class="comment">// 等于 SDS 所保存字符串的长度</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> len;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 记录 buf 数组中剩余可用字节数量</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="built_in">free</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 字节数组，用于保存字符串</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>free</code> 属性的值为 <code>0</code> ， 表示这个 SDS 没有分配任何未使用空间。</li>
<li><code>len</code> 属性的值为 <code>5</code> ， 表示这个 SDS 保存了一个 5 字节长的字符串。</li>
<li><code>buf</code> 属性是一个 <code>char</code> 类型的数组， 数组的前 5 个字节分别保存了 <code>&#39;R&#39;</code> 、 <code>&#39;e&#39;</code> 、 <code>&#39;d&#39;</code> 、 <code>&#39;i&#39;</code> 、 <code>&#39;s&#39;</code> 5 个字符， 而最后一个字节则保存了空字符 <code>&#39;\0&#39;</code> 。</li>
</ul>
<p><img src="https://gitee.com/KIMTOU/img/raw/master/20211128205733.png"></p>
<blockquote>
<p>SDS 遵循 C 字符串以空字符结尾的惯例， 保存空字符的 <code>1</code> 字节空间不计算在 SDS 的 <code>len</code> 属性里面， 并且为空字符分配额外的 <code>1</code> 字节空间， 以及添加空字符到字符串末尾等操作都是由 SDS 函数自动完成的。遵循空字符结尾这一惯例的好处是， SDS 可以兼容 C 语言，直接重用一部分 C 字符串函数库里面的函数。</p>
</blockquote>
<p>字段 <code>len</code> 和 <code>free</code> 各占 4 字节，紧接着存放字符串。</p>
<p>这样做有以下几个好处：</p>
<ul>
<li>用单独的变量 len 和 free，可以<strong>方便地获取字符串长度和剩余空间</strong>；</li>
<li>内容存储在动态数组 buf 中，<strong>SDS 对上层暴露的指针指向 buf，而不是指向结构体 SDS</strong>。因此，上层可以像读取 C 字符串一样读取 SDS 的内容，兼容 C 语言处理字符串的各种函数，同时也能通过 buf 地址的偏移，方便地获取其他变量；</li>
<li>读写字符串不依赖于 <code>\0</code>，保证<strong>二进制安全</strong>。</li>
</ul>
<blockquote>
<p>在 C 语言中，<code>\0</code> 表示字符串结束，<strong>如果字符串中本身就包含 <code>\0</code> 字符，那么字符串就会在 <code>\0</code> 处被截断，即非二进制安全</strong>；若通过使用一个 len 属性，来判断字符串是否结束，就可以保证读写字符串时不受到 <code>\0</code> 的影响，则是二进制安全。<strong>同时 len 属性也能保证在 O(1) 时间内获取字符串的长度</strong>。</p>
</blockquote>
<p>但其实以上的设计是存在一些问题的，对于不同长度的字符串，是否有必要使用 len 和 free 这 2 个 4 字节的变量？**4 字节的 len，可表示的字符串长度为 <code>2^32-1</code>**，而在实际应用中，存放于 Redis 中的字符串往往没有这么长，因此，空间的使用上能否进一步压缩？</p>
<br>

<h3 id="SDS-与-C-字符串的区别"><a href="#SDS-与-C-字符串的区别" class="headerlink" title="SDS 与 C 字符串的区别"></a>SDS 与 C 字符串的区别</h3><p>根据传统， C 语言使用长度为 <code>N+1</code> 的字符数组来表示长度为 <code>N</code> 的字符串， 并且字符数组的最后一个元素总是空字符 <code>&#39;\0&#39;</code> 。C 语言使用的这种简单的字符串表示方式， 并不能满足 Redis 对字符串在安全性、效率、以及功能方面的要求。</p>
<table>
<thead>
<tr>
<th align="left">C 字符串</th>
<th align="left">SDS</th>
</tr>
</thead>
<tbody><tr>
<td align="left">获取字符串长度的复杂度为 O(N) 。</td>
<td align="left">获取字符串长度的复杂度为 O(1) 。</td>
</tr>
<tr>
<td align="left">API 是不安全的，可能会造成缓冲区溢出。</td>
<td align="left">API 是安全的，不会造成缓冲区溢出。</td>
</tr>
<tr>
<td align="left">修改字符串长度 <code>N</code> 次必然需要执行 <code>N</code> 次内存重分配。</td>
<td align="left">修改字符串长度 <code>N</code> 次最多需要执行 <code>N</code> 次内存重分配。</td>
</tr>
<tr>
<td align="left">只能保存文本数据。</td>
<td align="left">可以保存文本或者二进制数据。</td>
</tr>
<tr>
<td align="left">可以使用所有 <code>&lt;string.h&gt;</code> 库中的函数。</td>
<td align="left">可以使用一部分 <code>&lt;string.h&gt;</code> 库中的函数。</td>
</tr>
</tbody></table>
<h4 id="常数复杂度获取字符串长度"><a href="#常数复杂度获取字符串长度" class="headerlink" title="常数复杂度获取字符串长度"></a>常数复杂度获取字符串长度</h4><p>因为 C 字符串并不记录自身的长度信息， 所以为了获取一个 C 字符串的长度， 程序必须遍历整个字符串， 对遇到的每个字符进行计数， 直到遇到代表字符串结尾的空字符为止， 这个操作的复杂度为 O(N) 。</p>
<p>和 C 字符串不同，<strong>SDS 在 <code>len</code> 属性中记录了 SDS 本身的长度， 所以获取一个 SDS 长度的复杂度仅为 O(1)</strong> 。</p>
<p>通过使用 SDS 而不是 C 字符串， Redis 将获取字符串长度所需的复杂度从 O(N) 降低到了 O(1) ， 这确保了获取字符串长度的工作不会成为 Redis 的性能瓶颈。</p>
<h4 id="杜绝缓冲区溢出"><a href="#杜绝缓冲区溢出" class="headerlink" title="杜绝缓冲区溢出"></a>杜绝缓冲区溢出</h4><p><strong>C字符串不记录自身长度带来的另一个问题是很容易造成缓冲区溢出</strong>。比如使用字符串拼接函数 <code>stract</code> 的时候，如果目标数组 <code>dest</code> 没有分配足够的内存，可能会造成缓冲区溢出，即新增字符串覆盖掉目标数组 <code>dest</code> 在内存中紧邻着的 C 字符串原有的数据。</p>
<p><strong><code>SDS</code>的空间分配策略完全杜绝了发生缓存区溢出的可能性</strong>。当 SDS API 需要对 SDS 进行修改时， API 会先检查 SDS 的空间是否满足修改所需的要求， 如果不满足的话， API 会自动将 SDS 的空间扩展至执行修改所需的大小， 然后才执行实际的修改操作， 所以使用 SDS 既不需要手动修改 SDS 的空间大小， 也不会出现前面所说的缓冲区溢出问题。</p>
<h4 id="减少修改字符串时带来的内存重分配次数"><a href="#减少修改字符串时带来的内存重分配次数" class="headerlink" title="减少修改字符串时带来的内存重分配次数"></a>减少修改字符串时带来的内存重分配次数</h4><p>因为 C 字符串的长度和底层数组的长度之间存在紧密关联， 所以每次增长或者缩短一个 C 字符串， 程序都要对这个数组进行一次内存重分配操作：</p>
<ul>
<li>如果程序执行的是增长字符串的操作， 比如拼接操作（append）， 那么在执行这个操作之前， 程序需要先通过内存重分配来扩展底层数组的空间大小 —— 如果忘了这一步就会产生缓冲区溢出。</li>
<li>如果程序执行的是缩短字符串的操作， 比如截断操作（trim）， 那么在执行这个操作之后， 程序需要通过内存重分配来释放字符串不再使用的那部分空间 —— 如果忘了这一步就会产生内存泄漏。</li>
</ul>
<p>因为内存重分配涉及复杂的算法， 并且可能需要执行系统调用， 所以通常是个比较耗时的操作。Redis 作为数据库， 经常被用于速度要求严苛、数据被频繁修改的场合， 如果每次修改字符串的长度都需要执行一次内存重分配的话， 那么光是执行内存重分配的时间就会占去修改字符串所用时间的一大部分， 如果这种修改频繁地发生的话， 可能还会对性能造成影响。</p>
<p>为了避免 C 字符串的这种缺陷， SDS 通过未使用空间解除了字符串长度和底层数组长度之间的关联： 在 SDS 中， <code>buf</code> 数组的长度不一定就是字符数量加 1， <strong>数组里面可以包含未使用的字节</strong>， 而这些字节的数量就由 SDS 的 <code>free</code> 属性记录。</p>
<p>通过未使用空间， SDS 实现了<strong>空间预分配和惰性空间释放</strong>两种优化策略。</p>
<p><strong>1、空间预分配</strong>：</p>
<p>空间预分配用于优化 SDS 的字符串增长操作： <strong>简单来说就是当字节数组空间不足需要进行扩展时，总是会预留一部分空闲空间</strong>。</p>
<p>其中， 额外分配的未使用空间数量由以下公式决定：</p>
<ul>
<li>如果对 SDS 进行修改之后， SDS 的长度（也即是 <code>len</code> 属性的值）将小于 <code>1 MB</code> ， 那么多分配和 <code>len</code> 属性同样大小的未使用空间， 这时 SDS <code>len</code> 属性的值将和 <code>free</code> 属性的值相同。 </li>
<li>如果对 SDS 进行修改之后， SDS 的长度将大于等于 <code>1 MB</code> ， 那么程序会多分配 <code>1 MB</code> 的未使用空间。 </li>
</ul>
<p><strong>通过空间预分配策略， Redis 可以减少连续执行字符串增长操作所需的内存重分配次数</strong>。</p>
<p><strong>2、惰性空间释放</strong>：</p>
<p>惰性空间释放用于优化 SDS 的字符串缩短操作： <strong>简单来说就是当字符串缩短时，并不立即使用内存重分配来回收多出来的字节， 而是使用 <code>free</code> 属性将这些字节的数量记录起来， 并等待将来使用</strong>。</p>
<p>通过惰性空间释放策略， SDS 避免了缩短字符串时所需的内存重分配操作， 并为将来可能有的增长操作提供了优化。同时<code>SDS</code>也提供直接释放<code>SDS</code>里面未使用空间的<code>API</code>，让我们在需要的时候，真正的释放掉多余的空间， 所以不用担心惰性空间释放策略会造成内存浪费。</p>
<h4 id="二进制安全"><a href="#二进制安全" class="headerlink" title="二进制安全"></a>二进制安全</h4><p>C 字符串中的字符必须符合某种编码，并且除了字符串末尾之外，其它位置不允许出现空字符，这些限制使得 C 字符串只能保存文本数据，而不能保存像图片、音频、视频、压缩文件这样的二进制数据。</p>
<p>为了确保 Redis 可以适用于各种不同的使用场景， SDS 的 API 都是二进制安全的（<code>binary-safe</code>）： 所有 SDS API 都会以处理二进制的方式来处理 SDS 存放在 <code>buf</code> 数组里的数据。这也是我们将 SDS 的 <code>buf</code> 属性称为字节数组的原因 —— Redis 不是用这个数组来保存字符， 而是用它来保存一系列二进制数据。</p>
<p><strong>因为 SDS 使用 <code>len</code> 属性的值而不是空字符来判断字符串是否结束</strong>。</p>
<h4 id="兼容部分-C-字符串函数"><a href="#兼容部分-C-字符串函数" class="headerlink" title="兼容部分 C 字符串函数"></a>兼容部分 C 字符串函数</h4><p>虽然 SDS 的 API 都是二进制安全的， 但它们一样遵循 C 字符串以空字符结尾的惯例： 这些 API 总会将 SDS 保存的数据的末尾设置为空字符， 并且总会在为 <code>buf</code> 数组分配空间时多分配一个字节来容纳这个空字符， 这是为了让那些保存文本数据的 SDS 可以重用一部分 <code>&lt;string.h&gt;</code> 库定义的函数。</p>
<p><strong>通过遵循 C 字符串以空字符结尾的惯例， SDS 可以在有需要时重用 <code>&lt;string.h&gt;</code> 函数库， 从而避免了不必要的代码重复</strong>。</p>
<br>

<blockquote>
<p>参考资料</p>
</blockquote>
<p>《Redis 设计与实现》——黄健宏</p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis设计与实现——跳跃表</title>
    <url>/2021/11/28/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E2%80%94%E2%80%94%E8%B7%B3%E8%B7%83%E8%A1%A8/</url>
    <content><![CDATA[<p><strong>跳跃表（skiplist）是一种有序数据结构，它通过在每个节点中维持多个指向其他节点的指针，从而达到快速访问节点的目的</strong>。跳跃表支持平均 O(log N) 、最坏 O(N) 复杂度的节点查找，还可以通过顺序性操作来批量处理节点。</p>
<p>Redis 使用跳跃表作为有序集合键的底层实现之一：如果一个有序集合包含的元素数量比较多，又或者有序集合中元素的成员（member）是比较长的字符串时，Redis 就会使用跳跃表来作为有序集合键的底层实现。</p>
<h3 id="跳跃表的实现"><a href="#跳跃表的实现" class="headerlink" title="跳跃表的实现"></a>跳跃表的实现</h3><p><strong>Redis 的跳跃表由 <code>zskiplistNode</code> 和 <code>zskiplist</code> 两个结构定义，<code>zskiplistNode</code> 结构用于表示跳跃表节点， <code>zskiplist</code> 结构用于保存跳跃表节点相关信息，比如节点的数量，以及指向表头节点和表尾节点的指针等</strong>。</p>
<p><img src="https://gitee.com/KIMTOU/img/raw/master/20211128210516.png"></p>
<p>如图展示了一个跳跃表示例， 位于图片最左边的是 <code>zskiplist</code> 结构， 该结构包含以下属性：</p>
<ul>
<li><strong>header</strong> ：指向跳跃表的表头节点。</li>
<li><strong>tail</strong> ：指向跳跃表的表尾节点。</li>
<li><strong>level</strong> ：记录目前跳跃表内，层数最大的那个节点的层数（表头节点的层数不计算在内）。</li>
<li><strong>length</strong> ：记录跳跃表的长度，也即是，跳跃表目前包含节点的数量（表头节点不计算在内）。</li>
</ul>
<p>位于 <code>zskiplist</code> 结构右方的是四个 <code>zskiplistNode</code> 结构， 该结构包含以下属性：</p>
<ul>
<li><strong>层（level）</strong>：节点中用 <code>L1</code> 、 <code>L2</code> 、 <code>L3</code> 等字样标记节点的各个层， <code>L1</code> 代表第一层， <code>L2</code> 代表第二层，以此类推。<strong>每个层都带有两个属性：前进指针和跨度。前进指针用于访问位于表尾方向的其他节点，而跨度则记录了前进指针所指向节点和当前节点的距离</strong>。在上面的图片中，连线上带有数字的箭头就代表前进指针，而那个数字就是跨度。<strong>当程序从表头向表尾进行遍历时，访问会沿着层的前进指针进行</strong>。</li>
<li><strong>后退（backward）指针</strong>：节点中用 <code>BW</code> 字样标记节点的后退指针，<strong>它指向位于当前节点的前一个节点。后退指针在程序从表尾向表头遍历时使用</strong>。</li>
<li><strong>分值（score）</strong>：各个节点中的 <code>1.0</code> 、 <code>2.0</code> 和 <code>3.0</code> 是节点所保存的分值。在跳跃表中，节点按各自所保存的分值从小到大排列。</li>
<li><strong>成员对象（obj）</strong>：各个节点中的 <code>o1</code> 、 <code>o2</code> 和 <code>o3</code> 是节点所保存的成员对象。</li>
</ul>
<p><strong>需要注意的是，表头节点不存储真实数据，并且层高固定为32，从表头节点第一个不为<code>NULL</code>最高层开始，就能实现快速查找</strong>。</p>
<br>

<h3 id="跳跃表节点-zskiplistNode"><a href="#跳跃表节点-zskiplistNode" class="headerlink" title="跳跃表节点 zskiplistNode"></a>跳跃表节点 zskiplistNode</h3><p>跳跃表节点的实现由 <code>redis.h/zskiplistNode</code> 结构定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> &#123;</span></span><br><span class="line">    <span class="comment">// 后退指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">backward</span>;</span></span><br><span class="line">    <span class="comment">// 分值</span></span><br><span class="line">    <span class="keyword">double</span> score;</span><br><span class="line">    <span class="comment">// 成员对象</span></span><br><span class="line">    robj *obj;</span><br><span class="line">    <span class="comment">// 层</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistLevel</span> &#123;</span></span><br><span class="line">        <span class="comment">// 前进指针</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">forward</span>;</span></span><br><span class="line">        <span class="comment">// 跨度</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> span;</span><br><span class="line">    &#125; level[];</span><br><span class="line">&#125; zskiplistNode;</span><br></pre></td></tr></table></figure>

<h4 id="1-层"><a href="#1-层" class="headerlink" title="1. 层"></a>1. 层</h4><p>跳跃表节点的 <code>level</code> 数组可以包含多个元素，每个元素都包含一个指向其他节点的指针，程序可以通过这些层来加快访问其他节点的速度，一般来说，层的数量越多，访问其他节点的速度就越快。</p>
<p>每次创建一个新跳跃表节点的时候，程序都根据幂次定律（power law，越大的数出现的概率越小）随机生成一个介于 <code>1</code> 和 <code>32</code> 之间的值作为 <code>level</code> 数组的大小，这个大小就是层的“高度”。</p>
<p><strong>每个层都带有两个属性：前进指针和跨度。前进指针用于访问位于表尾方向的其他节点，而跨度则记录了前进指针所指向节点和当前节点的距离</strong>。</p>
<h5 id="前进指针"><a href="#前进指针" class="headerlink" title="前进指针"></a>前进指针</h5><p>每个层都有一个指向表尾方向的前进指针， 用于从表头向表尾方向访问节点。</p>
<h5 id="跨度"><a href="#跨度" class="headerlink" title="跨度"></a>跨度</h5><p>层的跨度用于记录前进指针所指向节点和当前节点的距离。</p>
<p>遍历操作只使用前进指针就可以完成了，跨度实际上是用来计算排位（rank）的：在查找某个节点的过程中，将沿途访问过的所有层的跨度累计起来，得到的结果就是目标节点在跳跃表中的排位。</p>
<h4 id="2-后退指针"><a href="#2-后退指针" class="headerlink" title="2. 后退指针"></a>2. 后退指针</h4><p>节点的后退指针（<code>backward</code> 属性）用于从表尾向表头方向访问节点：跟可以一次跳过多个节点的前进指针不同，因为每个节点只有一个后退指针，所以每次只能后退至前一个节点。</p>
<p>程序首先通过跳跃表的 <code>tail</code> 指针访问表尾节点，然后通过后退指针访问倒数第二个节点，直至遇到指向 <code>NULL</code> 的后退指针，访问结束。</p>
<h4 id="3-分值和成员"><a href="#3-分值和成员" class="headerlink" title="3. 分值和成员"></a>3. 分值和成员</h4><p>节点的分值（<code>score</code> 属性）是一个 <code>double</code> 类型的浮点数，<strong>跳跃表中的所有节点都按分值从小到大来排序</strong>。</p>
<p>节点的成员对象（<code>obj</code> 属性）是一个指针，它指向一个字符串对象，而字符串对象则保存着一个 SDS 值。</p>
<p>在同一个跳跃表中， <strong>各个节点保存的成员对象必须是唯一的，但是多个节点保存的分值却可以是相同的：分值相同的节点将按照成员对象在字典序中的大小来进行排序</strong>，成员对象较小的节点会排在前面（靠近表头的方向），而成员对象较大的节点则会排在后面（靠近表尾的方向）。</p>
<br>

<h3 id="跳跃表-zskiplist"><a href="#跳跃表-zskiplist" class="headerlink" title="跳跃表 zskiplist"></a>跳跃表 zskiplist</h3><p>仅靠多个跳跃表节点就可以组成一个跳跃表，但通过使用一个<code>zskiplist</code>结构来持有这些节点，程序可以更方便地对整个跳跃表进行操作，比如<strong>快速访问跳跃表的表头节点和表尾节点，快速地获取跳跃表节点的数量</strong>（也就是跳跃表的长度）等信息。<code>zskiplist</code>结构定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplist</span> &#123;</span></span><br><span class="line">    <span class="comment">// 表头节点和表尾节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">header</span>, *<span class="title">tail</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 表中节点的数量</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> length;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 表中层数最大的节点的层数</span></span><br><span class="line">    <span class="keyword">int</span> level;</span><br><span class="line">&#125; zskiplist;</span><br></pre></td></tr></table></figure>

<p><code>header</code> 和 <code>tail</code> 指针分别指向跳跃表的表头和表尾节点，通过这两个指针，程序定位表头节点和表尾节点的复杂度为 O(1) 。</p>
<p>通过使用 <code>length</code> 属性来记录节点的数量，程序可以在 O(1) 复杂度内返回跳跃表的长度。</p>
<p><code>level</code> 属性则用于在 O(1) 复杂度内获取跳跃表中层高最大的那个节点的层数量，注意表头节点的层高并不计算在内。</p>
<br>

<blockquote>
<p>参考资料</p>
</blockquote>
<p>《Redis 设计与实现》——黄健宏</p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis设计与实现——字典（渐进式rehash细节）</title>
    <url>/2021/11/28/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E2%80%94%E2%80%94%E5%AD%97%E5%85%B8%EF%BC%88%E6%B8%90%E8%BF%9B%E5%BC%8Frehash%E7%BB%86%E8%8A%82%EF%BC%89/</url>
    <content><![CDATA[<p>字典是一种<strong>用于保存键值对</strong>的数据结构。在字典中，一个键（key）可以和一个值（value）进行关联（或者说将键映射为值），这些关联的键和值就称为键值对。</p>
<h3 id="字典的实现"><a href="#字典的实现" class="headerlink" title="字典的实现"></a>字典的实现</h3><p><strong>Redis 的字典使用哈希表作为底层实现，每个字典带有两个哈希表，一个平时使用，另一个仅在进行 rehash 过程中使用，一个哈希表里面可以有多个哈希表节点，每个哈希表节点就保存了字典中的一个键值对</strong>。</p>
<h4 id="哈希表-hashtable"><a href="#哈希表-hashtable" class="headerlink" title="哈希表 hashtable"></a>哈希表 hashtable</h4><p>Redis 字典所使用的哈希表由 <code>dict.h/dictht</code> 结构定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictht</span> &#123;</span></span><br><span class="line">    <span class="comment">// 哈希表数组</span></span><br><span class="line">    dictEntry **table;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 哈希表大小</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 哈希表大小掩码，用于计算索引值</span></span><br><span class="line">    <span class="comment">// 总是等于 size - 1</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> sizemask;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 该哈希表已有节点的数量</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> used;</span><br><span class="line">&#125; dictht;</span><br></pre></td></tr></table></figure>

<p><strong><code>table</code> 属性是一个数组，数组中的每个元素都是一个指向 <code>dict.h/dictEntry</code> 结构的指针，每个 <code>dictEntry</code> 结构保存着一个键值对</strong>。<code>size</code> 属性记录了哈希表的大小， 也即是 <code>table</code> 数组的大小， 而 <code>used</code> 属性则记录了哈希表目前已有节点（键值对）的数量。<code>sizemask</code> 属性的值总是等于 <code>size - 1</code> ， 这个属性和哈希值一起决定一个键应该被放到 <code>table</code> 数组的哪个索引上面（原理类似 Java 中的 HashMap）。</p>
<h4 id="哈希表节点"><a href="#哈希表节点" class="headerlink" title="哈希表节点"></a>哈希表节点</h4><p>哈希表节点使用 <code>dictEntry</code> 结构表示，每个 <code>dictEntry</code> 结构都保存着一个键值对：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> &#123;</span></span><br><span class="line">    <span class="comment">// 键</span></span><br><span class="line">    <span class="keyword">void</span> *key;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 值</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="keyword">void</span> *val; <span class="comment">// 指针</span></span><br><span class="line">        <span class="keyword">uint64_t</span> u64;</span><br><span class="line">        <span class="keyword">int64_t</span> s64;</span><br><span class="line">    &#125; v;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指向下个哈希表节点，形成链表</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; dictEntry;</span><br></pre></td></tr></table></figure>

<p><code>key</code> 属性保存着键值对中的键，而 <code>v</code> 属性则保存着键值对中的值，值可以是一个指针，或者是一个 <code>uint64_t</code> 整数，又或者是一个 <code>int64_t</code> 整数。</p>
<p><code>next</code> 属性是指向另一个 <code>dictEntry</code> 哈希表节点的指针，这个指针可以将多个哈希值相同的键值对连接在一次，以此来解决键冲突的问题，即<strong>使用链地址法解决键哈希冲突</strong>，被分配到同一个索引上的多个键值对会连接成一个单向链表。</p>
<blockquote>
<p><strong>解决键冲突</strong></p>
<p>当有两个或以上数量的键被分配到了哈希表数组的同一个索引上面时，我们称这些键发生了冲突。</p>
<p>Redis 的哈希表使用链地址法（separate chaining）来解决键冲突： 每个哈希表节点都有一个 <code>next</code> 指针， 多个哈希表节点可以用 <code>next</code> 指针构成一个单向链表， 被分配到同一个索引上的多个节点可以用这个单向链表连接起来， 这就解决了键冲突的问题。</p>
<p><strong>为什么使用头插法？</strong></p>
<p>因为 <code>dictEntry</code> 节点组成的链表没有指向链表表尾的指针， 所以为了速度考虑， 程序总是将新节点添加到链表的表头位置（复杂度为 O(1)）， 排在其他已有节点的前面。</p>
</blockquote>
<p>下图展示了如何通过 <code>next</code> 指针，将两个索引值相同的键 <code>k1</code> 和 <code>k0</code> 连接在一起：</p>
<p><img src="https://gitee.com/KIMTOU/img/raw/master/20211128210239.png"></p>
<h4 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h4><p>Redis 中的字典由 <code>dict.h/dict</code> 结构表示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dict</span> &#123;</span></span><br><span class="line">    <span class="comment">// 类型特定函数</span></span><br><span class="line">    dictType *type;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 私有数据</span></span><br><span class="line">    <span class="keyword">void</span> *privdata;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 哈希表</span></span><br><span class="line">    dictht ht[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// rehash 索引</span></span><br><span class="line">    <span class="comment">// 当 rehash 不在进行时，值为 -1</span></span><br><span class="line">    <span class="keyword">int</span> rehashidx; <span class="comment">/* rehashing not in progress if rehashidx == -1 */</span></span><br><span class="line">&#125; dict;</span><br></pre></td></tr></table></figure>

<p><code>type</code> 属性和 <code>privdata</code> 属性是针对不同类型的键值对，为创建多态字典而设置的。</p>
<p><strong><code>ht</code> 属性是一个大小为 2 的数组，数组中的每个元素都是一个 <code>dictht</code> 哈希表。一般情况下，字典只使用 <code>ht[0]</code> 哈希表，<code>ht[1]</code> 哈希表只会在对 <code>ht[0]</code> 哈希表进行 rehash 时使用。<code>rehashidx</code> 记录了 rehash 目前的进度，如果目前没有进行 rehash，则值为 -1</strong> 。</p>
<p>下图展示了一个普通状态下（没有进行 rehash）的字典：</p>
<p><img src="https://gitee.com/KIMTOU/img/raw/master/20211128210244.png"></p>
<h3 id="哈希算法"><a href="#哈希算法" class="headerlink" title="哈希算法"></a>哈希算法</h3><p>当要将一个新的键值对添加到字典里面时， 程序需要先根据键值对的键计算出哈希值和索引值， 然后再根据索引值， 将包含新键值对的哈希表节点放到哈希表数组的指定索引上面。</p>
<p>Redis 计算哈希值和索引值的方法如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 使用字典设置的哈希函数，计算键 key 的哈希值</span></span><br><span class="line">hash = dict-&gt;type-&gt;hashFunction(key);</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用哈希表的 sizemask 属性和哈希值，计算出索引值</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 根据情况不同， ht[x] 可以是 ht[0] 或者 ht[1]</span></span><br><span class="line">index = hash &amp; dict-&gt;ht[x].sizemask;</span><br></pre></td></tr></table></figure>

<h3 id="rehash"><a href="#rehash" class="headerlink" title="rehash"></a>rehash</h3><p><strong>为了让哈希表的负载因子（<code>ht[0].used / ht[0].size</code>）维持在一个合理范围之内，当哈希表保存的键值对数量过多或者过少时，程序需要对哈希表的大小进行相应的扩展和收缩</strong>。扩展和收缩哈希表的工作可以通过执行rehash（重新散列）操作来完成。rehash 的步骤如下：</p>
<ol>
<li><p>为字典的 <code>ht[1]</code> 哈希表分配空间， 这个哈希表的空间大小取决于要执行的操作， 以及 <code>ht[0]</code> 当前包含的键值对数量 （也即是 <code>ht[0].used</code> 属性的值）：</p>
<ul>
<li><p>如果执行的是扩展操作， 那么 <code>ht[1]</code> 的大小为第一个大于等于 <code>ht[0].used * 2</code> 的 2^n （<code>2</code> 的 <code>n</code> 次方幂）。比如 <code>ht[0].used=5</code>，那么此时<code>ht[1]</code>的大小就为16，因为大于10的第一个2^n的值是16。</p>
</li>
<li><p>如果执行的是收缩操作， 那么 <code>ht[1]</code> 的大小为第一个大于等于 <code>ht[0].used</code> 的 2^n 。</p>
</li>
</ul>
</li>
<li><p>将保存在 <code>ht[0]</code> 中的所有键值对 rehash 到 <code>ht[1]</code> 中（rehash 指的是重新计算键的哈希值和索引值， 然后将键值对放置到 <code>ht[1]</code> 哈希表的指定位置上）。</p>
</li>
<li><p>当 <code>ht[0]</code> 包含的所有键值对都迁移到了 <code>ht[1]</code> 之后 （<code>ht[0]</code> 变为空表），释放 <code>ht[0]</code> ，并将 <code>ht[1]</code> 设置为 <code>ht[0]</code> ，并在 <code>ht[1]</code> 新创建一个空白哈希表，为下一次 rehash 做准备。</p>
</li>
</ol>
<h4 id="哈希表的扩展和收缩时机"><a href="#哈希表的扩展和收缩时机" class="headerlink" title="哈希表的扩展和收缩时机"></a>哈希表的扩展和收缩时机</h4><ol>
<li>当服务器目前没有在执行 BGSAVE 命令或者 BGREWRITEAOF 命令，并且哈希表的负载因子大于等于 <code>1</code> 时，程序会自动开始对哈希表执行扩展操作。</li>
<li>当服务器目前正在执行 BGSAVE 命令或者 BGREWRITEAOF 命令，并且哈希表的负载因子大于等于 <code>5</code> 时，程序会自动开始对哈希表执行扩展操作。</li>
</ol>
<blockquote>
<p>其中哈希表的负载因子可以通过公式：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 负载因子 = 哈希表已保存节点数量 / 哈希表大小</span></span><br><span class="line">load_factor = ht[0].used / ht[0].size</span><br></pre></td></tr></table></figure>

<p>在执行 BGSAVE 命令或 BGREWRITEAOF 命令的过程中， Redis 需要创建当前服务器进程的子进程， 而大多数操作系统都采用写时复制（copy-on-write）技术来优化子进程的使用效率， 所以在子进程存在期间， 服务器会提高执行扩展操作所需的负载因子， 从而尽可能地避免在子进程存在期间进行哈希表扩展操作， 这可以避免不必要的内存写入操作， 最大限度地节约内存。</p>
</blockquote>
<ol start="3">
<li>当哈希表的负载因子小于 <code>0.1</code> 时，程序自动开始对哈希表执行收缩操作。</li>
</ol>
<br>

<h3 id="渐进式-rehash"><a href="#渐进式-rehash" class="headerlink" title="渐进式 rehash"></a>渐进式 rehash</h3><p>扩展或收缩哈希表需要将 <code>ht[0]</code> 里面的所有键值对 rehash 到 <code>ht[1]</code> 里面，但是为了避免 rehash 对服务器性能造成影响， 服务器不是一次性将 <code>ht[0]</code> 里面的所有键值对全部 rehash 到 <code>ht[1]</code> ， 而是分多次、渐进式地将 <code>ht[0]</code> 里面的键值对慢慢地 rehash 到 <code>ht[1]</code> 。</p>
<h4 id="为什么要使用渐进式-rehash"><a href="#为什么要使用渐进式-rehash" class="headerlink" title="为什么要使用渐进式 rehash"></a>为什么要使用渐进式 rehash</h4><p><strong>渐进式 rehash 的好处在于它采取分而治之的方式，将 rehash 键值对所需的计算工作分摊到对字典的每个添加、删除、查找和更新操作上，从而避免了集中式 rehash 而带来的庞大计算量</strong>。</p>
<p>如果<code>ht[0]</code>元素很多，显然一次性 rehash 成本会很大，庞大的计算量可能会导致服务器在一段时间内停止服务，从而影响到 Redis 性能。因为 Redis 不管是老版本（只支持单线程的版本）还是现在的多线程版本，最终执行命令的还是单线程，一次性 rehash 可能会导致主线程卡顿。</p>
<h4 id="哈希表渐进式-rehash-过程"><a href="#哈希表渐进式-rehash-过程" class="headerlink" title="哈希表渐进式 rehash 过程"></a>哈希表渐进式 rehash 过程</h4><ol>
<li>为 <code>ht[1]</code> 分配空间，让字典同时持有 <code>ht[0]</code> 和 <code>ht[1]</code> 两个哈希表。</li>
<li>在字典中维持一个索引计数器变量 <code>rehashidx</code> ，并将它的值设置为 <code>0</code> ，表示 rehash 工作正式开始。</li>
<li><strong>在 rehash 进行期间，每次对字典执行添加、删除、查找或者更新操作时，程序除了会执行指定的操作以外，还会顺带将 <code>ht[0]</code> 哈希表在 <code>rehashidx</code> 索引上的所有键值对 rehash 到 <code>ht[1]</code> ，当 rehash 工作完成之后，将 <code>rehashidx</code> 属性的值加 1</strong>，即从索引 0 开始顺序迁移。</li>
<li>随着字典操作的不断执行，最终在某个时间点上，<code>ht[0]</code> 的所有键值对都会被 rehash 至 <code>ht[1]</code> ， 此时将 <code>rehashidx</code> 属性的值设为 <code>-1</code> ，表示 rehash 操作已完成。</li>
</ol>
<p><img src="https://gitee.com/KIMTOU/img/raw/master/20211128210248.png"></p>
<h4 id="渐进式-rehash-执行期间的哈希表操作"><a href="#渐进式-rehash-执行期间的哈希表操作" class="headerlink" title="渐进式 rehash 执行期间的哈希表操作"></a>渐进式 rehash 执行期间的哈希表操作</h4><p>在渐进式 rehash 时，因为字典会同时使用<code>ht[0]</code>和<code>ht[1]</code>两个哈希表，所以此时对字典的删除、查找和更新操作都可能会在两个哈希表进行。</p>
<ul>
<li><p><strong>如果要查找一个键时，先在<code>ht[0]</code>中查找，如果没找到，则会继续到<code>ht[1]</code>中查找。</strong></p>
</li>
<li><p><strong>新添加到字典的键值对一律会被保存到 <code>ht[1]</code> 里面，而 <code>ht[0]</code> 则不再进行任何添加操作</strong>。</p>
</li>
</ul>
<br>

<blockquote>
<p>参考资料</p>
</blockquote>
<p>《Redis 设计与实现》——黄健宏</p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>基于Redis3.0与6.0版本源码看SDS内存优化</title>
    <url>/2021/11/28/%E5%9F%BA%E4%BA%8ERedis3-0%E4%B8%8E6-0%E7%89%88%E6%9C%AC%E6%BA%90%E7%A0%81%E7%9C%8BSDS%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<h3 id="实践中引发的思考"><a href="#实践中引发的思考" class="headerlink" title="实践中引发的思考"></a>实践中引发的思考</h3><p>最近在看《Redis 设计与实现》这本书，不由得赞叹 Redis 底层数据结构设计的精妙。在看到 Redis 对象章节时，我们知道 Redis 是使用对象来表示数据库中的键和值的，其中键总是字符串对象，而字符串对象的编码又可以是  <code>int</code>、<code>raw</code> 或者 <code>embstr</code> 。</p>
<p>关键点来了，书中对字符串对象是这么写的：</p>
<blockquote>
<p>如果字符串对象保存的是一个字符串值，并且这个字符串值的长度小于等于 39 字节，那么字符串对象将使用 embstr 编码的方式来保存这个字符串值。</p>
</blockquote>
<p>看到这，我马上实践了一波，结果直接懵了。。。</p>
<p><img src="https://gitee.com/KIMTOU/img/raw/master/20211128231641.png"></p>
<p>当我创建了一个长度为 39 的字符串，编码为 embstr，这没有什么问题，但长度变为 41 的时候，此时编码应该转换为 raw 才对，然而并没有！</p>
<p>我的第一直觉便觉得应该就是版本问题，因为《Redis 设计与实现》是基于 Redis 3.0 版本的，而我之前专门看过 Redis 3.0 和 6.0 版本的 SDS 源码，已经知道 Redis 在 3.2 版本的时候对 SDS 进行了内存优化，很可能是因为这个原因导致编码转换的边界值发生改变。</p>
<p>上网一搜，看到这位博主跟我遇到了一样的问题：<a href="https://blog.csdn.net/XiyouLinux_Kangyijie/article/details/78045385">Redis的embstr与raw编码方式不再以39字节为界了！</a>，发现原因确实是这样的。只不过博主并没有将不同版本的源码来对比说明，这里便通过源码加以佐证。</p>
<br>

<h3 id="Redis-3-2-以前的-SDS-实现"><a href="#Redis-3-2-以前的-SDS-实现" class="headerlink" title="Redis 3.2 以前的 SDS 实现"></a>Redis 3.2 以前的 SDS 实现</h3><p>每个 sds.h / sdshdr 结构表示一个 SDS 值，在 Redis 3.2 版本以前，SDS 的结构如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> &#123;</span></span><br><span class="line">    <span class="comment">// 记录 buf 数组中已使用字节的数量</span></span><br><span class="line">    <span class="comment">// 等于 SDS 所保存字符串的长度</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> len;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 记录 buf 数组中剩余可用字节数量</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="built_in">free</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 字节数组，用于保存字符串</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>想深入了解 SDS 的读者可以看我之前写的文章：<a href="https://blog.tojintao.cn/2021/11/28/%E5%9F%BA%E4%BA%8ERedis3-0%E4%B8%8E6-0%E7%89%88%E6%9C%AC%E6%BA%90%E7%A0%81%E7%9C%8BSDS%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96/">基于Redis3.0与6.0版本源码看SDS内存优化 | KimTou (tojintao.cn)</a></p>
</blockquote>
<p>我们可以看到，<strong>字段 <code>len</code> 和 <code>free</code> 都是 unsigned int 类型，各占 4 字节</strong>，紧接着存放字符串。</p>
<p>但其实以上的设计并不是最优，**4 字节的 len，可表示的字符串长度为 <code>2^32-1</code>**，在实际应用中，存放于 Redis 中的字符串往往没有这么长，没有必要每个字符串都让 len 和 free 为 4 字节。</p>
<br>

<h3 id="Redis-6-0版本-SDS-实现"><a href="#Redis-6-0版本-SDS-实现" class="headerlink" title="Redis 6.0版本 SDS 实现"></a>Redis 6.0版本 SDS 实现</h3><p><strong>优化：根据字符串的长度，使用不同的数据结构进行存储</strong></p>
<p>在 Redis 3.2 版本之后（v3.2 - v6.0），Redis 将 SDS 划分为 5 种类型：</p>
<ul>
<li>sdshdr5：长度小于 1 字节</li>
<li>sdshdr8：长度 1 字节</li>
<li>sdshdr16：长度 2 字节</li>
<li>sdshdr32：长度 4 字节</li>
<li>sdshdr64：长度 8 字节</li>
</ul>
<p><strong>Redis 增加了一个 flags 字段来标识类型，用一个字节 (8 位) 来存储</strong>，在 sdshdr5 中：前 3 位表示字符串的类型；剩余 5 位，可以用来存储数组长度 len (5 bit) 。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr5</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags; <span class="comment">/* 前3位存储类型，后5位存储长度 */</span></span><br><span class="line">    <span class="keyword">char</span> buf[]; <span class="comment">/* 存放字符串 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>而对于长度大于 31 的字符串，仅仅靠 flags 的后 5 位来存储长度明显是不够的，需要用另外的变量来存储。sdshdr8、sdshdr16、sdshdr32、sdshdr64 的数据结构定义如下：<strong>其中 len 表示已使用的长度，alloc 表示总长度，<code>alloc - len</code> 其实就是之前版本的 free 字段，buf 存储实际字符串内容，而 flags 的前 3 位依然存储类型，后 5 位则预留</strong>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr8</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint8_t</span> len;   <span class="comment">/* 已使用长度，1字节 */</span></span><br><span class="line">    <span class="keyword">uint8_t</span> alloc; <span class="comment">/* 总长度，1字节 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags; <span class="comment">/* 前3位存储类型，后5位预留 */</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr16</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint16_t</span> len;   <span class="comment">/* 已使用长度，2字节 */</span></span><br><span class="line">    <span class="keyword">uint16_t</span> alloc; <span class="comment">/* 总长度，2字节 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags; <span class="comment">/* 前3位存储类型，后5位预留 */</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr32</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> len;   <span class="comment">/* 已使用长度，4字节 */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> alloc; <span class="comment">/* 总长度，4字节 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags; <span class="comment">/* 前3位存储类型，后5位预留 */</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr64</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint64_t</span> len;   <span class="comment">/* 已使用长度，8字节 */</span></span><br><span class="line">    <span class="keyword">uint64_t</span> alloc; <span class="comment">/* 总长度，8字节 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags; <span class="comment">/* 前3位存储类型，后5位预留 */</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<br>

<h3 id="关键结论"><a href="#关键结论" class="headerlink" title="关键结论"></a>关键结论</h3><p>看到这里可以先总结一下结论：<strong>3.2版本之后 embstr 与 raw 编码的分界不再是 39，而是 44</strong>。</p>
<br>

<h3 id="为什么之前是39？"><a href="#为什么之前是39？" class="headerlink" title="为什么之前是39？"></a>为什么之前是39？</h3><blockquote>
<p>REDIS_ENCODING_EMBSTR_SIZE_LIMIT set to 39.<br>The new value is the limit for the robj + SDS header + string +<br>null-term to stay inside the 64 bytes Jemalloc arena in 64 bits<br>systems.</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> type:<span class="number">4</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> encoding:<span class="number">4</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> lru:REDIS_LRU_BITS;</span><br><span class="line">    <span class="keyword">int</span> refcount;</span><br><span class="line">    <span class="keyword">void</span> *ptr;</span><br><span class="line">&#125; robj;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> len;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="built_in">free</span>;</span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>embstr 编码的字符串是一块连续的内存区域，由 redisObject 和 sdshdr 组成。</p>
<p><img src="https://gitee.com/KIMTOU/img/raw/master/20211128232457.png"></p>
<p><strong>其中 redisObject 占 16 个字节，当 buf 数组内的字符串长度是 39 时，sdshdr 的大小为 4+4+39+1=48，那一个字节是 ‘\0’，加起来刚好 64</strong>。</p>
<blockquote>
<p>从2.4版本开始，Redis 开始使用 jemalloc 内存分配器。这个比 glibc 的 malloc 要好不少，还省内存。在这里可以简单理解，jemalloc 会分配8，16，32，64等字节的内存。</p>
<p>无论是DictEntry对象，还是RedisObject、SDS对象，都需要内存分配器（如jemalloc）分配内存进行存储。当Redis存储数据时，会选择大小最合适的内存块进行存储。</p>
</blockquote>
<p>embstr 最小为 16+4+4+1=25，而分配 32 字节的话 buf 只有 7 字节存储，长度太小了，所以实际会分配64字节，即 Redis 认为如果超过 64 字节就是大字符串。当字符数小于 39 时，都会分配 64 字节。</p>
<br>

<h3 id="为什么现在是44？"><a href="#为什么现在是44？" class="headerlink" title="为什么现在是44？"></a>为什么现在是44？</h3><p><strong>主要是因为 3.2 版本对 SDS 数据结构进行了内存优化</strong>。</p>
<p>本身就是针对短字符串的 embstr 自然会使用最小的 sdshdr8，而 sdshdr8 与之前的 sdshdr 相比正好减少了5个字节。为什么呢，这里计算一下除去 buf 数组以外变量所占空间：</p>
<ul>
<li>sdsdr8 = uint8_t * 2 + char = 1*2 + 1 = 3 字节</li>
<li>sdshdr = unsigned int * 2 = 4 * 2 = 8 字节</li>
</ul>
<p><strong>所以 buf 数组能容纳的字符串长度增加了 5 个字节，变成了 44</strong> ！</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr8</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint8_t</span> len;   <span class="comment">/* 已使用长度，8bit = 1字节 */</span></span><br><span class="line">    <span class="keyword">uint8_t</span> alloc; <span class="comment">/* 总长度，1字节 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags; <span class="comment">/* 前3位存储类型，后5位预留 */</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<br>

<h3 id="进行验证"><a href="#进行验证" class="headerlink" title="进行验证"></a>进行验证</h3><p><img src="https://gitee.com/KIMTOU/img/raw/master/20211128231635.PNG"></p>
<p>可以看到，当字符串长度达到大于 44 时，字符串对象就会从 <code>embstr</code> 编码转换为 <code>raw</code>。</p>
<hr>
<p>从发现问题再到深入底层探索细节，最后得出结论，整个历程都让我受益匪浅。一个小小的实践却让我深入探究了 SDS 的底层细节，也加深了自己对其的理解，不枉费自己在图书馆的一个下午哈哈。</p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Centos部署SpringBoot项目（JDK+MySQL+Redis）</title>
    <url>/2021/04/30/Centos%E9%83%A8%E7%BD%B2SpringBoot%E9%A1%B9%E7%9B%AE%EF%BC%88JDK-MySQL-Redis%EF%BC%89/</url>
    <content><![CDATA[<h2 id="安装jdk"><a href="#安装jdk" class="headerlink" title="安装jdk"></a>安装jdk</h2><ul>
<li>将压缩包上传至 /usr/java ，并进行解压</li>
</ul>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/java</span><br><span class="line">tar <span class="literal">-zxvf</span> jdk<span class="literal">-8u281</span><span class="literal">-linux</span><span class="literal">-x64</span>.tar.gz </span><br></pre></td></tr></table></figure>

<ul>
<li>设置环境变量</li>
</ul>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">vim /etc/profile</span><br></pre></td></tr></table></figure>
<ul>
<li>在文件中添加如下代码</li>
</ul>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">export JAVA_HOME=/usr/java/jdk1.<span class="number">8.0</span>_281</span><br><span class="line">export JRE_HOME=<span class="variable">$JAVA_HOME</span>/jre</span><br><span class="line">export CLASSPATH=.:<span class="variable">$JAVA_HOME</span>/lib/dt.jar:<span class="variable">$JAVA_HOME</span>/lib/tools.jar:<span class="variable">$JRE_HOME</span>/lib</span><br><span class="line">export PATH=<span class="variable">$PATH:</span><span class="variable">$JAVA_HOME</span>/bin</span><br></pre></td></tr></table></figure>
<ul>
<li>保存后使用source使配置环境生效</li>
</ul>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">source /etc/profile</span><br></pre></td></tr></table></figure>
<ul>
<li>查看环境是否配置成功<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">java <span class="literal">-version</span></span><br></pre></td></tr></table></figure></li>
</ul>
<br>

<h2 id="安装MySQL"><a href="#安装MySQL" class="headerlink" title="安装MySQL"></a>安装MySQL</h2><ul>
<li>下载MySQL官方的Yum Repository的配置文件</li>
</ul>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="built_in">wget</span> <span class="literal">-i</span> <span class="literal">-c</span> http://dev.mysql.com/get/mysql57<span class="literal">-community</span><span class="literal">-release</span><span class="literal">-el7</span><span class="literal">-10</span>.noarch.rpm</span><br></pre></td></tr></table></figure>
<ul>
<li>安装MySQL官方的Yum Repository</li>
</ul>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">yum <span class="literal">-y</span> install mysql57<span class="literal">-community</span><span class="literal">-release</span><span class="literal">-el7</span><span class="literal">-10</span>.noarch.rpm</span><br></pre></td></tr></table></figure>
<hr>
<p><strong>以上方法可能会出现下载速度很慢的问题，可以切换至阿里云的yum源</strong></p>
<ul>
<li>备份</li>
</ul>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mv</span> /etc/yum.repos.d/CentOS<span class="literal">-Base</span>.repo /etc/yum.repos.d/CentOS<span class="literal">-Base</span>.repo.backup</span><br></pre></td></tr></table></figure>
<ul>
<li>下载阿里云yum文件</li>
</ul>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="built_in">wget</span> <span class="literal">-O</span> /etc/yum.repos.d/CentOS<span class="literal">-Base</span>.repo http://mirrors.aliyun.com/repo/Centos<span class="literal">-7</span>.repo</span><br></pre></td></tr></table></figure>
<ul>
<li>清缓存</li>
</ul>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">yum clean all</span><br><span class="line">yum makecache</span><br></pre></td></tr></table></figure>
<ul>
<li>下载</li>
</ul>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">yum <span class="literal">-y</span> install mysql57<span class="literal">-community</span><span class="literal">-release</span><span class="literal">-el7</span><span class="literal">-10</span>.noarch.rpm</span><br></pre></td></tr></table></figure>

<hr>
<ul>
<li>启动mysql</li>
</ul>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">systemctl <span class="built_in">start</span> mysqld</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>若发现报错，如：Failed to start mysqld.service: Unit not found.<br>则安装mariadb：</strong></li>
<li>卸载mysql</li>
</ul>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">rpm <span class="literal">-qa</span> | grep mysql</span><br><span class="line"><span class="comment"># mysql-community-common-5.7.33-1.el7.x86_64</span></span><br><span class="line">yum <span class="literal">-y</span> remove mysql<span class="literal">-community</span><span class="literal">-common</span><span class="literal">-5</span>.<span class="number">7.33</span><span class="literal">-1</span>.el7.x86_64</span><br></pre></td></tr></table></figure>
<ul>
<li>安装mariadb（mysql的一个分支）<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">yum install <span class="literal">-y</span> mariadb<span class="literal">-server</span></span><br><span class="line">systemctl <span class="built_in">start</span> mariadb.service</span><br><span class="line">systemctl enable mariadb.service</span><br></pre></td></tr></table></figure></li>
<li>查看安装完成</li>
</ul>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/bin</span><br><span class="line">mysqladmin -<span class="literal">-version</span></span><br><span class="line"><span class="comment"># mysqladmin  Ver 9.0 Distrib 5.5.68-MariaDB, for Linux on x86_64</span></span><br></pre></td></tr></table></figure>
<ul>
<li>安装成功后进行修改密码</li>
</ul>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">mysql_secure_installation</span><br></pre></td></tr></table></figure>
<ul>
<li>登录mysql</li>
</ul>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">mysql <span class="literal">-u</span> root <span class="literal">-p</span></span><br></pre></td></tr></table></figure>
<ul>
<li>允许远程登录<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># XXXX为密码</span></span><br><span class="line">MariaDB [(<span class="type">none</span>)]&gt; GRANT ALL PRIVILEGES ON *.* TO <span class="string">&#x27;root&#x27;</span><span class="string">@&#x27;%&#x27; IDENTIFIED BY &#x27;XXXXX&#x27; WITH GRANT OPTION;</span></span><br><span class="line"><span class="string">MariaDB [(none)]&gt; flush privileges;</span></span><br></pre></td></tr></table></figure></li>
<li>接下来便可以使用Navicat等数据库工具进行远程连接<br></li>
</ul>
<h2 id="安装Redis"><a href="#安装Redis" class="headerlink" title="安装Redis"></a>安装Redis</h2><ul>
<li>下载redis压缩包</li>
</ul>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/local/redis</span><br><span class="line"><span class="built_in">wget</span> http://download.redis.io/releases/redis<span class="literal">-6</span>.<span class="number">0.8</span>.tar.gz</span><br></pre></td></tr></table></figure>
<ul>
<li>解压</li>
</ul>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">tar <span class="literal">-zxvf</span> redis<span class="literal">-6</span>.<span class="number">0.8</span>.tar.gz</span><br></pre></td></tr></table></figure>

<ul>
<li>由于Redis是由C语言编写的，所以需要安装gcc环境（使用gcc -v查看）</li>
<li>发现当前版本默认为4.8.5，而redis6.0只支持5.3版本以上的，所以我们需要升级gcc版本</li>
</ul>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 升级gcc版本</span></span><br><span class="line">yum <span class="literal">-y</span> install centos<span class="literal">-release</span><span class="literal">-scl</span></span><br><span class="line">yum <span class="literal">-y</span> install devtool<span class="built_in">set-9</span><span class="literal">-gcc</span> devtool<span class="built_in">set-9</span><span class="literal">-gcc</span><span class="literal">-c</span>++ devtool<span class="built_in">set-9</span><span class="literal">-binutils</span></span><br><span class="line"><span class="comment">#版本切换</span></span><br><span class="line">scl enable devtool<span class="built_in">set-9</span> bash</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;source /opt/rh/devtoolset-9/enable&quot;</span> &gt;&gt; /etc/profile</span><br><span class="line"><span class="comment">#查看版本</span></span><br><span class="line">gcc <span class="literal">-v</span>  </span><br></pre></td></tr></table></figure>
<ul>
<li>进入到redis的安装目录下进行编译</li>
</ul>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>

<h4 id="启动redis"><a href="#启动redis" class="headerlink" title="启动redis"></a>启动redis</h4><p>方式一：前台启动（切换至 <strong>/usr/local/bin</strong> 目录下）</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">./redis<span class="literal">-server</span></span><br></pre></td></tr></table></figure>
<hr>
<p>方式二：后台启动</p>
<ul>
<li>先将 <strong>redis.conf</strong> 拷贝到当前目录下<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cp</span> /usr/local/redis/redis<span class="literal">-6</span>.<span class="number">0.8</span>/redis.conf /usr/local/bin</span><br></pre></td></tr></table></figure></li>
<li>修改配置文件<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">vim redis.conf</span><br><span class="line"><span class="comment"># 修改 daemonize no为 yes ，开启后台启动</span></span><br><span class="line">daemonize yes</span><br><span class="line"><span class="comment"># requirepass foobared  修改你的密码</span></span><br><span class="line">requirepass xxxx</span><br></pre></td></tr></table></figure></li>
<li>启动</li>
</ul>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">./redis<span class="literal">-server</span> redis.conf</span><br></pre></td></tr></table></figure>
<ul>
<li>查看redis进程</li>
</ul>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ps</span> <span class="literal">-ef</span> |grep redis</span><br></pre></td></tr></table></figure>

<ul>
<li>进行连接测试</li>
</ul>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">redis<span class="literal">-cli</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; ping</span><br><span class="line">(error) NOAUTH Authentication required.</span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; auth <span class="string">&quot;xxxx&quot;</span></span><br><span class="line">OK</span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; ping</span><br><span class="line">PONG</span><br></pre></td></tr></table></figure>

<ul>
<li>开启远程连接（在 redis.conf 中注释掉以下内容 ）</li>
</ul>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># bind 127.0.0.1</span></span><br></pre></td></tr></table></figure>
<hr>
<br>

<h2 id="部署SpringBoot项目"><a href="#部署SpringBoot项目" class="headerlink" title="部署SpringBoot项目"></a>部署SpringBoot项目</h2><p>1、将项目的jar包上传至Linux服务器上（目录可为 /home/webapp ）</p>
<p>2、在jar包目录下编写启动脚本（ vim start.sh ）</p>
<p>脚本内容如下：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line">nohup java <span class="literal">-jar</span> club<span class="literal">-recruit</span><span class="literal">-0</span>.<span class="number">0.1</span><span class="literal">-SNAPSHOT</span>.jar &amp;</span><br></pre></td></tr></table></figure>
<p>3、修改脚本权限</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">chmod <span class="number">777</span> start.sh</span><br></pre></td></tr></table></figure>
<p>4、以后使用如下命令启动即可</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">./start.sh</span><br></pre></td></tr></table></figure>
<ul>
<li>如果想要停止这个应用，可使用如下命令查看端口占用的进程号并结束进程</li>
</ul>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">netstat <span class="literal">-anp</span> | grep 端口号</span><br><span class="line"><span class="built_in">kill</span> sid</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker搭建MySQL+Redis+Nginx+MongoDB环境</title>
    <url>/2021/04/30/Docker%E6%90%AD%E5%BB%BAMySQL-Redis-Nginx-MongoDB%E7%8E%AF%E5%A2%83/</url>
    <content><![CDATA[<h2 id="安装Docker"><a href="#安装Docker" class="headerlink" title="安装Docker"></a>安装Docker</h2><ul>
<li><a href="https://docs.docker.com/engine/install/centos/">docker官方文档链接</a></li>
</ul>
<p>1、卸载旧版本docker</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">yum remove docker \</span><br><span class="line">                  docker<span class="literal">-client</span> \</span><br><span class="line">                  docker<span class="literal">-client</span><span class="literal">-latest</span> \</span><br><span class="line">                  docker<span class="literal">-common</span> \</span><br><span class="line">                  docker<span class="literal">-latest</span> \</span><br><span class="line">                  docker<span class="literal">-latest</span><span class="literal">-logrotate</span> \</span><br><span class="line">                  docker<span class="literal">-logrotate</span> \</span><br><span class="line">                  docker<span class="literal">-engine</span></span><br></pre></td></tr></table></figure>
<p>2、安装需要的安装包（提供实用程序）</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">yum install <span class="literal">-y</span> yum<span class="literal">-utils</span></span><br></pre></td></tr></table></figure>
<p>3、设置镜像的仓库</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># yum-config-manager \</span></span><br><span class="line"><span class="comment">#     --add-repo \</span></span><br><span class="line"><span class="comment">#     https://download.docker.com/linux/centos/docker-ce.repo		# 默认国外（慢）</span></span><br><span class="line">    </span><br><span class="line"><span class="comment"># 使用阿里云镜像</span></span><br><span class="line">yum<span class="literal">-config</span><span class="literal">-manager</span> \</span><br><span class="line">    -<span class="literal">-add</span><span class="literal">-repo</span> \</span><br><span class="line">    http://mirrors.aliyun.com/docker<span class="literal">-ce</span>/linux/centos/docker<span class="literal">-ce</span>.repo</span><br></pre></td></tr></table></figure>
<p>4、安装最新版本的Docker 引擎和容器</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 可以先更新yum软件包索引</span></span><br><span class="line">yum makecache fast</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装docker</span></span><br><span class="line">yum install docker<span class="literal">-ce</span> docker<span class="literal">-ce</span><span class="literal">-cli</span> containerd.io</span><br></pre></td></tr></table></figure>
<p>5、启动docker</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">systemctl <span class="built_in">start</span> docker</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看是否安装成功</span></span><br><span class="line">docker version</span><br></pre></td></tr></table></figure>
<br>

<hr>
<h2 id="安装MySQL"><a href="#安装MySQL" class="headerlink" title="安装MySQL"></a>安装MySQL</h2><p>1、拉取镜像</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">docker pull mysql:<span class="number">5.7</span></span><br></pre></td></tr></table></figure>

<p>2、后台方式启动MySQL</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">docker run <span class="literal">-d</span> <span class="literal">-p</span> <span class="number">3306</span>:<span class="number">3306</span> <span class="literal">-v</span> /home/mysql/conf/mysqld.cnf:/etc/mysql/mysql.conf.d/mysqld.cnf <span class="literal">-v</span> /home/mysql/<span class="keyword">data</span>:/var/lib/mysql <span class="literal">-e</span> MYSQL_ROOT_PASSWORD=<span class="number">123456</span> -<span class="literal">-name</span> mysql01 mysql:<span class="number">5.7</span></span><br></pre></td></tr></table></figure>
<ul>
<li>-e MYSQL_ROOT_PASSWORD=xxxx  ：设置mysql密码。</li>
<li>-v /home/mysql/data:/var/lib/mysql ：挂载mysql数据文件到主机，当mysql容器删除后，数据依旧保存在主机。</li>
</ul>
<br>
备注：如何修改MySQL密码

<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">docker exec <span class="literal">-it</span> 容器id /bin/bash</span><br><span class="line">mysql <span class="literal">-u</span> root <span class="literal">-p</span>	</span><br><span class="line">update mysql.user <span class="built_in">set</span> authentication_string=PASSWORD(<span class="string">&#x27;xxxx&#x27;</span>), plugin=<span class="string">&#x27;mysql_native_password&#x27;</span> <span class="built_in">where</span> user=<span class="string">&#x27;root&#x27;</span>;</span><br><span class="line">flush privileges;	<span class="comment"># 刷新权限</span></span><br></pre></td></tr></table></figure>

<br>

<hr>
<h2 id="安装Redis"><a href="#安装Redis" class="headerlink" title="安装Redis"></a>安装Redis</h2><p>1、创建redis配置文件：<a href="http://download.redis.io/redis-stable/redis.conf">下载地址</a></p>
<p>2、修改配置文件</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">bind <span class="number">127.0</span>.<span class="number">0.1</span> -::<span class="number">1</span>       注释掉这一行，允许远程连接</span><br><span class="line">protected<span class="literal">-mode</span> no         将yes改为no，允许远程连接</span><br><span class="line">daemonize no		      以非守护进程的方式运行，默认为no</span><br><span class="line">requirepass yourpassword  设置密码</span><br></pre></td></tr></table></figure>
<p>3、将配置文件上传至服务器</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">mkdir /home/redis</span><br><span class="line"></span><br><span class="line">上传 redis.conf 至 /home/redis 目录下</span><br></pre></td></tr></table></figure>


<p>4、拉取redis镜像</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">docker pull redis</span><br></pre></td></tr></table></figure>
<p>5、运行Redis</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">docker run <span class="literal">-p</span> <span class="number">6379</span>:<span class="number">6379</span> <span class="literal">-v</span> /home/redis/redis.conf:/etc/redis/redis.conf <span class="literal">-v</span> /home/redis/<span class="keyword">data</span>:/<span class="keyword">data</span> <span class="literal">-d</span> redis redis<span class="literal">-server</span> /etc/redis/redis.conf</span><br></pre></td></tr></table></figure>
<br>

<hr>
<h2 id="安装nginx"><a href="#安装nginx" class="headerlink" title="安装nginx"></a>安装nginx</h2><p>1、拉取镜像</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">docker pull nginx</span><br></pre></td></tr></table></figure>
<p>2、启动测试的testnginx</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">docker run <span class="literal">-d</span> <span class="literal">-p</span> <span class="number">80</span>:<span class="number">80</span> -<span class="literal">-name</span> testnginx nginx</span><br></pre></td></tr></table></figure>
<p>3、创建三个本机存储文件目录</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">mkdir <span class="literal">-p</span> /home/nginx/www /home/nginx/logs /home/nginx/conf</span><br></pre></td></tr></table></figure>
<ul>
<li>www：存储网站网页的目录</li>
<li>logs：存储nginx日志的目录</li>
<li>conf：存储nginx配置文件的目录</li>
</ul>
<p>4、将用来测试的testnginx容器的配置文件拷贝到本机</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">cp</span> testnginx:/etc/nginx/nginx.conf /home/nginx/conf</span><br></pre></td></tr></table></figure>
<p>5、删除测试容器testnginx</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">docker stop testnginx</span><br><span class="line">docker <span class="built_in">rm</span> testnginx</span><br></pre></td></tr></table></figure>
<p>6、启动nginx</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">docker run <span class="literal">-d</span> <span class="literal">-p</span> <span class="number">80</span>:<span class="number">80</span> <span class="literal">-v</span> /home/nginx/www:/usr/share/nginx/html <span class="literal">-v</span> /home/nginx/conf/nginx.conf:/etc/nginx/nginx.conf <span class="literal">-v</span> /home/nginx/logs:/var/log/nginx -<span class="literal">-name</span> mynginx nginx </span><br></pre></td></tr></table></figure>
<p>7、浏览器测试访问</p>
<hr>
<h2 id="安装MongoDB"><a href="#安装MongoDB" class="headerlink" title="安装MongoDB"></a>安装MongoDB</h2><p>1、拉取镜像</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">docker pull mongo:<span class="number">4.4</span>.<span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>2、启动</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">docker run <span class="literal">-p</span> <span class="number">27017</span>:<span class="number">27017</span> -<span class="literal">-name</span> mongo <span class="literal">-v</span> /home/mongo/db:/<span class="keyword">data</span>/db <span class="literal">-d</span> mongo:<span class="number">4.4</span>.<span class="number">1</span> -<span class="literal">-auth</span></span><br></pre></td></tr></table></figure>
<p>3、进入容器</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">docker exec <span class="literal">-it</span> mongo mongo</span><br></pre></td></tr></table></figure>
<p>4、添加管理员用户</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">use admin		<span class="comment">#切换数据库</span></span><br><span class="line">&gt; db.createUser(&#123;		</span><br><span class="line">... user: <span class="string">&quot;KimTou&quot;</span>,</span><br><span class="line">... <span class="built_in">pwd</span>: <span class="string">&quot;xxxx你的密码&quot;</span>,</span><br><span class="line">... roles: [&#123; <span class="type">role</span>:<span class="string">&quot;root&quot;</span>,<span class="type">db</span>:<span class="string">&quot;admin&quot;</span> &#125;] &#125;);</span><br><span class="line">&gt; db.auth(<span class="string">&quot;KimTou&quot;</span>,<span class="string">&quot;xxxx你的密码&quot;</span>)	<span class="comment"># 测试</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
</search>
