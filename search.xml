<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>初始RocketMQ</title>
      <link href="/2021/09/12/%E5%88%9D%E5%A7%8BRocketMQ/"/>
      <url>/2021/09/12/%E5%88%9D%E5%A7%8BRocketMQ/</url>
      
        <content type="html"><![CDATA[<p><strong>RocketMQ</strong> 是一个 <strong>队列模型</strong> 的消息中间件，具有<strong>高性能、高可靠、高实时、分布式</strong> 的特点。</p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="核心组成"><a href="#核心组成" class="headerlink" title="核心组成"></a>核心组成</h3><p>RocketMQ的四大核心组成部分：<strong>NameServer</strong>、<strong>Broker</strong>、<strong>Producer</strong>以及<strong>Consumer</strong></p><hr><h4 id="名字服务-NameServer"><a href="#名字服务-NameServer" class="headerlink" title="名字服务 NameServer"></a>名字服务 NameServer</h4><blockquote><p>主要负责对于源数据的管理，包括了对于<strong>Topic</strong>和路由信息的管理。</p></blockquote><p>名称服务充当路由消息的提供者。生产者或消费者能够通过名字服务查找各主题相应的Broker IP列表。多个Namesrv实例组成集群，<strong>每个NameServer节点相互独立，没有信息交换。</strong></p><p><strong>每个 Broker 在启动的时候会到 NameServer 注册，Producer 在发送消息前会根据 Topic 到 NameServer 获取到 Broker 的路由信息，Consumer 也会定时获取 Topic 的路由信息。</strong></p><hr><h4 id="代理服务器-Broker"><a href="#代理服务器-Broker" class="headerlink" title="代理服务器 Broker"></a>代理服务器 Broker</h4><p><strong>消息中转角色，负责存储消息、转发消息。</strong>代理服务器在RocketMQ系统中负责接收从生产者发送来的消息并存储、同时为消费者的拉取请求作准备。代理服务器也存储消息相关的元数据，包括消费者组、消费进度偏移和主题和队列消息等。</p><hr><h4 id="消息生产者-Producer"><a href="#消息生产者-Producer" class="headerlink" title="消息生产者 Producer"></a>消息生产者 Producer</h4><p><strong>负责生产消息</strong>，一般由业务系统负责生产消息。一个消息生产者会把业务应用系统里产生的消息发送到broker服务器。RocketMQ提供多种发送方式，同步发送、异步发送、顺序发送、单向发送。同步和异步方式均需要Broker返回确认信息，单向发送不需要。</p><hr><h4 id="消息消费者-Consumer"><a href="#消息消费者-Consumer" class="headerlink" title="消息消费者 Consumer"></a>消息消费者 Consumer</h4><p><strong>负责消费消息</strong>，一般是后台系统负责异步消费。一个消息消费者会从Broker服务器拉取消息、并将其提供给应用程序。从用户应用的角度而言提供了两种消费形式：拉取式消费、推动式消费。</p><hr><h3 id="消息领域模型"><a href="#消息领域模型" class="headerlink" title="消息领域模型"></a>消息领域模型</h3><h4 id="消息模型-Message-Model"><a href="#消息模型-Message-Model" class="headerlink" title="消息模型 Message Model"></a>消息模型 Message Model</h4><p>RocketMQ主要由 Producer、Broker、Consumer 三部分组成，其中Producer 负责生产消息，Consumer 负责消费消息，Broker 负责存储消息。Broker 在实际部署过程中对应一台服务器，<strong>每个 Broker 可以存储多个Topic的消息，每个Topic的消息也可以分片存储于不同的 Broker。</strong>Message Queue 用于存储消息的物理地址，每个Topic中的消息地址存储于多个 Message Queue 中。ConsumerGroup 由多个Consumer 实例构成。</p><h4 id="消息-Message"><a href="#消息-Message" class="headerlink" title="消息 Message"></a>消息 Message</h4><p><strong>消息系统所传输信息的物理载体，生产和消费数据的最小单位</strong>，每条消息必须属于一个主题。RocketMQ中每个消息拥有唯一的Message ID，且可以携带具有业务标识的Key。系统提供了通过Message ID和Key查询消息的功能。</p><h4 id="主题-Topic"><a href="#主题-Topic" class="headerlink" title="主题 Topic"></a>主题 Topic</h4><p><strong>表示一类消息的集合</strong>，每个主题包含若干条消息，每条消息只能属于一个主题，是RocketMQ进行消息订阅的基本单位。</p><blockquote><p><strong>Topic</strong> 与生产者和消费者的关系非常松散，一个 Topic 可以有0个、1个、多个生产者向其发送消息，一个生产者也可以同时向不同的 Topic 发送消息。</p><p>一个 Topic 也可以被 0个、1个、多个消费者订阅。</p></blockquote><h4 id="标签-Tag"><a href="#标签-Tag" class="headerlink" title="标签 Tag"></a>标签 Tag</h4><p><strong>为消息设置的标志，用于同一主题下区分不同类型的消息</strong>。来自同一业务单元的消息，可以根据不同业务目的在同一主题下设置不同标签。标签能够有效地保持代码的清晰度和连贯性，并优化RocketMQ提供的查询系统。消费者可以根据Tag实现对不同子主题的不同消费逻辑，实现更好的扩展性。</p><h4 id="分组-Group"><a href="#分组-Group" class="headerlink" title="分组 Group"></a>分组 Group</h4><p>分为ProducerGroup，ConsumerGroup，代表某一类的生产者和消费者，一个组可以订阅多个Topic。</p><p><strong>ProducerGroup</strong>代表同一类Producer的集合，这类Producer发送同一类消息且发送逻辑一致。如果发送的是事务消息且原始生产者在发送之后崩溃，则Broker服务器会联系同一生产者组的其他生产者实例以提交或回溯消费。</p><p><strong>ConsumerGroup</strong>代表同一类Consumer的集合，这类Consumer通常消费同一类消息且消费逻辑一致。消费者组使得在消息消费方面，实现负载均衡和容错的目标变得非常容易。要注意的是，消费者组的消费者实例必须订阅完全相同的Topic。RocketMQ 支持两种消息模式：集群消费（Clustering）和广播消费（Broadcasting）。</p><h3 id="消费模式"><a href="#消费模式" class="headerlink" title="消费模式"></a>消费模式</h3><h4 id="集群消费-Clustering"><a href="#集群消费-Clustering" class="headerlink" title="集群消费 Clustering"></a>集群消费 Clustering</h4><p>集群消费模式下,相同Consumer Group的每个Consumer实例平均分摊消息。</p><h4 id="广播消费-Broadcasting"><a href="#广播消费-Broadcasting" class="headerlink" title="广播消费 Broadcasting"></a>广播消费 Broadcasting</h4><p>广播消费模式下，相同Consumer Group的每个Consumer实例都接收全量的消息。</p><h3 id="消费类型"><a href="#消费类型" class="headerlink" title="消费类型"></a>消费类型</h3><h4 id="拉取式消费-Pull-Consumer"><a href="#拉取式消费-Pull-Consumer" class="headerlink" title="拉取式消费 Pull Consumer"></a>拉取式消费 Pull Consumer</h4><p>Consumer消费的一种类型，应用通常主动调用Consumer的拉消息方法从Broker服务器拉消息、主动权由应用控制。一旦获取了批量消息，应用就会启动消费过程。</p><h4 id="推动式消费-Push-Consumer"><a href="#推动式消费-Push-Consumer" class="headerlink" title="推动式消费 Push Consumer"></a>推动式消费 Push Consumer</h4><p>Consumer消费的一种类型，该模式下Broker收到数据后会主动推送给消费端，该消费模式一般实时性较高。</p><hr><h2 id="架构设计"><a href="#架构设计" class="headerlink" title="架构设计"></a>架构设计</h2><img src="https://gitee.com/KIMTOU/img/raw/master/20210912214133.png" style="zoom:150%;" /><p><strong>RocketMQ架构上主要分为四部分</strong>，如上图所示:</p><ul><li><strong>Producer：消息发布的角色</strong>，支持分布式集群方式部署。Producer通过MQ的负载均衡模块选择相应的Broker集群队列进行消息投递，投递的过程支持快速失败并且低延迟。</li><li><strong>Consumer：消息消费的角色</strong>，支持分布式集群方式部署。支持以push推，pull拉两种模式对消息进行消费。同时也支持集群方式和广播方式的消费，它提供实时消息订阅机制，可以满足大多数用户的需求。</li><li><strong>NameServer：NameServer是一个非常简单的Topic路由注册中心</strong>，其角色类似Dubbo中的zookeeper，支持Broker的动态注册与发现。<strong>主要包括两个功能：Broker管理</strong>，NameServer接受Broker集群的注册信息并且保存下来作为路由信息的基本数据。然后提供心跳检测机制，检查Broker是否还存活；<strong>路由信息管理</strong>，每个NameServer将保存关于Broker集群的整个路由信息和用于客户端查询的队列信息。然后Producer和Conumser通过NameServer就可以知道整个Broker集群的路由信息，从而进行消息的投递和消费。NameServer通常也是集群的方式部署，各实例间相互不进行信息通讯。Broker是向每一台NameServer注册自己的路由信息，所以每一个NameServer实例上面都保存一份完整的路由信息。当某个NameServer因某种原因下线了，Broker仍然可以向其它NameServer同步其路由信息，Producer,Consumer仍然可以动态感知Broker的路由的信息。</li><li><strong>BrokerServer：Broker主要负责消息的存储、投递和查询以及服务高可用保证</strong></li></ul><h4 id="RocketMQ-网络部署特点"><a href="#RocketMQ-网络部署特点" class="headerlink" title="RocketMQ 网络部署特点"></a>RocketMQ 网络部署特点</h4><ul><li>NameServer是一个几乎无状态节点，可集群部署，节点之间无任何信息同步。</li><li>Broker部署相对复杂，Broker分为Master与Slave，一个Master可以对应多个Slave，但是一个Slave只能对应一个Master，Master与Slave 的对应关系通过指定相同的BrokerName，不同的BrokerId 来定义，BrokerId为0表示Master，非0表示Slave。Master也可以部署多个。每个Broker与NameServer集群中的所有节点建立长连接，定时注册Topic信息到所有NameServer。 注意：当前RocketMQ版本在部署架构上支持一Master多Slave，但只有BrokerId=1的从服务器才会参与消息的读负载。</li><li>Producer与NameServer集群中的其中一个节点（随机选择）建立长连接，定期从NameServer获取Topic路由信息，并向提供Topic 服务的Master建立长连接，且定时向Master发送心跳。Producer完全无状态，可集群部署。</li><li>Consumer与NameServer集群中的其中一个节点（随机选择）建立长连接，定期从NameServer获取Topic路由信息，并向提供Topic服务的Master、Slave建立长连接，且定时向Master、Slave发送心跳。Consumer既可以从Master订阅消息，也可以从Slave订阅消息，消费者在向Master拉取消息时，Master服务器会根据拉取偏移量与最大偏移量的距离（判断是否读老消息，产生读I/O），以及从服务器是否可读等因素建议下一次是从Master还是Slave拉取。</li></ul><h4 id="集群工作流程"><a href="#集群工作流程" class="headerlink" title="集群工作流程"></a>集群工作流程</h4><ul><li>启动NameServer，NameServer起来后监听端口，等待Broker、Producer、Consumer连上来，相当于一个路由控制中心。</li><li>Broker启动，跟所有的NameServer保持长连接，定时发送心跳包。心跳包中包含当前Broker信息(IP+端口等)以及存储所有Topic信息。注册成功后，NameServer集群中就有Topic跟Broker的映射关系。</li><li>收发消息前，先创建Topic，创建Topic时需要指定该Topic要存储在哪些Broker上，也可以在发送消息时自动创建Topic。</li><li>Producer发送消息，启动时先跟NameServer集群中的其中一台建立长连接，并从NameServer中获取当前发送的Topic存在哪些Broker上，轮询从队列列表中选择一个队列，然后与队列所在的Broker建立长连接从而向Broker发消息。</li><li>Consumer跟Producer类似，跟其中一台NameServer建立长连接，获取当前订阅Topic存在哪些Broker上，然后直接跟Broker建立连接通道，开始消费消息。</li></ul><hr><h2 id="安装启动（Linux）"><a href="#安装启动（Linux）" class="headerlink" title="安装启动（Linux）"></a>安装启动（Linux）</h2><h4 id="1、下载压缩包"><a href="#1、下载压缩包" class="headerlink" title="1、下载压缩包"></a>1、下载压缩包</h4><p>镜像下载地址：<a href="https://mirrors.bfsu.edu.cn/apache/rocketmq/4.9.1/rocketmq-all-4.9.1-source-release.zip"><strong>https://mirrors.bfsu.edu.cn/apache/rocketmq/4.9.1/rocketmq-all-4.9.1-source-release.zip</strong></a></p><h4 id="2、将压缩包上传至Linux"><a href="#2、将压缩包上传至Linux" class="headerlink" title="2、将压缩包上传至Linux"></a>2、将压缩包上传至Linux</h4><ul><li>解压</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unzip rocketmq-all-4.9.1-source-release.zip</span><br></pre></td></tr></table></figure><h4 id="3、修改配置文件"><a href="#3、修改配置文件" class="headerlink" title="3、修改配置文件"></a>3、修改配置文件</h4><p>启动顺序为先启动NameServer，再启动Broker。但是启动之前需要先检查自己服务器内存情况，因为默认参数需要的JVM内存较大，因此需要修改这两个的配置文件（<code>runserver.sh</code>、<code>runbroker.sh</code>）。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 进入对应目录</span></span><br><span class="line">cd /home/rocketmq/rocketmq-all-4.9.1-bin-release/bin</span><br><span class="line"><span class="meta">#</span><span class="bash"> 修改NameServer配置文件</span></span><br><span class="line">vim runserver.sh</span><br></pre></td></tr></table></figure><ul><li>查找JVM配置：</li></ul><p><img src="https://gitee.com/KIMTOU/img/raw/master/20210912214128.PNG"></p><ul><li>将其修改成：</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JAVA_OPT=&quot;$&#123;JAVA_OPT&#125; -server -Xms256m -Xmx256m -Xmn128m -XX:MetaspaceSize=128m -XX:MaxMetaspaceSize=320m&quot;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 修改Broker配置文件</span></span><br><span class="line">vim runbroker.sh</span><br></pre></td></tr></table></figure><ul><li>查找JVM配置：</li></ul><p><img src="https://gitee.com/KIMTOU/img/raw/master/20210912214122.PNG"></p><p>将其修改成：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JAVA_OPT=&quot;$&#123;JAVA_OPT&#125; -server -Xms256m -Xmx256m&quot;</span><br></pre></td></tr></table></figure><h4 id="4、启动"><a href="#4、启动" class="headerlink" title="4、启动"></a>4、启动</h4><ul><li>进入bin目录</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@CJT-Linux bin]# pwd</span><br><span class="line">/home/rocketmq/rocketmq-all-4.9.1-bin-release/bin</span><br></pre></td></tr></table></figure><ul><li>启动NameServer</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup sh mqnamesrv &amp;</span><br></pre></td></tr></table></figure><ul><li>检查是否启动成功</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tail -f ~/logs/rocketmqlogs/namesrv.log</span><br><span class="line"><span class="meta">#</span><span class="bash"> 出现 The Name Server boot success...代表启动成功</span></span><br></pre></td></tr></table></figure><ul><li>启动Broker</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup sh mqbroker -n localhost:9876 &amp;</span><br></pre></td></tr></table></figure><ul><li>检查是否启动成功</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tail -f ~/logs/rocketmqlogs/broker.log </span><br></pre></td></tr></table></figure><h4 id="5、测试"><a href="#5、测试" class="headerlink" title="5、测试"></a>5、测试</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 配置NameServer地址</span></span><br><span class="line">export NAMESRV_ADDR=localhost:9876</span><br><span class="line"><span class="meta">#</span><span class="bash"> 生产数据</span></span><br><span class="line">sh tools.sh org.apache.rocketmq.example.quickstart.Producer</span><br><span class="line"><span class="meta">#</span><span class="bash"> 消费数据</span></span><br><span class="line">sh tools.sh org.apache.rocketmq.example.quickstart.Consumer</span><br></pre></td></tr></table></figure><h4 id="Window环境下安装启动"><a href="#Window环境下安装启动" class="headerlink" title="Window环境下安装启动"></a>Window环境下安装启动</h4><p>1、下载压缩包并解压</p><p>2、配置系统环境</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">ROCKETMQ_HOME</span>=<span class="string">&quot;D:\rocketmq&quot;</span></span><br><span class="line"><span class="attr">NAMESRV_ADDR</span>=<span class="string">&quot;localhost:9876&quot;</span></span><br></pre></td></tr></table></figure><p>3、在bin目录下启动<code>mqnamesrv.cmd</code>，再启动<code>mqbroker.cmd</code></p><hr><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>中文官方文档：<a href="https://github.com/apache/rocketmq/blob/master/docs/cn">https://github.com/apache/rocketmq/blob/master/docs/cn</a></p><p><a href="https://blog.csdn.net/qq_35190492/article/details/103341634?ops_request_misc=%7B%22request_id%22:%22162972269016780271584378%22,%22scm%22:%2220140713.130102334.pc_blog.%22%7D&request_id=162972269016780271584378&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_v2~rank_v29-1-103341634.pc_v2_rank_blog_default&utm_term=rocket&spm=1018.2226.3001.4450">看完保送阿里的RocketMQ知识点（超详细）_敖丙-CSDN博客</a></p><p><a href="http://rocketmq.apache.org/docs/quick-start/">Quick Start - Apache RocketMQ</a></p>]]></content>
      
      
      <categories>
          
          <category> 消息队列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 消息队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指 Offer 31.栈的压入、弹出序列</title>
      <link href="/2021/09/12/%E5%89%91%E6%8C%87-Offer-31-%E6%A0%88%E7%9A%84%E5%8E%8B%E5%85%A5%E3%80%81%E5%BC%B9%E5%87%BA%E5%BA%8F%E5%88%97/"/>
      <url>/2021/09/12/%E5%89%91%E6%8C%87-Offer-31-%E6%A0%88%E7%9A%84%E5%8E%8B%E5%85%A5%E3%80%81%E5%BC%B9%E5%87%BA%E5%BA%8F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><strong>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如，序列 {1,2,3,4,5} 是某栈的压栈序列，序列 {4,5,3,2,1} 是该压栈序列对应的一个弹出序列，但 {4,3,5,1,2} 就不可能是该压栈序列的弹出序列。</strong></p><p>示例 1：</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：pushed = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>], popped = [<span class="number">4</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">输出：<span class="literal">true</span></span><br><span class="line">解释：我们可以按以下顺序执行：</span><br><span class="line">push<span class="function"><span class="params">(<span class="number">1</span>)</span>, <span class="title">push</span><span class="params">(<span class="number">2</span>)</span>, <span class="title">push</span><span class="params">(<span class="number">3</span>)</span>, <span class="title">push</span><span class="params">(<span class="number">4</span>)</span>, <span class="title">pop</span><span class="params">()</span> -&gt;</span> <span class="number">4</span>,</span><br><span class="line">push<span class="function"><span class="params">(<span class="number">5</span>)</span>, <span class="title">pop</span><span class="params">()</span> -&gt;</span> <span class="number">5</span>, pop<span class="function"><span class="params">()</span> -&gt;</span> <span class="number">3</span>, pop<span class="function"><span class="params">()</span> -&gt;</span> <span class="number">2</span>, pop<span class="function"><span class="params">()</span> -&gt;</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">pushed</span> = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>], <span class="attr">popped</span> = [<span class="number">4</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">输出：<span class="literal">false</span></span><br><span class="line">解释：<span class="number">1</span> 不能在 <span class="number">2</span> 之前弹出。</span><br></pre></td></tr></table></figure><p>提示：</p><ol><li>0 &lt;= pushed.length == popped.length &lt;= 1000</li><li>0 &lt;= pushed[i], popped[i] &lt; 1000</li><li>pushed 是 popped 的排列。</li></ol><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><h3 id="利用数组模拟栈"><a href="#利用数组模拟栈" class="headerlink" title="利用数组模拟栈"></a>利用数组模拟栈</h3><h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>既然题目给我们的压入、弹出序列是数组，那么我们创建一个数组来模拟一个栈，作为中间的一个辅助栈，其长度最大不会超过pushed压入序列的长度。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] stack = <span class="keyword">new</span> <span class="keyword">int</span>[pushed.length];</span><br></pre></td></tr></table></figure><p><strong>算法实现：</strong></p><p>1、遍历压入序列<code>pushed</code>的元素，并将其压入辅助栈<code>stack</code>。若遍历完压入序列<code>pushed</code>，则进行步骤三。</p><p>2、辅助栈每压入一个元素，就去循环判断自己的栈顶元素与<code>popped</code>序列的栈顶元素是否相同。相同则一起弹出该元素并指针下移，继续判断下一栈顶元素是否相同；若不相同，则回到步骤一。</p><p>3、检查辅助栈是否为空，若辅助栈不为空，则popped序列不是弹出序列。</p><p><strong>关于循环条件的说明：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (stackIndex &gt;= <span class="number">0</span> &amp;&amp; popIndex &lt; popped.length &amp;&amp;</span><br><span class="line">                                 stack[stackIndex] == popped[popIndex])</span><br></pre></td></tr></table></figure><p>由于题目说明指出压入序列与弹出序列长度相同（<code>0 &lt;= pushed.length == popped.length &lt;= 1000</code>），且stack数组在当前循环中的长度小于等于pushed压入序列，故可知stack数组在当前循环中的长度必然小于等于poped弹出序列长度，因此我们便可把循环条件简化为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (stackIndex &gt;= <span class="number">0</span> &amp;&amp; stack[stackIndex] == popped[popIndex])</span><br></pre></td></tr></table></figure><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">validateStackSequences</span><span class="params">(<span class="keyword">int</span>[] pushed, <span class="keyword">int</span>[] popped)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pushIndex = <span class="number">0</span>, popIndex = <span class="number">0</span>, stackIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] stack = <span class="keyword">new</span> <span class="keyword">int</span>[pushed.length];</span><br><span class="line">        <span class="keyword">while</span> (pushIndex &lt; pushed.length)&#123;</span><br><span class="line">            stack[stackIndex] = pushed[pushIndex++];</span><br><span class="line">            <span class="keyword">while</span> (stackIndex &gt;= <span class="number">0</span> &amp;&amp; stack[stackIndex] == popped[popIndex])&#123;</span><br><span class="line">                stackIndex--;</span><br><span class="line">                popIndex++;</span><br><span class="line">            &#125;</span><br><span class="line">            stackIndex++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stackIndex == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度O(N)：N为<code>pushed</code>压入序列的元素个数，每个元素最多入栈、出栈一次，即最多2N次出入栈操作</li><li>空间复杂度O(N)：创建模拟栈stack，最多同时存储N个元素</li></ul><h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">validateStackSequences</span><span class="params">(<span class="keyword">int</span>[] pushed, <span class="keyword">int</span>[] popped)</span> </span>&#123;</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : pushed)&#123;</span><br><span class="line">            stack.push(num);</span><br><span class="line">            <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; stack.peek() == popped[i])&#123;</span><br><span class="line">                stack.pop();</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><ul><li>题目链接：<a href="https://leetcode-cn.com/problems/zhan-de-ya-ru-dan-chu-xu-lie-lcof/">剑指 Offer 31. 栈的压入、弹出序列 - 力扣（LeetCode） (leetcode-cn.com)</a></li><li>题解链接：<a href="https://leetcode-cn.com/problems/zhan-de-ya-ru-dan-chu-xu-lie-lcof/solution/zhi-xing-yong-shi-0-ms-li-yong-shu-zu-mo-1vwk/">执行用时: 0 ms 利用数组模拟栈（剑指31.栈的压入、弹出序列） - 栈的压入、弹出序列 - 力扣（LeetCode） (leetcode-cn.com)</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 8新特性：Lambda表达式, Stream API, Optional类</title>
      <link href="/2021/08/15/Java-8%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%9ALambda%E8%A1%A8%E8%BE%BE%E5%BC%8F-Stream-API-Optional%E7%B1%BB/"/>
      <url>/2021/08/15/Java-8%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%9ALambda%E8%A1%A8%E8%BE%BE%E5%BC%8F-Stream-API-Optional%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<p>在 Java 8 中，增加了Lambda表达式、函数式接口、接口的默认方法和静态方法等语言新特性；在类库方面又新增了Stream API、Optional类等。</p><h2 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h2><p>Lambda 表达式 − Lambda允许把函数作为一个方法的参数（函数作为参数传递进方法中。</p><h2 id="Stream-API"><a href="#Stream-API" class="headerlink" title="Stream API"></a>Stream API</h2><h3 id="什么是Stream"><a href="#什么是Stream" class="headerlink" title="什么是Stream"></a>什么是Stream</h3><blockquote><p>Stream（流）是一个来自数据源的元素队列，它可以支持聚合操作，极大简化了集合的操作。</p><ul><li>数据源：流的数据来源，构造Stream对象的数据源，比如通过一个List来构造Stream对象，这个List就是数据源；</li><li>聚合操作：对Stream对象进行处理后使得Stream对象返回指定规则数据的操作称之为聚合操作，比如filter、map、limit、sorted等都是聚合操作。</li></ul></blockquote><h3 id="Stream聚合操作"><a href="#Stream聚合操作" class="headerlink" title="Stream聚合操作"></a>Stream聚合操作</h3><p>这里使用一个实体类（User）作为示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Long userId;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例数据：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">User user1 = <span class="keyword">new</span> User(<span class="number">1001L</span>, <span class="string">&quot;小明&quot;</span>, <span class="number">21</span>, <span class="string">&quot;深圳&quot;</span>);</span><br><span class="line">User user2 = <span class="keyword">new</span> User(<span class="number">1002L</span>, <span class="string">&quot;小红&quot;</span>, <span class="number">23</span>, <span class="string">&quot;成都&quot;</span>);</span><br><span class="line">User user3 = <span class="keyword">new</span> User(<span class="number">1003L</span>, <span class="string">&quot;小华&quot;</span>, <span class="number">25</span>, <span class="string">&quot;广州&quot;</span>);</span><br><span class="line">User user4 = <span class="keyword">new</span> User(<span class="number">1004L</span>, <span class="string">&quot;大海&quot;</span>, <span class="number">30</span>, <span class="string">&quot;杭州&quot;</span>);</span><br><span class="line">List&lt;User&gt; userList = Arrays.asList(user1, user2, user3, user4);</span><br></pre></td></tr></table></figure><h4 id="流的创建"><a href="#流的创建" class="headerlink" title="流的创建"></a>流的创建</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="comment">//创建一个顺序流</span></span><br><span class="line">Stream&lt;String&gt; stream = list.stream();</span><br><span class="line"><span class="comment">//创建一个并行流</span></span><br><span class="line">Stream&lt;String&gt; parallelStream = list.parallelStream();</span><br><span class="line"></span><br><span class="line"><span class="comment">//将示例数据转换成流</span></span><br><span class="line">Stream&lt;User&gt; userStream = userList.stream();</span><br></pre></td></tr></table></figure><ul><li>顺序流与并行流的区别</li></ul><p>stream是顺序流，由主线程按顺序对流执行操作； parallelStream是并行流，内部以多线程并行执行的方式对流进行操作，但前提是流中的数据处理没有顺序要求。</p><h4 id="collect收集"><a href="#collect收集" class="headerlink" title="collect收集"></a>collect收集</h4><p><strong>collect方法用于传入一个Collector实例，将流转换为其他数据结构并返回</strong></p><ul><li>将List集合转换为Set集合</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;User&gt; collect = userList.stream()</span><br><span class="line">        .collect(Collectors.toSet());</span><br></pre></td></tr></table></figure><ul><li>将List集合转换为Map集合</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Long, User&gt; collect = userList.stream()</span><br><span class="line">        .collect(Collectors.toMap(User::getUserId, user -&gt; user));</span><br></pre></td></tr></table></figure><h4 id="filter过滤"><a href="#filter过滤" class="headerlink" title="filter过滤"></a>filter过滤</h4><p><strong>根据一定规则对stream流进行过滤，将符合条件的元素提取到新的流中</strong></p><ul><li>筛选出List集合大于6的数据</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamAPI</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; list = Arrays.asList(<span class="number">2</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>);</span><br><span class="line">        Stream&lt;Integer&gt; stream = list.stream();</span><br><span class="line">        stream.filter(num -&gt; num &gt; <span class="number">6</span>).forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>将示例数据中年龄大于24的数据筛选出来</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;User&gt; collect = userList.stream()</span><br><span class="line">                .filter(user -&gt; user.getAge() &lt; <span class="number">24</span>)</span><br><span class="line">                .collect(Collectors.toList());</span><br></pre></td></tr></table></figure><h4 id="map映射"><a href="#map映射" class="headerlink" title="map映射"></a>map映射</h4><p>将流的元素按照一定映射规则进行转换处理后映射到另一个流中</p><ul><li>将实例集合中的对象的name映射为新的List集合</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; collect = userList.stream()</span><br><span class="line">        .map(user -&gt; user.getUserName())</span><br><span class="line">        .collect(Collectors.toList());</span><br></pre></td></tr></table></figure><h4 id="distinct去重"><a href="#distinct去重" class="headerlink" title="distinct去重"></a>distinct去重</h4><p>将stream流中的相同元素进行去重处理（通过流中元素的 hashCode() 和 equals() 去除重复元素）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;User&gt; collect = userList.stream()</span><br><span class="line">        .distinct()</span><br><span class="line">        .collect(Collectors.toList());</span><br></pre></td></tr></table></figure><h4 id="limit"><a href="#limit" class="headerlink" title="limit"></a>limit</h4><p>从stream流中获取指定个数的元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;User&gt; collect = userList.stream()</span><br><span class="line">        .limit(<span class="number">2</span>)</span><br><span class="line">        .collect(Collectors.toList());</span><br></pre></td></tr></table></figure><h4 id="skip"><a href="#skip" class="headerlink" title="skip"></a>skip</h4><p>跳过指定个数的流中的元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;User&gt; collect = userList.stream()</span><br><span class="line">        .skip(<span class="number">2</span>)</span><br><span class="line">        .collect(Collectors.toList());</span><br></pre></td></tr></table></figure><h4 id="分页操作"><a href="#分页操作" class="headerlink" title="分页操作"></a>分页操作</h4><p>使用limit配合skip可实现分页操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;User&gt; collect = userList.stream()</span><br><span class="line">        .skip(<span class="number">0</span>)</span><br><span class="line">        .limit(<span class="number">2</span>)</span><br><span class="line">        .collect(Collectors.toList());</span><br></pre></td></tr></table></figure><h4 id="count"><a href="#count" class="headerlink" title="count"></a>count</h4><p>返回stream流中元素个数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> count = userList.stream().count();</span><br></pre></td></tr></table></figure><h4 id="sorted排序"><a href="#sorted排序" class="headerlink" title="sorted排序"></a>sorted排序</h4><p>按照某种规则对元素进行排序</p><p>排序有两种方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自然排序，流中元素需要实现Comparable接口</span></span><br><span class="line"><span class="function">Stream&lt;T&gt; <span class="title">sorted</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// Comparator自定义排序</span></span><br><span class="line"><span class="function">Stream&lt;T&gt; <span class="title">sorted</span><span class="params">(Comparator&lt;? <span class="keyword">super</span> T&gt; comparator)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>年龄大的排在前面</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;User&gt; collect = userList.stream()</span><br><span class="line">        .sorted((userA, userB) -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> userB.getAge().compareTo(userA.getAge());</span><br><span class="line">        &#125;)</span><br><span class="line">        .collect(Collectors.toList());</span><br></pre></td></tr></table></figure><h2 id="Optional类"><a href="#Optional类" class="headerlink" title="Optional类"></a>Optional类</h2><p>Optional类主要是用于解决<strong>空指针异常NullPointerException</strong>，它能帮助我们减少各种null检查的代码，使程序变得更加简洁，从Java 8开始成为类库的一部分。</p><h4 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h4><p>从下面源码可以发现，Optional类维护了一个变量value，初始时其值为null。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Optional</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Optional&lt;?&gt; EMPTY = <span class="keyword">new</span> Optional&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> T value;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Optional</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span>&lt;T&gt; Optional&lt;T&gt; <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">        Optional&lt;T&gt; t = (Optional&lt;T&gt;) EMPTY;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Constructs an instance with the value present.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Optional</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = Objects.requireNonNull(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns an &#123;<span class="doctag">@code</span> Optional&#125; with the specified present non-null value.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Optional&lt;T&gt; <span class="title">of</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Optional&lt;&gt;(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Optional&lt;T&gt; <span class="title">ofNullable</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value == <span class="keyword">null</span> ? empty() : of(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果value值为空，则抛出异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException(<span class="string">&quot;No value present&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>可以看到，<code>of</code>以及<code>ofNullable</code>这两个方法都可以创建Optional对象，那么它们有上面不同呢。主要在于使用<code>of</code>方法创建对象时，如果传入的value值为null，则会报NullPointerException空指针异常；而<code>ofNullable</code>方法不会报空指针异常，而是创建一个空的Optional对象。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://blog.nowcoder.net/n/4e5c389e638147938bcd7b2340474a45">字节二面被问“Java Stream 流操作‘’？看完这篇，教你自信应对！</a></p><p><a href="http://www.macrozheng.com/#/technology/java_stream?id=java-8%E9%83%BD%E5%87%BA%E9%82%A3%E4%B9%88%E4%B9%85%E4%BA%86%EF%BC%8Cstream-api%E4%BA%86%E8%A7%A3%E4%B8%8B%EF%BC%9F">Java 8都出那么久了，Stream API了解下？</a></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot实现MySQL读写分离</title>
      <link href="/2021/05/27/SpringBoot%E5%AE%9E%E7%8E%B0MySQL%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB/"/>
      <url>/2021/05/27/SpringBoot%E5%AE%9E%E7%8E%B0MySQL%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB/</url>
      
        <content type="html"><![CDATA[<h2 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a>读写分离</h2><p>在高并发下，需要对应用进行读写分离，配置多数据源，即写操作走主库，读操作则走从库，主从数据库负责各自的读和写，缓解了锁的争用，提高了读取性能。</p><p>实现读写分离有多种方式，如使用中间件MyCat、Sharding-JDBC等，这里我们使用<strong>Aop</strong>的方式在代码层面实现读写分离。</p><h4 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h4><p>实现读写分离，首先要对Mysql做主从复制，即搭建一个主数据库，以及一个或多个从数据库。</p><p>具体实现主从复制，可参照<a href="https://blog.tojintao.cn/2021/05/27/%E5%9F%BA%E4%BA%8Edocker%E5%AE%9E%E7%8E%B0MySQL%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/">《基于docker实现MySQL主从复制》</a></p><p>使用Aop的方式，当调用业务层方法前，判断请求是否是只读操作，动态切换数据源，如果是只读操作，则切换从数据库的数据源，否则使用主数据库的数据源。</p><h4 id="系统架构"><a href="#系统架构" class="headerlink" title="系统架构"></a>系统架构</h4><p>:rocket: 项目仓库：<a href="https://github.com/KimTou/Open-LetFit">KimTou/Open-LetFit: LetFit小程序后台开源版 </a></p><p>这是我之前写的一个项目，具体代码可以在可以在上面我的GitHub仓库中找到，项目就是使用了本文章介绍的读写分离方式，感兴趣的同学可以作为参考。</p><p><img src="https://gitee.com/KIMTOU/img/raw/master/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84.png"></p><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><ul><li><strong>在application.yml配置MySQL</strong></li></ul><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">com.alibaba.druid.pool.DruidDataSource</span></span><br><span class="line">    <span class="comment">#主机</span></span><br><span class="line">    <span class="attr">master:</span></span><br><span class="line">      <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">      <span class="attr">password:</span> <span class="number">123456</span></span><br><span class="line">      <span class="attr">url:</span> <span class="string">jdbc:mysql://服务器ip:3306/letfit?useSSL=false&amp;useUnicode=true&amp;characterEncoding=utf8&amp;serverTimezone=GMT</span></span><br><span class="line">      <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">    <span class="comment">#从机</span></span><br><span class="line">    <span class="attr">slave:</span></span><br><span class="line">      <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">      <span class="attr">password:</span> <span class="number">123456</span></span><br><span class="line">      <span class="attr">url:</span> <span class="string">jdbc:mysql://服务器ip:3307/letfit?useSSL=false&amp;useUnicode=true&amp;characterEncoding=utf8&amp;serverTimezone=GMT</span></span><br><span class="line">      <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">    <span class="comment">#连接池</span></span><br><span class="line">    <span class="attr">druid:</span></span><br><span class="line">      <span class="attr">initialSize:</span> <span class="number">5</span></span><br><span class="line">      <span class="attr">minIdle:</span> <span class="number">5</span></span><br><span class="line">      <span class="attr">maxActive:</span> <span class="number">20</span></span><br><span class="line">      <span class="attr">maxWait:</span> <span class="number">60000</span></span><br><span class="line">      <span class="attr">timeBetweenEvictionRunsMillis:</span> <span class="number">60000</span></span><br><span class="line">      <span class="attr">minEvictableIdleTimeMillis:</span> <span class="number">300000</span></span><br><span class="line">      <span class="attr">validationQuery:</span> <span class="string">SELECT</span> <span class="number">1</span> <span class="string">FROM</span> <span class="string">DUAL</span></span><br><span class="line">      <span class="attr">testWhileIdle:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">testOnBorrow:</span> <span class="literal">false</span></span><br><span class="line">      <span class="attr">testOnReturn:</span> <span class="literal">false</span></span><br><span class="line">      <span class="attr">poolPreparedStatements:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">filters:</span> <span class="string">stat,wall</span></span><br><span class="line">      <span class="attr">maxPoolPreparedStatementPerConnectionSize:</span> <span class="number">20</span></span><br><span class="line">      <span class="attr">useGlobalDataSourceStat:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">connectionProperties:</span> <span class="string">druid.stat.mergeSql=true;druid.stat.slowSqlMillis=500</span></span><br></pre></td></tr></table></figure><ul><li><strong>创建 <code>ReadOnly</code> 注解</strong></li></ul><p>在业务层的方法上使用该注解，使用 <code>ReadOnly</code> 注解的方法只处理读操作，会切换到从机的数据源</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.letfit.aop.annotation;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 只读注解</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.METHOD, ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> ReadOnly &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>创建枚举类</strong></li></ul><p>定义两个枚举类型 <code>MASTER</code>、<code>slave</code>分别代表数据库类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.letfit.common;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 数据库类型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">DBTypeEnum</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 主数据库</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    MASTER,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从数据库</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    SLAVE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>编写动态切换数据源的工具类</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.letfit.util;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 动态切换数据源工具类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicDbUtil</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用来存储代表数据源的对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;DBTypeEnum&gt; CONTEXT_HAND = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 切换当前线程要使用的数据源</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> dbTypeEnum</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(DBTypeEnum dbTypeEnum)</span></span>&#123;</span><br><span class="line">        CONTEXT_HAND.set(dbTypeEnum);</span><br><span class="line">        log.info(<span class="string">&quot;切换数据源:&#123;&#125;&quot;</span>, dbTypeEnum);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 切换到主数据库</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">master</span><span class="params">()</span></span>&#123;</span><br><span class="line">        set(DBTypeEnum.MASTER);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 切换到从数据库</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">slave</span><span class="params">()</span></span>&#123;</span><br><span class="line">        set(DBTypeEnum.SLAVE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 移除当前线程使用的数据源</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span></span>&#123;</span><br><span class="line">        CONTEXT_HAND.remove();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取当前线程使用的枚举类</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DBTypeEnum <span class="title">get</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> CONTEXT_HAND.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>编写 <code>AbstractRoutingDataSource</code>的实现类</strong></li></ul><blockquote><p>Spring boot提供了AbstractRoutingDataSource 根据用户定义的规则选择当前的数据源，这样我们可以在执行查询之前，设置使用的数据源。实现可动态路由的数据源，在每次数据库查询操作前执行。它的抽象方法 determineCurrentLookupKey() 决定使用哪个数据源。</p></blockquote><p>AbstractRoutingDataSource 的部分源码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractRoutingDataSource</span> <span class="keyword">extends</span> <span class="title">AbstractDataSource</span> <span class="keyword">implements</span> <span class="title">InitializingBean</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 用来存储多个数据源</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;Object, Object&gt; targetDataSources;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 默认数据源</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">private</span> Object defaultTargetDataSource;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;Object, DataSource&gt; resolvedDataSources;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">private</span> DataSource resolvedDefaultDataSource;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AbstractRoutingDataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 设置多数据源，最终使用哪个数据源由determineTargetDataSource()返回决定</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTargetDataSources</span><span class="params">(Map&lt;Object, Object&gt; targetDataSources)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.targetDataSources = targetDataSources;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 设置默认数据源</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDefaultTargetDataSource</span><span class="params">(Object defaultTargetDataSource)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.defaultTargetDataSource = defaultTargetDataSource;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 决定使用的数据源，选择的策略需要我们自己去定义</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> DataSource <span class="title">determineTargetDataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Assert.notNull(<span class="keyword">this</span>.resolvedDataSources, <span class="string">&quot;DataSource router not initialized&quot;</span>);</span><br><span class="line">        <span class="comment">//调用determineCurrentLookupKey()获取数据源的key</span></span><br><span class="line">        Object lookupKey = <span class="keyword">this</span>.determineCurrentLookupKey();</span><br><span class="line">        <span class="comment">//根据key获取对应数据源</span></span><br><span class="line">        DataSource dataSource = (DataSource)<span class="keyword">this</span>.resolvedDataSources.get(lookupKey);</span><br><span class="line">        <span class="keyword">if</span> (dataSource == <span class="keyword">null</span> &amp;&amp; (<span class="keyword">this</span>.lenientFallback || lookupKey == <span class="keyword">null</span>)) &#123;</span><br><span class="line">            dataSource = <span class="keyword">this</span>.resolvedDefaultDataSource;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (dataSource == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Cannot determine target DataSource for lookup key [&quot;</span> + lookupKey + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> dataSource;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 抽象方法，需要我们自己去实现</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> Object <span class="title">determineCurrentLookupKey</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编写 <code>DynamicDataSource</code>继承 <code>AbstractRoutingDataSource</code>    </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.letfit.common;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicDataSource</span> <span class="keyword">extends</span> <span class="title">AbstractRoutingDataSource</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回当前线程正在使用代表数据库的枚举对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">determineCurrentLookupKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> DynamicDbUtil.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>流程步骤：</p><p>1、重写数据源选择策略determineCurrentLookupKey()。</p><p>2、数据源配置类将数据源存放在AbstractRoutingDataSource的 targetDataSources和defaultTargetDataSource中，然后通过afterPropertiesSet()方法将数据源分别进行复制到resolvedDataSources和resolvedDefaultDataSource中。</p><p>3、进行数据库连接时，调用AbstractRoutingDataSource的getConnection()的方法，此时会先调用determineTargetDataSource()方法返回DataSource再进行getConnection()。</p><ul><li><strong>编写多数据源配置类</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.letfit.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.druid.spring.boot.autoconfigure.DruidDataSourceBuilder;</span><br><span class="line"><span class="keyword">import</span> com.letfit.common.DBTypeEnum;</span><br><span class="line"><span class="keyword">import</span> com.letfit.common.DynamicDataSource;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Qualifier;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.context.properties.ConfigurationProperties;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Primary;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.sql.DataSource;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DataSourceConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 主数据库数据源，存入Spring容器</span></span><br><span class="line"><span class="comment">     * 注解<span class="doctag">@Primary</span>表示主数据源</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ConfigurationProperties(prefix = &quot;spring.datasource.master&quot;)</span></span><br><span class="line">    <span class="meta">@Primary</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">masterDataSource</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> DruidDataSourceBuilder.create().build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从数据库数据源，存入Spring容器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ConfigurationProperties(prefix = &quot;spring.datasource.slave&quot;)</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">slaveDataSource</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> DruidDataSourceBuilder.create().build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 决定最终数据源</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> masterDataSource</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> slaveDataSource</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">targetDataSource</span><span class="params">(<span class="meta">@Qualifier(&quot;masterDataSource&quot;)</span> DataSource masterDataSource, <span class="meta">@Qualifier(&quot;slaveDataSource&quot;)</span> DataSource slaveDataSource)</span></span>&#123;</span><br><span class="line">        <span class="comment">//存放主从数据源</span></span><br><span class="line">        Map&lt;Object,Object&gt; targetDataSource = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">2</span>);</span><br><span class="line">        <span class="comment">//主数据源</span></span><br><span class="line">        targetDataSource.put(DBTypeEnum.MASTER, masterDataSource);</span><br><span class="line">        <span class="comment">//从数据源</span></span><br><span class="line">        targetDataSource.put(DBTypeEnum.SLAVE, slaveDataSource);</span><br><span class="line">        <span class="comment">//实现动态切换</span></span><br><span class="line">        DynamicDataSource dynamicDataSource = <span class="keyword">new</span> DynamicDataSource();</span><br><span class="line">        <span class="comment">//绑定所有数据源</span></span><br><span class="line">        dynamicDataSource.setTargetDataSources(targetDataSource);</span><br><span class="line">        <span class="comment">//设置默认数据源</span></span><br><span class="line">        dynamicDataSource.setDefaultTargetDataSource(masterDataSource);</span><br><span class="line">        <span class="keyword">return</span> dynamicDataSource;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>配置Mybatis</strong></li></ul><p>当我们只有一个数据源时，SpringBoot会默认配置Mybatis，现在我们有多个数据源，就需要手动配置Mybatis的SqlSessionFactory</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.letfit.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.session.SqlSessionFactory;</span><br><span class="line"><span class="keyword">import</span> org.mybatis.spring.SqlSessionFactoryBean;</span><br><span class="line"><span class="keyword">import</span> org.mybatis.spring.SqlSessionTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Qualifier;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.io.support.PathMatchingResourcePatternResolver;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.datasource.DataSourceTransactionManager;</span><br><span class="line"><span class="keyword">import</span> org.springframework.transaction.PlatformTransactionManager;</span><br><span class="line"><span class="keyword">import</span> org.springframework.transaction.annotation.EnableTransactionManagement;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.Resource;</span><br><span class="line"><span class="keyword">import</span> javax.sql.DataSource;</span><br><span class="line"><span class="keyword">import</span> java.util.Objects;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 多数据源需要手动配置SqlSessionFactory</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableTransactionManagement</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MybatisConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource(name = &quot;targetDataSource&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> DataSource dataSource;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 配置SqlSessionFactory</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SqlSessionFactory <span class="title">sqlSessionFactory</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        SqlSessionFactoryBean factoryBean = <span class="keyword">new</span> SqlSessionFactoryBean();</span><br><span class="line">        factoryBean.setDataSource(dataSource);</span><br><span class="line">        <span class="comment">//配置映射文件路径</span></span><br><span class="line">        factoryBean.setMapperLocations(<span class="keyword">new</span> PathMatchingResourcePatternResolver().getResources(<span class="string">&quot;classpath:mapper/*.xml&quot;</span>));</span><br><span class="line">        <span class="comment">//配置别名</span></span><br><span class="line">        factoryBean.setTypeAliasesPackage(<span class="string">&quot;com.letfit.pojo&quot;</span>);</span><br><span class="line">        <span class="comment">//设置驼峰命名</span></span><br><span class="line">        Objects.requireNonNull(factoryBean.getObject()).getConfiguration().setMapUnderscoreToCamelCase(<span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">return</span> factoryBean.getObject();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 配置事务管理</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> PlatformTransactionManager <span class="title">transactionManager</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DataSourceTransactionManager(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SqlSessionTemplate <span class="title">sqlSessionTemplate</span><span class="params">(<span class="meta">@Qualifier(&quot;sqlSessionFactory&quot;)</span> SqlSessionFactory sqlSessionFactory)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SqlSessionTemplate(sqlSessionFactory);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>配置Aop</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.letfit.aop;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DataSourceAop</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Pointcut(&quot;@annotation(com.letfit.aop.annotation.ReadOnly)&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readPointcut</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 配置前置通知，切换数据源为从数据库</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Before(&quot;readPointcut()&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readAdvise</span><span class="params">()</span></span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;切换数据源为从数据库&quot;</span>);</span><br><span class="line">        DynamicDbUtil.slave();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>业务层方法上使用 <code>ReadOnly</code> 注解</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据标题关键字模糊查询资源</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> title</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@ReadOnly</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> ResultInfo&lt;List&lt;Source&gt;&gt; searchSource(String title) &#123;</span><br><span class="line">    <span class="keyword">if</span>(!ValiDateUtil.isLegalString(title))&#123;</span><br><span class="line">        <span class="keyword">return</span> ResultInfo.error(CodeEnum.PARAM_NOT_IDEAL, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;Source&gt; sourceList = sourceMapper.searchSource(title);</span><br><span class="line">    <span class="keyword">return</span> ResultInfo.success(CodeEnum.SUCCESS, sourceList);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/KIMTOU/img/raw/master/20210528134946.png" alt="从数据源"></p><ul><li>至此，读写分离的工作就完成了！</li></ul>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpingBoot </tag>
            
            <tag> MySQL </tag>
            
            <tag> java </tag>
            
            <tag> 环境配置 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于docker实现MySQL主从复制</title>
      <link href="/2021/05/27/%E5%9F%BA%E4%BA%8Edocker%E5%AE%9E%E7%8E%B0MySQL%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/"/>
      <url>/2021/05/27/%E5%9F%BA%E4%BA%8Edocker%E5%AE%9E%E7%8E%B0MySQL%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h2><h4 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h4><p>主从复制是MySQL提供的一种高可用高性能的解决方案。</p><p>工作原理分为以下3个步骤：</p><p>1、主库（master）把数据更改记录到<strong>二进制日志（binlog）</strong>中。</p><p>2、从库（slave）的<strong>I/O线程</strong>把主库的二进制日志读取保存到自己的<strong>中继日志（relay log）</strong>中。</p><p>3、从库的<strong>SQL线程</strong>执行中继日志，重做中继日志中的日志，即再执行一遍SQL，更新自己的数据库，以达到数据的一致性。</p><p><img src="https://gitee.com/KIMTOU/img/raw/master/20210528000926.png" alt="主从复制"></p><p>注意要点：</p><p>主从复制不是完全实时地进行同步，而是<strong>异步实时</strong>。从库同步主库数据的过程是串行化的，也就是说主库上并行的操作，在从库上会串行执行。由于从库从主库拷贝日志以及串行执行 SQL 的特点，会有<strong>主从同步时延</strong>，在高并发的情况下，该问题就越明显。</p><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><p>使用主从复制能够预防MySQ的单点故障，对数据进行备份。</p><p>在高并发下，需要对应用进行读写分离，配置多数据源，即写操作走主库，读操作则走从库，以减少锁的争用，此时也需要进行主从复制。</p><h4 id="部署数据库实例"><a href="#部署数据库实例" class="headerlink" title="部署数据库实例"></a>部署数据库实例</h4><p>1、拉取镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull mysql:5.7</span><br></pre></td></tr></table></figure><p>2、运行容器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 主库（端口3306）</span></span><br><span class="line">docker run -d -p 3306:3306 -e MYSQL_ROOT_PASSWORD=123456 --name master_mysql mysql:5.7</span><br><span class="line"><span class="meta">#</span><span class="bash"> 从库（端口3307）</span></span><br><span class="line">docker run -d -p 3307:3306 -e MYSQL_ROOT_PASSWORD=123456 --name slave_mysql mysql:5.7</span><br></pre></td></tr></table></figure><p>3、查看状态</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps#查看是否运行成功</span><br></pre></td></tr></table></figure><p>4、使用Navicat等数据库管理工具进行连接</p><h4 id="主从复制配置"><a href="#主从复制配置" class="headerlink" title="主从复制配置"></a>主从复制配置</h4><p><strong>一、配置主库</strong></p><ul><li>进入容器修改配置文件</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it master_mysql /bin/bash</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">由于容器内没有vim工具，需进行安装</span></span><br><span class="line">apt-get update</span><br><span class="line">apt-get install vim</span><br><span class="line"></span><br><span class="line">vim /etc/mysql/my.cnf</span><br></pre></td></tr></table></figure><ul><li>在 my.cnf 配置文件中添加如下代码</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">server-id=10</span><br><span class="line">log-bin=mysql-bin</span><br><span class="line">innodb_flush_log_at_trx_commit=1</span><br><span class="line">sync_binlog=1</span><br></pre></td></tr></table></figure><img src="https://gitee.com/KIMTOU/img/raw/master/20210528000934.PNG" alt="mycnf" style="zoom: 67%;" /><ul><li>进入<strong>主库</strong>为<strong>从库</strong>创建一个用户用来复制数据，从库通过这个用户连接至主库</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 登录mysql</span></span><br><span class="line">mysql -u root -p</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 创建用户</span></span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> CREATE user <span class="string">&#x27;slave&#x27;</span>@<span class="string">&#x27;%&#x27;</span> identified by <span class="string">&#x27;slave&#x27;</span>;</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 赋予权限</span></span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> GRANT REPLICATION SLAVE, REPLICATION CLIENT ON *.* TO <span class="string">&#x27;slave&#x27;</span>@<span class="string">&#x27;%&#x27;</span>;</span></span><br></pre></td></tr></table></figure><ul><li>查看主库状态</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> show master status;</span></span><br><span class="line">+------------------+----------+--------------+------------------+-------------------+</span><br><span class="line">| File             | Position | Binlog_Do_DB | Binlog_Ignore_DB | Executed_Gtid_Set |</span><br><span class="line">+------------------+----------+--------------+------------------+-------------------+</span><br><span class="line">| mysql-bin.000001 |     617  |              |                  |                   |</span><br><span class="line">+------------------+----------+--------------+------------------+-------------------+</span><br></pre></td></tr></table></figure><ul><li>重启生效</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker restart master_mysql</span><br></pre></td></tr></table></figure><p><strong>二、从库配置</strong></p><ul><li>同样的进入容器修改配置文件</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it slave_mysql /bin/bash</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">由于容器内没有vim工具，需进行安装</span></span><br><span class="line">apt-get update</span><br><span class="line">apt-get install vim</span><br><span class="line"></span><br><span class="line">vim /etc/mysql/my.cnf</span><br></pre></td></tr></table></figure><ul><li>在 my.cnf 配置文件中添加如下代码</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">server_id=11</span><br><span class="line">log-bin=mysql-slave-bin</span><br><span class="line">relay_log=edu-mysql-relay-bin</span><br></pre></td></tr></table></figure><ul><li>重启生效</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker restart slave_mysql</span><br></pre></td></tr></table></figure><p><strong>三、绑定主库</strong></p><ul><li>docker查看主mysql容器的ip</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker inspect --format=&#x27;&#123;&#123;.NetworkSettings.IPAddress&#125;&#125;&#x27; master_mysql</span><br></pre></td></tr></table></figure><ul><li>进入从库</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it slave_mysql /bin/bash</span><br><span class="line">mysql -u root -p</span><br></pre></td></tr></table></figure><ul><li>绑定主库</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> change master to master_host=<span class="string">&#x27;172.17.0.2&#x27;</span>, master_user=<span class="string">&#x27;slave&#x27;</span>, master_password=<span class="string">&#x27;slave&#x27;</span>, master_port=3306, master_log_file=<span class="string">&#x27;mysql-bin.000001&#x27;</span>, master_log_pos=617, master_connect_retry=30;</span></span><br></pre></td></tr></table></figure><p>这里的<strong>master_host</strong>为刚刚查到的<strong>主mysql容器的ip</strong>，是容器独立的ip </p><ul><li>查看从库的状态</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">show slave status \G;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 发现IO线程和SQL线程运行状态都为No，默认是没有开启，需要手动开启</span></span><br><span class="line">Slave_IO_Running: No</span><br><span class="line">Slave_SQL_Running: No</span><br></pre></td></tr></table></figure><ul><li>开启主从复制</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">start slave;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指 Offer 06.从尾到头打印链表</title>
      <link href="/2021/05/24/%E5%89%91%E6%8C%87-Offer-06-%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/"/>
      <url>/2021/05/24/%E5%89%91%E6%8C%87-Offer-06-%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><strong>输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）</strong></p><p>示例 1：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = <span class="comment">[1,3,2]</span></span><br><span class="line">输出：<span class="comment">[2,3,1]</span></span><br></pre></td></tr></table></figure><p>限制：</p><p><code>0 &lt;= 链表长度 &lt;= 10000</code></p><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><h4 id="方式一：递归法"><a href="#方式一：递归法" class="headerlink" title="方式一：递归法"></a>方式一：递归法</h4><p>解题思路：递归到链表尾端，在回溯时存入数组。</p><p>算法实现：</p><ul><li>变量：先创建一个result数组，用size变量记录当前数组的下标索引，node为当前链表结点。</li><li>递归结束条件：当链表结点为null，node==null。</li><li>结果：result即为逆序排列链表数值后的数组，根据size对数组做截断并返回即可。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10000</span>];</span><br><span class="line">    <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] reversePrint(ListNode head) &#123;</span><br><span class="line">        recurGet(head);</span><br><span class="line">        <span class="keyword">return</span> Arrays.copyOfRange(result,<span class="number">0</span>,size);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recurGet</span><span class="params">(ListNode node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        recurGet(node.next);</span><br><span class="line">        result[size++] = node.val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>复杂度分析：</p><ul><li>时间复杂度O(N)：遍历整个链表</li><li>空间复杂度：本解法创建了一个大小为链表长度最大值的数组，结果对其做截断处理，故空间大小即为链表长度最大值；也可以使用集合代替数组，则空间复杂度为O(N)</li></ul><h4 id="方法二：栈"><a href="#方法二：栈" class="headerlink" title="方法二：栈"></a>方法二：栈</h4><p>解题思路：由于栈具有先进后出的特点，故可用来将链表倒置。</p><p>算法实现：创建一个栈，顺序遍历链表便依次将结点值push入栈。最后根据栈的大小创建数组result，遍历栈赋值给数组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] reversePrint(ListNode head) &#123;</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack();</span><br><span class="line">        <span class="keyword">while</span>(head != <span class="keyword">null</span>)&#123;</span><br><span class="line">            stack.push(head.val);</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[stack.size()];</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">            result[i++] = stack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>复杂度分析：</p><ul><li>时间复杂度O(N): 先遍历链表给栈赋值（入栈），再遍历栈给数组赋值（出栈）</li><li>空间复杂度O(N): 栈与数组的大小均与链表长度有关</li></ul><h4 id="方法三：使用两个数组模拟栈"><a href="#方法三：使用两个数组模拟栈" class="headerlink" title="方法三：使用两个数组模拟栈"></a>方法三：使用两个数组模拟栈</h4><p>解题思路：遍历链表给第1个数组赋值，再将第1个数组逆序赋值给第2个数组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] reversePrint(ListNode head) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] node = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10000</span>];</span><br><span class="line">        <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(head!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            node[size++] = head.val;</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[size--];</span><br><span class="line">        <span class="keyword">while</span>(size&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            result[i++] = node[size--];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>写在开头</title>
      <link href="/2021/04/29/%E5%86%99%E5%9C%A8%E5%BC%80%E5%A4%B4/"/>
      <url>/2021/04/29/%E5%86%99%E5%9C%A8%E5%BC%80%E5%A4%B4/</url>
      
        <content type="html"><![CDATA[<h4 id="关于我"><a href="#关于我" class="headerlink" title="关于我"></a>关于我</h4><p>本人目前是软件工程专业的一名在读本科生，主要方向是java后台开发。平时也喜欢打篮球与听音乐，欢迎小伙伴与我交流，我的个人邮箱：<a href="mailto:&#x37;&#x35;&#x32;&#x31;&#54;&#x30;&#x36;&#x35;&#53;&#x40;&#113;&#113;&#x2e;&#x63;&#111;&#109;">&#x37;&#x35;&#x32;&#x31;&#54;&#x30;&#x36;&#x35;&#53;&#x40;&#113;&#113;&#x2e;&#x63;&#111;&#109;</a></p>]]></content>
      
      
      <categories>
          
          <category> 感想 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 感想 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
